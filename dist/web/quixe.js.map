{
  "version": 3,
  "sources": ["../../src/upstream/quixe/src/quixe/quixe.js", "../../src/upstream/quixe/src/quixe/gi_dispa.js", "../../src/upstream/quixe/src/quixe/gi_load.js", "../../src/common/quixe.js"],
  "sourcesContent": ["'use strict';\n\n/* Quixe -- a Glulx VM interpreter written in Javascript\n * Designed by Andrew Plotkin <erkyrath@eblong.com>\n * <http://eblong.com/zarf/glulx/quixe/>\n * \n * This Javascript library is copyright 2010-2021 by Andrew Plotkin.\n * It is distributed under the MIT license; see the \"LICENSE\" file.\n *\n * For documentation, see the README.txt or the web page noted above.\n * For information on getting Quixe installed on a web page, see the\n * comments in the gi_load.js file.\n *\n * This library makes use of jQuery utility functions (but it does not\n * manipulate DOM). It has been tested with jQuery 1.11.2 (included),\n * but should work equally well with jQuery 2.\n *\n *\n * Some interpreter behaviors can be customized by adding attributes to\n * the game_options object. (See gi_load.js for more about this object.)\n * Quixe currently understands these options:\n *\n *   log_execution_time: If true, a console message will be logged every\n *     turn, indicating how many milliseconds the turn took to execute.\n *\n *   rethrow_exceptions: If true, any fatal VM errors encountered during\n *     play will be allowed to bubble up to the browser. If you're using\n *     a browser debugging facility, this may give you more information\n *     than the usual red \"fatal-error\" banner.\n *\n *   debug_info_chunk: If true, Quixe loads a \"Dbug\" chunk from the\n *     blorb file. The chunk should contain the gameinfo.dbg data\n *     generated by the Inform compiler when the game was compiled.\n *\n *   do_vm_autosave: If true, Quixe tries to load an autosave file at\n *     startup (via the Dialog class) and then autosave every turn.\n *\n *   clear_vm_autosave: If true, Quixe will delete any autosave file\n *     at startup and then start up normally.\n *\n * The point of the debug_info_chunk option is that if a fatal error\n * occurs, the browser's debug console will show the I6 stack dump at\n * the point of the error; and this dump will contain both the name and\n * address of every I6 function on the stack.\n *\n * To set this up, you need to use the blorbtool.py script to add the\n * gameinfo.dbg file to the compiled blorb:\n *\n *   blorbtool.py test.gblorb import Dbug gameinfo.dbg\n *\n * Then add \"debug_info_chunk: true\" to the game_options object.\n */\n\n// ### Optimizations I have not yet tried:\n// Using JS array types. This didn't prove to be a speedup a few years\n//   ago, but maybe engines have improved. The raw Blorb loading delay\n//   might also benefit from this.\n// Change memory to an array of 4-byte values. Inline Mem4 and Mem4W when\n//   address is known to be aligned.\n// Inline Mem1 wherever possible.\n// Compile \"@mul 2 x\" amd \"@mul x 2\" as a bit-shift (similarly other\n//   power-of-2 constants).\n// Is \"x instanceof Function\" efficient? Should compile_string return a \n//   tiny tagged object instead?\n// Probably don't want to cache string-functions in filter mode.\n// If a compiled path has no iosys dependencies, we could cache it in\n//   all three iosys caches for the function.\n// Also: put in debug asserts for valid stack values (at push/pop)\n//   (check isFinite and non-negative)\n// Should we be caching arrays instead of strings?\n\n/* All state is contained in QuixeClass. */\n\nvar QuixeClass = function() {\n\n/* Create the \"self\" object. (No relation to the Inform \"self\" global.) */\nvar self = {};\n\n/* This is called by the page (or the page's loader library) when it\n   starts up. It must be called before quixe_start().\n\n   (NOTE: In older versions of this code, quixe_init() was called\n   quixe_prepare(), and quixe_start() was called quixe_init(). This was\n   confusing and inconsistent with the rest of the ecosystem. I renamed\n   them as of 2.2.0.)\n\n   The first argument is the game file image, encoded as an array of byte\n   values (integers between 0 and 255). It is stashed away for when\n   the game is started up.\n\n   The (optional) second object supplies execution options.\n\n   This also computes the game signature, which is a 64-character string\n   unique to the game. (In fact it is just the first 64 bytes of the\n   game file, encoded as hexadecimal digits.)\n*/\nfunction quixe_init(image, all_options) {\n    self.GiDispa = all_options.GiDispa;\n    self.GiLoad = all_options.GiLoad;\n    self.Glk = all_options.io;\n    \n    game_image = image;\n\n    var ls = game_image.slice(0, 64);\n    var ix, val;\n    for (ix=0; ix<ls.length; ix++) {\n        val = ls[ix].toString(16);\n        if (val.length < 2)\n            val = \"0\" + val;\n        ls[ix] = val;\n    }\n    game_signature = ls.join('');\n\n    if (all_options) {\n        opt_log_execution_time = all_options.log_execution_time;\n        opt_rethrow_exceptions = all_options.rethrow_exceptions;\n        opt_do_vm_autosave = all_options.do_vm_autosave;\n        opt_clear_vm_autosave = all_options.clear_vm_autosave;\n    }\n\n    if (all_options && all_options.debug_info_chunk) {\n        parse_inform_debug_data();\n    }\n}\n\nfunction quixe_inited() {\n    return (game_image != null);\n}\n\nfunction quixe_getlibrary(val) {\n    switch (val) {\n        case 'GiDispa': return self.GiDispa;\n        case 'GiLoad': return self.GiLoad;\n        case 'Glk': return self.Glk;\n        case 'GlkOte': return self.Glk.getlibrary('GlkOte');\n        case 'Dialog': return self.Glk.getlibrary('Dialog');\n    }\n    /* Unrecognized library name. */\n    return null;\n}\n    \n/* This is called by the page (or the page's display library) when it\n   starts up. It executes until the first glk_select() or glk_exit().\n*/\nfunction quixe_start() {\n    if (self.vm_started) {\n        self.Glk.fatal_error(\"Quixe was inited twice!\");\n        return;\n    }\n\n    try {\n        setup_bytestring_table();\n        setup_operandlist_table();\n\n        setup_vm();\n        execute_loop();\n    }\n    catch (ex) {\n        if (ex.stack)\n            qlog('JS stack dump A:\\n' + ex.stack);\n        qstackdump();\n        self.Glk.fatal_error(\"Quixe init: \" + show_exception(ex));\n        if (true || opt_rethrow_exceptions)\n            throw ex;\n    }\n}\n\n/* This is called by the page after a \"blocking\" operation completes.\n   (That is, a user event has triggered the completion of glk_select()\n   or glk_fileref_create_by_prompt().)\n   It executes until the next glk_select() or glk_exit().\n\n   The argument is only defined when resuming from an operation that\n   returns a value -- i.e. glk_fileref_create_by_prompt(). But we ignore\n   it anyhow, because that return value was handled by GiDispa. (See\n   SetResumeStore() below.)\n*/\nfunction quixe_resume(argument) {\n    try {\n        self.done_executing = self.vm_stopped;\n        execute_loop();\n    }\n    catch (ex) {\n        if (ex.stack)\n            qlog('JS stack dump B:\\n' + ex.stack);\n        qstackdump();\n        self.Glk.fatal_error(\"Quixe run: \" + show_exception(ex));\n        if (opt_rethrow_exceptions)\n            throw ex;\n    }\n}\n\n/* Exception objects are hard to display in Javascript. This is a rough\n   attempt.\n*/\nfunction show_exception(ex) {\n    if (typeof(ex) == 'string')\n        return ex;\n    var res = ex.toString();\n    if (ex.message)\n        res = res + ' ' + ex.message;\n    if (ex.fileName)\n        res = res + ' ' + ex.fileName;\n    if (ex.lineNumber)\n        res = res + ' line:' + ex.lineNumber;\n    if (ex.name)\n        res = res + ' ' + ex.name;\n    if (ex.number)\n        res = res + ' ' + ex.number;\n    return res;\n}\n\n/* Log the message in the browser's error log, if it has one. (This shows\n   up in Safari, in Opera, and in Firefox if you have Firebug installed.)\n*/\nfunction qlog(msg) {\n    if (window.console && console.log)\n        console.log(msg);\n    else if (window.opera && opera.postError)\n        opera.postError(msg);\n}\n\n/* This returns a string displaying an object and all its properties.\n   It's not used in the normal course of execution, but some (commented-out)\n   debug log message use it.\n*/\nfunction qobjdump(obj, depth) {\n    var key, proplist;\n\n    if (jQuery.type(obj) === 'array') {\n        if (depth)\n            depth--;\n        var ls = jQuery.map(obj, function(v, ix) {return qobjdump(v, depth);});\n        return (\"[\" + ls.join(\",\") + \"]\");\n    }\n    if (!(jQuery.type(obj) === 'object'))\n        return (\"\"+obj);\n\n    proplist = [ ];\n    for (key in obj) {\n        var val = obj[key];\n        if (depth && jQuery.type(val) === 'object')\n            val = qobjdump(val, depth-1);\n        proplist.push(key + \":\" + val);\n    }\n    return \"{ \" + proplist.join(\", \") + \" }\";\n}\n\n/* Print the VM stack as a log message.\n */\nfunction qstackdump() {\n    if (!stack || !stack.length)\n        return;\n    var ix, val, debugfunc;\n    var frm;\n    var ls = [];\n    for (ix=0; ix<stack.length; ix++) {\n        frm = stack[ix];\n        if (!frm.vmfunc.funcaddr) {\n            // Can't get information from a ghost vmfunc.\n            ls.push(\"(anonymous)\");\n            continue;\n        }\n        val = \"0x\"+frm.vmfunc.funcaddr.toString(16);\n        debugfunc = debuginfo.functionmap[frm.vmfunc.funcaddr];\n        if (debugfunc)\n            val = val + (\" \\\"\" + debugfunc.name + \"\\\"\");\n        ls.push(val);\n    }\n    qlog(\"VM stack dump: \" + ls.join(\", \"));\n}\n\n/* Polyfill for Math.imul, if necessary. (This affects the global Math\n   namespace at load time, which is ugly, but only on ancient browsers.)\n*/\nif (Math.imul === undefined) {\n    qlog(\"Polyfilling Math.imul().\");\n    /* Code from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul */\n    Math.imul = function(a, b) {\n        var ah = (a >>> 16) & 0xffff;\n        var al = a & 0xffff;\n        var bh = (b >>> 16) & 0xffff;\n        var bl = b & 0xffff;\n        // the shift by 0 fixes the sign on the high part\n        // the final |0 converts the unsigned value into a signed value\n        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);\n    };\n}\n\n/* Fast char-to-hex and char-to-quoted-char conversion tables. \n   setup_bytestring_table() is called once, at startup time.\n*/\nvar bytestring_table = Array(256);\nvar quotechar_table = Array(256);\nfunction setup_bytestring_table() {\n    var ix, val;\n    for (ix=0; ix<0x100; ix++) {\n        val = ix.toString(16);\n        if (ix<0x10)\n            val = \"0\" + val;\n        bytestring_table[ix] = val;\n    }\n\n    for (ix=0; ix<0x100; ix++) {\n        if (ix >= 0x20 && ix < 0x7f) {\n            /* Escape quote, double-quote, backslash. */\n            if (ix == 0x22 || ix == 0x27 || ix == 0x5c)\n                val = \"\\\\\"+String.fromCharCode(ix);\n            else\n                val = String.fromCharCode(ix);\n        }\n        else if (ix == 0x0a) {\n            val = \"\\\\n\";\n        }\n        else {\n            val = \"\\\\x\" + bytestring_table[ix];\n        }\n        quotechar_table[ix] = val;\n    }\n}\n\n/* Functions to read values from memory (or other byte-arrays). These must\n   always produce unsigned integers.\n\n   We use arithmetic rather than bitwise operations. *,+ are slightly slower\n   than <<,| but *,+ produce positive results, whereas <<,| produces a signed\n   result for values over 0x80000000. So we save the cost of the >>>0, which\n   is worthwhile.\n*/\n\nfunction ByteRead4(arr, addr) {\n    return (arr[addr] * 0x1000000) + (arr[addr+1] * 0x10000) \n        + (arr[addr+2] * 0x100) + (arr[addr+3]);\n}\nfunction ByteRead2(arr, addr) {\n    return (arr[addr] * 0x100) + (arr[addr+1]);\n}\nfunction ByteRead1(arr, addr) {\n    return arr[addr];\n}\n\nfunction Mem1(addr) {\n    return memmap[addr];\n}\nfunction Mem2(addr) {\n    return (memmap[addr] * 0x100) + (memmap[addr+1]);\n}\nfunction Mem4(addr) {\n    return (memmap[addr] * 0x1000000) + (memmap[addr+1] * 0x10000) \n        + (memmap[addr+2] * 0x100) + (memmap[addr+3]);\n}\nfunction MemSlice(addr, length) {\n    return memmap.slice(addr, addr + length);\n}\nfunction MemW1(addr, val) {\n    // ignore high bytes if necessary\n    memmap[addr] = val & 0xFF;\n}\nfunction MemW2(addr, val) {\n    // ignore high bytes if necessary\n    memmap[addr] = (val >> 8) & 0xFF;\n    memmap[addr+1] = val & 0xFF;\n}\nfunction MemW4(addr, val) {\n    memmap[addr]   = (val >> 24) & 0xFF;\n    memmap[addr+1] = (val >> 16) & 0xFF;\n    memmap[addr+2] = (val >> 8) & 0xFF;\n    memmap[addr+3] = val & 0xFF;\n}\n\nself.Mem1 = Mem1;\nself.Mem2 = Mem2;\nself.Mem4 = Mem4;\nself.MemSlice = MemSlice;\nself.MemW1 = MemW1;\nself.MemW2 = MemW2;\nself.MemW4 = MemW4;\n\nfunction BytePushString(arr, str) {\n    for (var ix = 0; ix < str.length; ix++) {\n        arr.push(str.charCodeAt(ix));\n    }\n}\nfunction BytePush4(arr, val) {\n    arr.push((val >> 24) & 0xFF);\n    arr.push((val >> 16) & 0xFF);\n    arr.push((val >> 8) & 0xFF);\n    arr.push(val & 0xFF);\n}\nfunction BytePush2(arr, val) {\n    arr.push((val >> 8) & 0xFF);\n    arr.push(val & 0xFF);\n}\nfunction BytePush1(arr, val) {\n    arr.push(val & 0xFF);\n}\nfunction ByteWrite4(arr, addr, val) {\n    arr[addr]   = (val >> 24) & 0xFF;\n    arr[addr+1] = (val >> 16) & 0xFF;\n    arr[addr+2] = (val >> 8) & 0xFF;\n    arr[addr+3] = val & 0xFF;\n}\nfunction ByteReadString(arr, addr, len) {\n    return String.fromCharCode.apply(this, arr.slice(addr, addr+len));\n}\n\nfunction QuoteMem1(addr) {\n    if (memmap[addr] >= 0x80)\n        return \"0xffffff\" + bytestring_table[memmap[addr]];\n    return \"0x\" + bytestring_table[memmap[addr]];\n}\nfunction QuoteMem2(addr) {\n    if (memmap[addr] >= 0x80) \n        return \"0xffff\" + bytestring_table[memmap[addr]] + bytestring_table[memmap[addr+1]];\n    if (memmap[addr]) \n        return \"0x\" + bytestring_table[memmap[addr]] + bytestring_table[memmap[addr+1]];\n    return \"0x\" + bytestring_table[memmap[addr+1]];\n}\nfunction QuoteMem4(addr) {\n    if (memmap[addr]) \n        return \"0x\" + bytestring_table[memmap[addr]] + bytestring_table[memmap[addr+1]] + bytestring_table[memmap[addr+2]] + bytestring_table[memmap[addr+3]];\n    if (memmap[addr+1]) \n        return \"0x\" + bytestring_table[memmap[addr+1]] + bytestring_table[memmap[addr+2]] + bytestring_table[memmap[addr+3]];\n    if (memmap[addr+2]) \n        return \"0x\" + bytestring_table[memmap[addr+2]] + bytestring_table[memmap[addr+3]];\n    return \"0x\" + bytestring_table[memmap[addr+3]];\n}\n\nfunction ReadArgByte(addr) {\n    if (addr == 0xffffffff)\n        return self.frame.valstack.pop() & 0xFF;\n    else\n        return Mem1(addr);\n}\n\nfunction WriteArgByte(addr, val) {\n    if (addr == 0xffffffff)\n        self.frame.valstack.push(val & 0xFF);\n    else\n        MemW1(addr, val);\n}\n\nfunction ReadArgWord(addr) {\n    if (addr == 0xffffffff)\n        return self.frame.valstack.pop();\n    else\n        return Mem4(addr);\n}\n\nfunction WriteArgWord(addr, val) {\n    if (addr == 0xffffffff)\n        self.frame.valstack.push(val);\n    else\n        MemW4(addr, val);\n}\n\nfunction ReadStructField(addr, fieldnum) {\n    if (addr == 0xffffffff)\n        return self.frame.valstack.pop();\n    else\n        return Mem4(addr + 4*fieldnum);\n}\n\nfunction WriteStructField(addr, fieldnum, val) {\n    if (addr == 0xffffffff)\n        self.frame.valstack.push(val);\n    else\n        MemW4(addr + 4*fieldnum, val);\n}\n\n/* GiDispa calls this, right before resuming execution at the end of a\n   blocking Glk call. The value passed in is the result of the Glk\n   call, which may have to be stored in a local variable or wherever.\n   (This is only really relevant for glk_fileref_create_by_prompt(),\n   since it's the only non-void blocking Glk call.)\n*/\nfunction SetResumeStore(val) {\n    self.resumevalue = val;\n}\n\n/* Convert a 32-bit Unicode value to a JS string. */\nfunction CharToString(val) {\n    if (val < 0x10000) {\n        return String.fromCharCode(val);\n    }\n    else {\n        val -= 0x10000;\n        return String.fromCharCode(0xD800 + (val >> 10), 0xDC00 + (val & 0x3FF));\n    }\n}\n\n/* Convert a 32-bit Unicode value to a fragment of a JS string literal.\n   That is, eval('\"'+QuoteCharToString(val)+'\"') == CharToString(val).\n*/\nfunction QuoteCharToString(val) {\n    if (val < 0x100) {\n        return quotechar_table[val];\n    }\n    else if (val < 0x10000) {\n        val = val.toString(16);\n        while (val.length < 4)\n            val = \"0\"+val;\n        return (\"\\\\u\" + val);\n    }\n    else {\n        var val2;\n        val -= 0x10000;\n        val2 = 0xD800 + (val >> 10);\n        val = 0xDC00 + (val & 0x3FF);\n        return (\"\\\\u\" + val2.toString(16) + \"\\\\u\" + val.toString(16));\n    }\n}\n\n/* Turn a length-1 string to a fragment of a JS string literal.\n*/\nfunction QuoteStr1ToString(val) {\n    return QuoteCharToString(val.charCodeAt(0));\n}\n\nvar regexp_string_unsafe = /[^a-zA-Z0-9 .,;:?!=_+()-]/g;\n\nfunction QuoteEscapeString(val) {\n    val = val.replace(regexp_string_unsafe, QuoteStr1ToString);\n    return '\"' + val + '\"';\n}\n\n/* All fatal errors in the interpreter call this. It just converts the\n   arguments to a nicely-formatted string, and then throws the string\n   as an exception. The top-level quixe_start() or quixe_resume() will\n   catch the exception and display it.\n*/\nfunction fatal_error(msg) {\n    var ix, val;\n    if (arguments.length > 1) {\n        msg += \" (\";\n        for (ix = 1; ix < arguments.length; ix++) {\n            val = arguments[ix];\n            if (typeof(val) == 'number') {\n                val = val.toString(16);\n            }\n            else {\n                val = \"\"+val;\n            }\n            if (ix != 1)\n                msg += \" \";\n            msg += val;\n        }\n        msg += \")\";\n    }\n    qlog(msg);//###debug\n    throw(new Error(msg));\n}\nself.fatal_error = fatal_error;\n\n/* Turn a string containing JS statements into a function object that\n   executes those statements. The funcname is unfortunately not used.\n   (This function used to use eval(), which let you sneak the funcname\n   in for debugging purposes.)\n\n   The function runs in global scope, rather than our Quixe environment.\n   Private Quixe variables are not available. To work around this, the\n   function's first argument must be \"self\"; the caller must pass in the\n   global self object.\n\n   If arg1, arg2 are provided, they become additional function arguments.\n   (Currently limited to two.)\n*/\nfunction make_code(val, funcname, arg1, arg2) {\n    var func;\n    if (funcname === undefined)\n        funcname = '_func';\n    if (arg1 === undefined)\n        func = new Function('self', val);\n    else if (arg2 === undefined)\n        func = new Function('self', arg1, val);\n    else\n        func = new Function('self', arg1, arg2, val);\n    return func;\n}\n\n/* Constructor: VMFunc\n\n   Everything we know about a function. This includes the layout of the local\n   variables, the compiled paths for various start points within the function,\n   and the addresses known to be start points.\n\n   If the function is not in ROM, we still create this, but we will not\n   add it to the permanent vmfunc_table.\n*/\nfunction VMFunc(funcaddr, startpc, localsformat, rawformat) {\n    if (!funcaddr) {\n        this.funcaddr = null;\n        this.startpc = null;\n        this.functype = null;\n    }\n    else {\n        this.funcaddr = funcaddr;\n        this.startpc = startpc;\n        this.functype = Mem1(funcaddr); /* 0xC0 or 0xC1 */\n    }\n\n    /* Addresses of all known (or predicted) paths for this function. */\n    this.pathaddrs = {};\n    /* The path tables for the various iosys modes. And yes, they are keyed\n       on integers. */\n    this[0] = {};\n    this[1] = {};\n    this[2] = {};\n\n    this.locallen = null;\n    this.localsformat = localsformat; /* array of {size, count} */\n    this.rawformat = rawformat; /* array of bytes (multiple of 4) */\n    this.localsindex = []; /* array of {size, pos} */\n\n    /* Create a locals index, according to the format. This will \n       contain one {size, pos} per local.\n\n       This is wacky, because it's not a simple list of values. A local is\n       accessed by its byte position, assuming the \"natural\" four-byte word\n       size. So the first (4-byte) local will be locals[0], the second will \n       be locals[4], and so on. In-between values will be undefined. */\n    var ix, jx;\n    var locallen = 0;\n    for (ix=0; ix<this.localsformat.length; ix++) {\n        var form = this.localsformat[ix];\n\n        /* Pad to 4-byte or 2-byte alignment if these locals are 4 or 2\n           bytes long. */\n        if (form.size == 4) {\n            while (locallen & 3)\n                locallen++;\n        }\n        else if (form.size == 2) {\n            while (locallen & 1)\n                locallen++;\n        }\n        /* else no padding */\n\n        for (jx=0; jx<form.count; jx++) {\n            this.localsindex.push({ size:form.size, pos:locallen });\n            locallen += form.size;\n        }\n    }\n\n    /* Pad the locals to 4-byte alignment. */\n    while (locallen & 3)\n        locallen++;\n    this.locallen = locallen;\n}\n\n/* Constructor: StackFrame\n\n   One stack frame on the execution stack. This includes local variables\n   and the value stack. It does not contain the spec-defined byte sequence\n   for the stack frame; we generate that at save time.\n\n   If we're deserializing a saved game, the vmfunc isn't a \"real\" vmfunc,\n   but a ghost built from the saved stack frame. In particular, \n   vmfunc.funcaddr and vmfunc.startpc are null.\n*/\nfunction StackFrame(vmfunc) {\n    var ix;\n\n    this.vmfunc = vmfunc; /* the VMFunc that is running in this frame */\n    this.depth = null;\n    this.framestart = null; /* stack position where this frame starts */\n    this.framelen = null; /* as in C */\n    this.valstack = [];\n    this.localspos = null; /* as in C */\n\n    this.localsindex = vmfunc.localsindex;\n    this.locals = [];\n\n    /* Create a locals array, according to the index. All locals begin \n       with a value of zero. */\n    for (ix=0; ix<this.localsindex.length; ix++) {\n        var form = this.localsindex[ix];\n        this.locals[form.pos] = 0;\n    }\n\n    /* Note: I tried building that array in the VMFunc constructor,\n       so that I could do a fast clone here. Turns out it was\n       actually slower that way. Pity. */\n\n    this.framelen = 8 + vmfunc.rawformat.length + vmfunc.locallen;\n\n    //qlog(\"### frame for \" + vmfunc.funcaddr.toString(16) + \": framelen \" + this.framelen + \", locindex \" + qobjdump(this.localsindex) + \", locals \" + qobjdump(this.locals));\n}\n\n/* Make a deep copy of a stack frame. This is used in vm_saveundo().\n*/\nfunction clone_stackframe(frame) {\n    var other = new StackFrame(frame.vmfunc);\n    other.depth = frame.depth;\n    other.framestart = frame.framestart;\n    other.framelen = frame.framelen;\n    other.valstack = frame.valstack.slice(0);\n    other.localspos = frame.localspos;\n    other.locals = frame.locals.slice(0);\n    other.framelen = frame.framelen;\n    return other;\n}\n\n/* Serialize a stack frame and push it onto the end of a byte array.\n   The frame must end in a call stub (or we won't be able to read it back in).\n   See the spec at http://www.eblong.com/zarf/glulx/glulx-spec_1.html#s.3.1\n*/\nfunction push_serialized_stackframe(frame, arr) {\n    // Frame length and format of locals.\n    BytePush4(arr, frame.framelen);\n    var rawformat = frame.vmfunc.rawformat;\n    BytePush4(arr, 8 + rawformat.length);\n    for (var i = 0; i < rawformat.length; i++) {\n        arr.push(rawformat[i]);\n    }\n    \n    // Local variables, plus any necessary padding.\n    for (var i = 0; i < frame.vmfunc.localsindex.length; i++) {\n        var form = frame.vmfunc.localsindex[i];\n        if (form.size == 4) {\n            while (arr.length & 3)\n                arr.push(0);\n            BytePush4(arr, frame.locals[form.pos]);\n        }\n        else if (form.size == 2) {\n            while (arr.length & 1)\n                arr.push(0);\n            BytePush2(arr, frame.locals[form.pos]);\n        }\n        else {\n            BytePush1(arr, frame.locals[form.pos]);\n        }\n    }\n    while (arr.length & 3)\n        arr.push(0);\n    \n    // Value stack.\n    for (var i = 0; i < frame.valstack.length; i++) {\n        BytePush4(arr, frame.valstack[i]);\n    }\n}\n    \n/* Pop a stack frame from the end of the given byte array.\n   Returns a deserialized StackFrame object, or undefined on failure.\n */\nfunction pop_deserialized_stackframe(arr) {\n    // The last 4 bytes should be the frame pointer.\n    var frameptr = ByteRead4(arr, arr.length - 4);\n    if (frameptr < 0 || frameptr >= arr.length) {\n        qlog(\"Bad frameptr in serialized stack frame\");\n        return undefined;\n    }\n    arr = arr.splice(frameptr, arr.length);\n    \n    // Frame length and locals format. We'll need this to build a fake\n    // stack frame.\n    var framelen = ByteRead4(arr, 0);\n    var localspos = ByteRead4(arr, 4);\n\n    var rawformat = arr.slice(8, localspos);\n\n    /* Go through the function's locals-format list, and construct a\n       slightly nicer description of the locals. (An array of [size, num].) */\n    var localsformat = [];\n    var addr = 8;\n    while (1) {\n        /* Grab two bytes from the locals-format list. These are \n           unsigned (0..255 range). */\n        var loctype = ByteRead1(arr, addr);\n        addr++;\n        var locnum = ByteRead1(arr, addr);\n        addr++;\n\n        if (loctype == 0) {\n            break;\n        }\n        if (loctype != 1 && loctype != 2 && loctype != 4) {\n            fatal_error(\"Invalid local variable size in function header.\", loctype);\n        }\n        \n        localsformat.push({ size:loctype, count:locnum });\n    }\n\n    // Build the fake VMFunc that will serve this stack frame.\n    var vmfunc = new VMFunc(null, null, localsformat, rawformat);\n    \n    // Build an empty frame.\n    var frame = new StackFrame(vmfunc);\n    frame.framestart = frameptr;\n    \n    // Load the local variables.\n    for (var i = 0; i < frame.vmfunc.localsindex.length; i++) {\n        var form = frame.vmfunc.localsindex[i];\n        if (form.size == 4) {\n            frame.locals[form.pos] = ByteRead4(arr, localspos + form.pos);\n        }\n        else if (form.size == 2) {\n            frame.locals[form.pos] = ByteRead2(arr, localspos + form.pos);\n        }\n        else {\n            frame.locals[form.pos] = ByteRead1(arr, localspos + form.pos);\n        }\n    }\n    \n    // Load the stack variables.\n    for (var pos = framelen; pos < arr.length; pos += 4) {\n        frame.valstack.push(ByteRead4(arr, pos));\n    }\n    \n    return frame;\n}\n\n/* Constructor: VMTextEnv\n\n   Represents all the cached string-table information for when stringtable\n   is addr. This includes the decoding table, and the compiled strings\n   for each address that's been printed.\n\n   If the table is not in ROM, there is no cached information. We still\n   make a VMTextEnv, but it's empty.\n*/\nfunction VMTextEnv(addr, dectab) {\n    if (addr == 0)\n        fatal_error(\"Tried to create a VMTextEnv for address zero.\");\n\n    this.addr = addr;\n    this.cacheable = (dectab !== undefined);\n    this.decoding_tree = dectab;\n\n    /* The string tables for the various iosys modes. */\n    this.vmstring_tables = [];\n    if (this.cacheable) {\n        this.vmstring_tables[0] = {};\n        this.vmstring_tables[1] = {};\n        this.vmstring_tables[2] = {};\n    }\n}\n\nvar operandlist_table = null;\n\n/* This is called once, at startup time. */\nfunction setup_operandlist_table() {\n    /* Constructor: OperandList */\n    function OperandList(formlist, argsize) {\n        this.argsize = (argsize ? argsize : 4);\n        this.numops = formlist.length;\n        var ls = [];\n        for (var ix=0; ix<formlist.length; ix++)\n            ls.push(formlist.charAt(ix));\n        this.formlist = ls;\n    }\n    var list_none = new OperandList(\"\");\n    var list_L = new OperandList(\"L\");\n    var list_LL = new OperandList(\"LL\");\n    var list_LLL = new OperandList(\"LLL\");\n    var list_LLLL = new OperandList(\"LLLL\");\n    var list_LS = new OperandList(\"LS\");\n    var list_LLS = new OperandList(\"LLS\");\n    var list_LLLLLLS = new OperandList(\"LLLLLLS\");\n    var list_LLLLLLLS = new OperandList(\"LLLLLLLS\");\n    var list_LLSS = new OperandList(\"LLSS\");\n    var list_LC = new OperandList(\"LC\");\n    var list_LLC = new OperandList(\"LLC\");\n    var list_LLLC = new OperandList(\"LLLC\");\n    var list_LLLLC = new OperandList(\"LLLLC\");\n    var list_ES = new OperandList(\"ES\");\n    var list_LES = new OperandList(\"LES\");\n    var list_EES = new OperandList(\"EES\");\n    var list_F = new OperandList(\"F\");\n    var list_LF = new OperandList(\"LF\");\n    var list_LLF = new OperandList(\"LLF\");\n    var list_EF = new OperandList(\"EF\");\n    var list_1EF = new OperandList(\"EF\", 1);\n    var list_2EF = new OperandList(\"EF\", 2);\n    var list_S = new OperandList(\"S\");\n    var list_SS = new OperandList(\"SS\");\n    var list_CL = new OperandList(\"CL\");\n    var list_C = new OperandList(\"C\");\n    operandlist_table = { \n        0x00: list_none, /* nop */\n        0x10: list_EES, /* add */\n        0x11: list_LES, /* sub */\n        0x12: list_LLS, /* mul */\n        0x13: list_LLS, /* div */\n        0x14: list_LLS, /* mod */\n        0x15: list_ES, /* neg */\n        0x18: list_EES, /* bitand */\n        0x19: list_EES, /* bitor */\n        0x1A: list_EES, /* bitxor */\n        0x1B: list_ES, /* bitnot */\n        0x1C: list_LLS, /* shiftl */\n        0x1D: list_LLS, /* sshiftr */\n        0x1E: list_LLS, /* ushiftr */\n        0x20: list_L, /* jump */\n        0x22: list_LL, /* jz */\n        0x23: list_LL, /* jnz */\n        0x24: list_LLL, /* jeq */\n        0x25: list_LLL, /* jne */\n        0x26: list_LLL, /* jlt */\n        0x27: list_LLL, /* jge */\n        0x28: list_LLL, /* jgt */\n        0x29: list_LLL, /* jle */\n        0x2A: list_LLL, /* jltu */\n        0x2B: list_LLL, /* jgeu */\n        0x2C: list_LLL, /* jgtu */\n        0x2D: list_LLL, /* jleu */\n        0x30: list_LLC, /* call */\n        0x31: list_L, /* return */\n        0x32: list_CL, /* catch */\n        0x33: list_LL, /* throw */\n        0x34: list_LL, /* tailcall */\n        0x40: list_EF, /* copy */\n        0x41: list_2EF, /* copys */\n        0x42: list_1EF, /* copyb */\n        0x44: list_LS, /* sexs */\n        0x45: list_LS, /* sexb */\n        0x48: list_LLS, /* aload */\n        0x49: list_LLS, /* aloads */\n        0x4A: list_LLS, /* aloadb */\n        0x4B: list_LLS, /* aloadbit */\n        0x4C: list_LLL, /* astore */\n        0x4D: list_LLL, /* astores */\n        0x4E: list_LLL, /* astoreb */\n        0x4F: list_LLL, /* astorebit */\n        0x50: list_F, /* stkcount */\n        0x51: list_LF, /* stkpeek */\n        0x52: list_none, /* stkswap */\n        0x53: list_LL, /* stkroll */\n        0x54: list_L, /* stkcopy */\n        0x70: list_L, /* streamchar */\n        0x71: list_L, /* streamnum */\n        0x72: list_L, /* streamstr */\n        0x73: list_L, /* streamunichar */\n        0x100: list_LLS, /* gestalt */\n        0x101: list_L, /* debugtrap */\n        0x102: list_S, /* getmemsize */\n        0x103: list_LS, /* setmemsize */\n        0x104: list_L, /* jumpabs */\n        0x110: list_LS, /* random */\n        0x111: list_L, /* setrandom */\n        0x120: list_none, /* quit */\n        0x121: list_S, /* verify */\n        0x122: list_none, /* restart */\n        0x123: list_LC, /* save */\n        0x124: list_LF, /* restore */\n        0x125: list_C, /* saveundo */\n        0x126: list_F, /* restoreundo */\n        0x127: list_LL, /* protect */\n        0x130: list_LLF, /* glk */\n        0x140: list_S, /* getstringtbl */\n        0x141: list_L, /* setstringtbl */\n        0x148: list_SS, /* getiosys */\n        0x149: list_LL, /* setiosys */\n        0x150: list_LLLLLLLS, /* linearsearch */\n        0x151: list_LLLLLLLS, /* binarysearch */\n        0x152: list_LLLLLLS, /* linkedsearch */\n        0x160: list_LC, /* callf */\n        0x161: list_LLC, /* callfi */\n        0x162: list_LLLC, /* callfii */\n        0x163: list_LLLLC, /* callfiii */\n        0x170: list_LL, /* mzero */\n        0x171: list_LLL, /* mcopy */\n        0x178: list_LS, /* malloc */\n        0x179: list_L, /* mfree */\n        0x180: list_LL, /* accelfunc */\n        0x181: list_LL, /* accelparam */\n        0x190: list_LS, /* numtof */\n        0x191: list_LS, /* ftonumz */\n        0x192: list_LS, /* ftonumn */\n        0x198: list_LS, /* ceil */\n        0x199: list_LS, /* floor */\n        0x1A0: list_LLS, /* fadd */\n        0x1A1: list_LLS, /* fsub */\n        0x1A2: list_LLS, /* fmul */\n        0x1A3: list_LLS, /* fdiv */\n        0x1A4: list_LLSS, /* fmod */\n        0x1A8: list_LS, /* sqrt */\n        0x1A9: list_LS, /* exp */\n        0x1AA: list_LS, /* log */\n        0x1AB: list_LLS, /* pow */\n        0x1B0: list_LS, /* sin */\n        0x1B1: list_LS, /* cos */\n        0x1B2: list_LS, /* tan */\n        0x1B3: list_LS, /* asin */\n        0x1B4: list_LS, /* acos */\n        0x1B5: list_LS, /* atan */\n        0x1B6: list_LLS, /* atan2 */\n        0x1C0: list_LLLL, /* jfeq */\n        0x1C1: list_LLLL, /* jfne */\n        0x1C2: list_LLL, /* jflt */\n        0x1C3: list_LLL, /* jfle */\n        0x1C4: list_LLL, /* jfgt */\n        0x1C5: list_LLL, /* jfge */\n        0x1C8: list_LL, /* jisnan */\n        0x1C9: list_LL  /* jisinf */\n    }\n}\n\n/* A brief lecture on the offstate:\n\n   One way we optimize JIT-compiled code is to do a running static analysis,\n   and try to determine what values are on top of the VM stack at any given\n   time. (That is, during any given instruction.) We also try to keep track\n   of what values are in all the local variables. These lists are the\n   \"offstate\" (\"offstack\" and \"offloc\" lists). They can contain both numeric\n   literals and (Javascript) temporary variables. When we add a value to the\n   offstack, we delay generating the code that pushes it into the real (VM)\n   stack. If we're lucky, we never have to do that push at all. Similarly,\n   when we add a value to the offloc, we delay writing it to the real\n   local-variable array.\n\n   Temporary variables are considered immutable as long as they remain in\n   the offstate. So a variable can actually appear in the offstate more\n   than once.\n\n   Whenever anything happens that can't be statically analyzed --\n   notably, any jump, call, or return -- we \"unload the offstate\", by\n   generating the appropriate VM stack pushes and local writes. This must\n   certainly be done at the end of a code path, and we have asserts to\n   ensure this.\n*/\n\n/* Some utility functions for opcode handlers. */\n\nself.funcop_cache = {};\n\n/* Return a Javascript literal representing a funcop. The funcop can be used\n   later with store_operand_by_funcop(). For efficiency, this represents a\n   \"discard\" funcop as \"null\".\n\n   For more efficiency (to avoid creating objects in commonly-called\n   functions), the literal we return looks like \"funcop_cache.mXsYaZ\".\n   We fill in the cache as necessary.\n\n   (We can't just store the passed-in funcop, because it's a scratch object\n   that will be overwritten.)\n*/\nfunction oputil_record_funcop(funcop) {\n    if (funcop.mode == 0) {\n        /* discard value */\n        return \"null\";\n    }\n\n    var key = \"m\" + funcop.mode;\n    if (funcop.argsize != null)\n        key = key + \"s\" + funcop.argsize;\n    if (funcop.addr != null)\n        key = key + \"a\" + funcop.addr;\n\n    if (self.funcop_cache.key)\n        return \"self.funcop_cache.\"+key;\n\n    var obj = { key: key, \n        mode: funcop.mode, argsize: funcop.argsize, addr: funcop.addr };\n    self.funcop_cache[key] = obj;\n    return \"self.funcop_cache.\"+key;\n}\n\n/* Store the result of an opcode, using the information specified in\n   funcop. The operand may be a quoted constant, a holdvar, or an\n   expression. (As usual, constants are identified by starting with a\n   \"0\", and holdvars with a \"_\".)\n*/\nfunction oputil_store(context, funcop, operand) {\n    var holdvar;\n\n    switch (funcop.mode) {\n\n    case 8: /* push on stack */\n        if (funcop.argsize == 4) {\n            /* These two cases are tested in a nasty fast way. Pretend\n               I'm calling quot_isconstant() and quot_isholdvar(). */\n            var opchar = operand[0];\n            if (opchar === \"0\") { /* quot_isconstant(operand) */\n                /* If this is an untruncated constant, we can move it \n                   directly to the offstack. */\n                context.offstack.push(operand);\n                ;;;context.code.push(\"// push to offstack: \"+operand); //debug\n                return;\n            }\n            if (opchar === \"_\") { /* quot_isholdvar(operand) */\n                /* If it's an untruncated variable, we can still move it\n                   to the offstack, but we have to increase its usage. */\n                push_offstack_holdvar(context, operand);\n                ;;;context.code.push(\"// re-push to offstack: \"+operand); //debug\n                return;\n            }\n        }\n\n        holdvar = alloc_holdvar(context, true);\n        context.offstack.push(holdvar);\n        if (funcop.argsize == 4) {\n            context.code.push(holdvar+\"=(\"+operand+\");\");\n        }\n        else if (funcop.argsize == 2) {\n            context.code.push(holdvar+\"=0xffff&(\"+operand+\");\");\n        }\n        else {\n            context.code.push(holdvar+\"=0xff&(\"+operand+\");\");\n        }\n        return;\n\n    case 0: /* discard value */\n        context.code.push(\"(\"+operand+\");\");\n        return;\n\n    case 11: /* The local-variable cases. */\n        if (funcop.argsize == 4) {\n            /* These two cases are tested in a nasty fast way. Pretend\n               I'm calling quot_isconstant() and quot_isholdvar(). */\n            var opchar = operand[0];\n            if (opchar === \"0\") { /* quot_isconstant(operand) */\n                /* If this is an untruncated constant, we can move it \n                   directly to the offloc. */\n                store_offloc_value(context, funcop.addr, operand, false);\n                ;;;context.code.push(\"// store to offloc[\"+funcop.addr+\"]: \"+operand); //debug\n                return;\n            }\n            if (opchar === \"_\") { /* quot_isholdvar(operand) */\n                /* If it's an untruncated variable, we can still move it\n                   to the offloc, but we have to increase its usage. */\n                store_offloc_value(context, funcop.addr, operand, true);\n                ;;;context.code.push(\"// re-store to offloc[\"+funcop.addr+\"]: \"+operand); //debug\n                return;\n            }\n        }\n\n        /* Wipe the offloc entry, if any. */\n        store_offloc_value(context, funcop.addr, undefined);\n        /* Store directly to the locals array. */\n        if (funcop.argsize == 4) {\n            context.code.push(\"self.frame.locals[\"+funcop.addr+\"]=(\"+operand+\");\");\n        }\n        else if (funcop.argsize == 2) {\n            context.code.push(\"self.frame.locals[\"+funcop.addr+\"]=(0xffff &\"+operand+\");\");\n        }\n        else {\n            context.code.push(\"self.frame.locals[\"+funcop.addr+\"]=(0xff &\"+operand+\");\");\n        }\n        return;\n\n    case 15: /* The main-memory cases. */\n        if (funcop.argsize == 4) {\n            context.code.push(\"self.MemW4(\"+funcop.addr+\",\"+operand+\");\");\n        }\n        else if (funcop.argsize == 2) {\n            context.code.push(\"self.MemW2(\"+funcop.addr+\",\"+operand+\");\");\n        }\n        else {\n            context.code.push(\"self.MemW1(\"+funcop.addr+\",\"+operand+\");\");\n        }\n        return;\n\n    default:\n        fatal_error(\"Unknown addressing mode in store func operand.\");\n\n    }\n}\n\n/* Push the four-value call stub onto the stack. The operand should be the\n   output of a \"C\" operand -- a string of the form \"DESTTYPE,DESTADDR\". \n\n   The last argument, addr, is optional. If not provided, it defaults to\n   context.cp -- the address of the next opcode (to be compiled).\n*/\nfunction oputil_push_callstub(context, operand, addr) {\n    if (addr === undefined)\n        addr = context.cp;\n    context.code.push(\"self.frame.valstack.push(\"+operand+\",\"+addr+\",self.frame.framestart);\");\n}\n\n/* Conditionally push a type-0x11 call stub. This logically happens at\n   the beginning of any compiled string function. In practice, we delay\n   it until the first time it's needed; that's what the substring flag\n   tracks.\n\n   This relies on nextcp being the next opcode address (as passed\n   to the compiled string function as an argument).\n*/\nfunction oputil_push_substring_callstub(context) {\n    context.code.push(\"if (!substring) { substring=true;\");\n    context.code.push(\"self.frame.valstack.push(0x11,0,nextcp,self.frame.framestart);\");\n    context.code.push(\"}\");\n}\n\n/* Move all values on the offstack to the real stack, and all values\n   on the offloc to the real local variables. A handler should call\n   this before any operation which requires a legal game state, and\n   also before ending compilation. \n\n   If keepstack is true, this generates code to move the values, but\n   leaves them on the offstack as well. Call this form before a conditional\n   \"return\" which does not end compilation.\n*/\nfunction oputil_unload_offstate(context, keepstack) {\n    var ix;\n    ;;;context.code.push(\"// unload offstate: \" + context.offstack.length + \" stack\" + (context.offloc.length ? \", plus locs\" : \"\") + (keepstack ? \" (conditional)\" : \"\")); //debug\n    if (context.offstack.length) {\n        context.code.push(\"self.frame.valstack.push(\"+context.offstack.join(\",\")+\");\");\n    }\n    if (context.offloc.length) {\n        for (ix=0; ix<context.offloc.length; ix++) {\n            if (context.offloc[ix] !== undefined && context.offlocdirty[ix]) {\n                context.code.push(\"self.frame.locals[\"+ix+\"]=\"+context.offloc[ix]+\";\");\n            }\n        }\n    }\n    if (!keepstack) {\n        var holdvar;\n        for (ix=0; ix<context.offloc.length; ix++) {\n            holdvar = context.offloc[ix];\n            if (holdvar !== undefined) {\n                if (context.holduse[holdvar] !== undefined)\n                    context.holduse[holdvar] = false;\n            }\n        }\n        context.offloc.length = 0;\n        context.offlocdirty.length = 0;\n        while (context.offstack.length) {\n            holdvar = context.offstack.pop();\n            if (context.holduse[holdvar] !== undefined)\n                context.holduse[holdvar] = false;\n        }\n        /* Now offstack/offloc are empty, and all their variables are marked \n           not on it. (There might have been constant values too, but that\n           didn't affect holduse.) */\n    }\n}\n\nfunction oputil_flush_string(context) {\n    if (context.buffer.length == 0)\n        return;\n\n    var str = context.buffer.join(\"\");\n    context.buffer.length = 0;\n\n    context.code.push(\"self.Glk.glk_put_jstring(\"+QuoteEscapeString(str)+\");\");\n}\n\n/* Return the signed equivalent of a value. If it is a high-bit constant, \n   this returns its negative equivalent as a constant. If it is a _hold\n   variable or expression, a new expression is returned with the signed\n   value.\n\n   If the hold parameter is true, the expression will be assigned to a\n   new _hold var. Use this if you intend to use the returned value more\n   than once.\n*/\nfunction oputil_signify_operand(context, operand, hold) {\n    var val;\n    if (quot_isconstant(operand)) {\n        val = Number(operand);\n        if (val & 0x80000000)\n            return \"\"+(val - 0x100000000);\n        else\n            return operand;\n    }\n\n    /* By a quirk of Javascript, you can turn an unsigned 32-bit number\n       into a signed one by bit-anding it with 0xffffffff. */\n\n    val = \"(\"+operand+\"&0xffffffff)\";\n    if (hold) {\n        var holdvar = alloc_holdvar(context);\n        context.code.push(holdvar+\"=\"+val+\";\");\n        return holdvar;\n    }\n    else {\n        return val;\n    }\n}\n\n/* Return the float equivalent of a value. If it is a constant, this\n   returns a float constant. If it is a _hold_ variable or expression,\n   a new expression is returned with the signed value.\n\n   If the hold parameter is true, the expression will be assigned to a\n   new _hold var. Use this if you intend to use the returned value more\n   than once.\n*/\nfunction oputil_decode_float(context, operand, hold) {\n    var val;\n    if (quot_isconstant(operand)) {\n        val = Number(operand);\n        /* The standard toString rendering of -0 is \"0\", so we have to\n           handle that case specially. */\n        if (val == 0x80000000)\n            return \"-0\";\n        return \"\"+decode_float(val);\n    }\n\n    val = \"self.decode_float(\"+operand+\")\";\n    if (hold) {\n        var holdvar = alloc_holdvar(context);\n        context.code.push(holdvar+\"=\"+val+\";\");\n        return holdvar;\n    }\n    else {\n        return val;\n    }\n}\n\n/* Generate code for a branch to operand. This includes the usual branch\n   hack; 0 or 1 return from the current function. \n   If unconditional is false, the offstack values are left in place,\n   so that compilation can continue.\n*/\nfunction oputil_perform_jump(context, operand, unconditional) {\n    if (quot_isconstant(operand)) {\n        var val = Number(operand);\n        if (val == 0 || val == 1) {\n            if (unconditional) {\n                ;;;context.code.push(\"// quashing offstack for unconditional return: \" + context.offstack.length); //debug\n                context.offstack.length = 0;\n                context.offloc.length = 0;\n                context.offlocdirty.length = 0;\n            }\n            else {\n                ;;;context.code.push(\"// ignoring offstack for conditional return: \" + context.offstack.length); //debug\n            }\n            context.code.push(\"if (self.leave_function()) return self.VMStopped;\");\n            context.code.push(\"self.pop_callstub(\"+val+\");\");\n        }\n        else {\n            oputil_unload_offstate(context, !unconditional);\n            var newpc = (context.cp+val-2) >>>0;\n            context.code.push(\"self.pc = \"+newpc+\";\");\n            context.vmfunc.pathaddrs[newpc] = true;\n        }\n    }\n    else {\n        oputil_unload_offstate(context, !unconditional);\n        context.code.push(\"if ((\"+operand+\")==0 || (\"+operand+\")==1) {\");\n        context.code.push(\"if (self.leave_function()) return self.VMStopped;\");\n        context.code.push(\"self.pop_callstub(\"+operand+\");\");\n        context.code.push(\"}\");\n        context.code.push(\"else {\");\n        context.code.push(\"self.pc = (\"+context.cp+\"+(\"+operand+\")-2) >>>0;\");\n        context.code.push(\"}\");\n    }\n    context.code.push(\"return;\");\n}\n\n/* opcode_table: All the Glulx VM opcodes. \n\n   Each entry in this table is a function that *generates* executable\n   Javascript code for that opcode. When we're compiling a code path,\n   we call the sequence of opcode functions, and the result is a\n   working Javascript function for that code path.\n*/\n\nvar opcode_table = {\n    0x0: function(context, operands) { /* nop */\n    },\n\n    0x10: function(context, operands) { /* add */\n        /* Commutative, so we don't care about the order of evaluation of\n           the two expressions. */\n        /* We truncate the sum with >>>0, which always gives an unsigned\n           32-bit integer. */\n        context.code.push(operands[2]+\"((\"+operands[0]+\")+(\"+operands[1]+\")) >>>0);\");\n    },\n\n    0x11: function(context, operands) { /* sub */\n        /* We hold operand 0, to ensure that it's evaluated first. Op 1\n           is an expression. */\n        context.code.push(operands[2]+\"((\"+operands[0]+\")-(\"+operands[1]+\")) >>>0);\");\n    },\n\n    0x12: function(context, operands) { /* mul */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        context.code.push(operands[2]+\"(Math.imul((\"+sign0+\"),(\"+sign1+\"))) >>>0);\");\n    },\n\n    0x13: function(context, operands) { /* div */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        var holdvar = alloc_holdvar(context);\n        context.code.push(holdvar+\"=((\"+sign0+\")/(\"+sign1+\"));\");\n        context.code.push(\"if (!isFinite(\"+holdvar+\")) self.fatal_error('Division by zero.');\");\n        context.code.push(operands[2]+\"(\"+holdvar+\">=0)?Math.floor(\"+holdvar+\"):(-Math.floor(-\"+holdvar+\") >>>0));\");\n    },\n\n    0x14: function(context, operands) { /* mod */\n        /* Javascript modulo follows the same sign laws as Glulx, which\n           is convenient. */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        var holdvar = alloc_holdvar(context);\n        context.code.push(holdvar+\"=((\"+sign0+\")%(\"+sign1+\"));\");\n        context.code.push(\"if (!isFinite(\"+holdvar+\")) self.fatal_error('Modulo division by zero.');\");\n        context.code.push(operands[2]+holdvar+\" >>>0);\");\n    },\n\n    0x15: function(context, operands) { /* neg */\n        context.code.push(operands[1]+\"(-(\"+operands[0]+\")) >>>0);\");\n    },\n\n    0x18: function(context, operands) { /* bitand */\n        /* Commutative. */\n        context.code.push(operands[2]+\"((\"+operands[0]+\")&(\"+operands[1]+\")) >>>0);\");\n    },\n\n    0x19: function(context, operands) { /* bitor */\n        /* Commutative. */\n        context.code.push(operands[2]+\"((\"+operands[0]+\")|(\"+operands[1]+\")) >>>0);\");\n    },\n\n    0x1a: function(context, operands) { /* bitxor */\n        /* Commutative. */\n        context.code.push(operands[2]+\"((\"+operands[0]+\")^(\"+operands[1]+\")) >>>0);\");\n    },\n\n    0x1b: function(context, operands) { /* bitnot */\n        context.code.push(operands[1]+\"(~(\"+operands[0]+\")) >>>0);\");\n    },\n\n    0x1c: function(context, operands) { /* shiftl */\n        if (quot_isconstant(operands[1])) {\n            var val = Number(operands[1]);\n            if (val < 32)\n                context.code.push(operands[2]+\"((\"+operands[0]+\")<<\"+val+\") >>>0);\");\n            else\n                context.code.push(operands[2]+\"0);\");\n        }\n        else {\n            context.code.push(operands[2]+\"(\"+operands[1]+\"<32) ? ((\"+operands[0]+\"<<\"+operands[1]+\") >>>0) : 0);\");\n        }\n    },\n\n    0x1d: function(context, operands) { /* sshiftr */\n        if (quot_isconstant(operands[1])) {\n            var val = Number(operands[1]);\n            if (val < 32)\n                context.code.push(operands[2]+\"((\"+operands[0]+\")>>\"+val+\") >>>0);\");\n            else\n                context.code.push(operands[2]+\"((\"+operands[0]+\")&0x80000000) ? 0xffffffff : 0);\");\n        }\n        else {\n            context.code.push(\"if (\"+operands[0]+\" & 0x80000000) {\");\n            context.code.push(operands[2]+\"(\"+operands[1]+\"<32) ? ((\"+operands[0]+\">>\"+operands[1]+\") >>>0) : 0xffffffff);\");\n            context.code.push(\"} else {\");\n            context.code.push(operands[2]+\"(\"+operands[1]+\"<32) ? ((\"+operands[0]+\">>\"+operands[1]+\") >>>0) : 0);\");\n            context.code.push(\"}\");\n        }\n    },\n\n    0x1e: function(context, operands) { /* ushiftr */\n        if (quot_isconstant(operands[1])) {\n            var val = Number(operands[1]);\n            if (val < 32)\n                context.code.push(operands[2]+\"(\"+operands[0]+\")>>>\"+val+\");\");\n            else\n                context.code.push(operands[2]+\"0);\");\n        }\n        else {\n            context.code.push(operands[2]+\"(\"+operands[1]+\"<32) ? (\"+operands[0]+\">>>\"+operands[1]+\") : 0);\");\n        }\n    },\n\n    0x20: function(context, operands) { /* jump */\n        oputil_perform_jump(context, operands[0], true);\n        context.path_ends = true;\n    },\n\n    0x104: function(context, operands) { /* jumpabs */\n        if (quot_isconstant(operands[0])) {\n            var newpc = Number(operands[0]);\n            context.code.push(\"self.pc = \"+newpc+\";\");\n            context.vmfunc.pathaddrs[newpc] = true;\n        }\n        else {\n            context.code.push(\"self.pc = \"+operands[0]+\";\");\n        }\n        oputil_unload_offstate(context);\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x22: function(context, operands) { /* jz */\n        context.code.push(\"if ((\"+operands[0]+\")==0) {\");\n        oputil_perform_jump(context, operands[1]);\n        context.code.push(\"}\");\n    },\n\n    0x23: function(context, operands) { /* jnz */\n        context.code.push(\"if ((\"+operands[0]+\")!=0) {\");\n        oputil_perform_jump(context, operands[1]);\n        context.code.push(\"}\");\n    },\n\n    0x24: function(context, operands) { /* jeq */\n        context.code.push(\"if ((\"+operands[0]+\")==(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x25: function(context, operands) { /* jne */\n        context.code.push(\"if ((\"+operands[0]+\")!=(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x26: function(context, operands) { /* jlt */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        context.code.push(\"if ((\"+sign0+\")<(\"+sign1+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x27: function(context, operands) { /* jge */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        context.code.push(\"if ((\"+sign0+\")>=(\"+sign1+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x28: function(context, operands) { /* jgt */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        context.code.push(\"if ((\"+sign0+\")>(\"+sign1+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x29: function(context, operands) { /* jle */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        var sign1 = oputil_signify_operand(context, operands[1]);\n        context.code.push(\"if ((\"+sign0+\")<=(\"+sign1+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x2a: function(context, operands) { /* jltu */\n        context.code.push(\"if ((\"+operands[0]+\")<(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x2b: function(context, operands) { /* jgeu */\n        context.code.push(\"if ((\"+operands[0]+\")>=(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x2c: function(context, operands) { /* jgtu */\n        context.code.push(\"if ((\"+operands[0]+\")>(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x2d: function(context, operands) { /* jleu */\n        context.code.push(\"if ((\"+operands[0]+\")<=(\"+operands[1]+\")) {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x30: function(context, operands) { /* call */\n        if (quot_isconstant(operands[1])) {\n            var ix;\n            var argc = Number(operands[1]);\n            for (ix=0; ix<argc; ix++) {\n                if (context.offstack.length) {\n                    var holdvar = pop_offstack_holdvar(context);\n                    context.code.push(\"self.tempcallargs[\"+ix+\"]=\"+holdvar+\";\");\n                }\n                else {\n                    context.code.push(\"self.tempcallargs[\"+ix+\"]=self.frame.valstack.pop();\");\n                }\n            }\n            oputil_unload_offstate(context);\n        }\n        else {\n            context.varsused[\"ix\"] = true;\n            oputil_unload_offstate(context);\n            context.code.push(\"for (ix=0; ix<\"+operands[1]+\"; ix++) { self.tempcallargs[ix]=self.frame.valstack.pop(); }\");\n        }\n        oputil_push_callstub(context, operands[2]);\n        context.code.push(\"self.enter_function(\"+operands[0]+\", \"+operands[1]+\");\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x34: function(context, operands) { /* tailcall */\n        if (quot_isconstant(operands[1])) {\n            var ix;\n            var argc = Number(operands[1]);\n            for (ix=0; ix<argc; ix++) {\n                if (context.offstack.length) {\n                    var holdvar = pop_offstack_holdvar(context);\n                    context.code.push(\"self.tempcallargs[\"+ix+\"]=\"+holdvar+\";\");\n                }\n                else {\n                    context.code.push(\"self.tempcallargs[\"+ix+\"]=self.frame.valstack.pop();\");\n                }\n            }\n            oputil_unload_offstate(context);\n        }\n        else {\n            context.varsused[\"ix\"] = true;\n            oputil_unload_offstate(context);\n            context.code.push(\"for (ix=0; ix<\"+operands[1]+\"; ix++) { self.tempcallargs[ix]=self.frame.valstack.pop(); }\");\n        }\n        /* Note that tailcall in the top-level function will not work.\n           But why would you do that? */\n        context.code.push(\"if (self.leave_function()) return self.VMStopped;\");\n        context.code.push(\"self.enter_function(\"+operands[0]+\", \"+operands[1]+\");\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x160: function(context, operands) { /* callf */\n        oputil_unload_offstate(context);\n        oputil_push_callstub(context, operands[1]);\n        context.code.push(\"self.enter_function(\"+operands[0]+\", 0);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x161: function(context, operands) { /* callfi */\n        oputil_unload_offstate(context);\n        context.code.push(\"self.tempcallargs[0]=(\"+operands[1]+\");\");\n        oputil_push_callstub(context, operands[2]);\n        context.code.push(\"self.enter_function(\"+operands[0]+\", 1);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x162: function(context, operands) { /* callfii */\n        oputil_unload_offstate(context);\n        context.code.push(\"self.tempcallargs[0]=(\"+operands[1]+\");\");\n        context.code.push(\"self.tempcallargs[1]=(\"+operands[2]+\");\");\n        oputil_push_callstub(context, operands[3]);\n        context.code.push(\"self.enter_function(\"+operands[0]+\", 2);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x163: function(context, operands) { /* callfiii */\n        oputil_unload_offstate(context);\n        context.code.push(\"self.tempcallargs[0]=(\"+operands[1]+\");\");\n        context.code.push(\"self.tempcallargs[1]=(\"+operands[2]+\");\");\n        context.code.push(\"self.tempcallargs[2]=(\"+operands[3]+\");\");\n        oputil_push_callstub(context, operands[4]);\n        context.code.push(\"self.enter_function(\"+operands[0]+\", 3);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x31: function(context, operands) { /* return */\n        /* Quash the offstack; we're about to blow away the whole stack\n           frame, so nothing of the stack will survive. */\n        ;;;context.code.push(\"// quashing offstack for return: \" + context.offstack.length); //debug\n        context.offstack.length = 0;\n        context.offloc.length = 0;\n        context.offlocdirty.length = 0;\n        context.code.push(\"if (self.leave_function()) return self.VMStopped;\");\n        context.code.push(\"self.pop_callstub(\"+operands[0]+\");\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x32: function(context, operands) { /* catch */\n        oputil_unload_offstate(context);\n        oputil_push_callstub(context, operands[0]);\n        context.code.push(\"self.store_operand(\"+operands[0]+\",self.frame.framestart+self.frame.framelen+4*self.frame.valstack.length);\");\n        oputil_perform_jump(context, operands[1], true);\n        context.path_ends = true;\n    },\n\n    0x33: function(context, operands) { /* throw */\n        /* Quash the offstack; we're about to blow away the stack frame, or\n           at minimum reset it. A valid call stub cannot be on the offstack. */\n        ;;;context.code.push(\"// quashing offstack for throw: \" + context.offstack.length); //debug\n        context.offstack.length = 0;\n        context.offloc.length = 0;\n        context.offlocdirty.length = 0;\n        context.code.push(\"self.pop_stack_to(\"+operands[1]+\");\");\n        context.code.push(\"self.pop_callstub(\"+operands[0]+\");\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x40: function(context, operands) { /* copy */\n        oputil_store(context, operands[1], operands[0]);\n    },\n\n    0x41: function(context, operands) { /* copys */\n        oputil_store(context, operands[1], operands[0]);\n    },\n\n    0x42: function(context, operands) { /* copyb */\n        oputil_store(context, operands[1], operands[0]);\n    },\n\n    0x44: function(context, operands) { /* sexs */\n        var val;\n        if (quot_isconstant(operands[0])) {\n            val = Number(operands[0]);\n            val = (val & 0x8000) ? ((val | 0xffff0000) >>> 0) : (val & 0xffff);\n            context.code.push(operands[1]+val+\");\");\n        }\n        else {\n            context.code.push(operands[1]+\"(\"+operands[0]+\" & 0x8000) ? ((\"+operands[0]+\" | 0xffff0000) >>> 0) : (\"+operands[0]+\" & 0xffff));\");\n        }\n    },\n\n    0x45: function(context, operands) { /* sexb */\n        var val;\n        if (quot_isconstant(operands[0])) {\n            val = Number(operands[0]);\n            val = (val & 0x80) ? ((val | 0xffffff00) >>> 0) : (val & 0xff);\n            context.code.push(operands[1]+val+\");\");\n        }\n        else {\n            context.code.push(operands[1]+\"(\"+operands[0]+\" & 0x80) ? ((\"+operands[0]+\" | 0xffffff00) >>> 0) : (\"+operands[0]+\" & 0xff));\");\n        }\n    },\n\n    0x48: function(context, operands) { /* aload */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]) * 4;\n                val = \"self.Mem4(\"+(addr >>>0)+\")\";\n            }\n            else {\n                var addr = Number(operands[1]) * 4;\n                if (addr)\n                    val = \"self.Mem4((\"+operands[0]+\"+\"+addr+\") >>>0)\";\n                else\n                    val = \"self.Mem4(\"+operands[0]+\")\";\n            }\n        }\n        else {\n            val = \"self.Mem4((\"+operands[0]+\"+4*\"+operands[1]+\") >>>0)\";\n        }\n        context.code.push(operands[2]+val+\");\");\n    },\n\n    0x49: function(context, operands) { /* aloads */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]) * 2;\n                val = \"self.Mem2(\"+(addr >>>0)+\")\";\n            }\n            else {\n                var addr = Number(operands[1]) * 2;\n                if (addr)\n                    val = \"self.Mem2((\"+operands[0]+\"+\"+addr+\") >>>0)\";\n                else\n                    val = \"self.Mem2(\"+operands[0]+\")\";\n            }\n        }\n        else {\n            val = \"self.Mem2((\"+operands[0]+\"+2*\"+operands[1]+\") >>>0)\";\n        }\n        context.code.push(operands[2]+val+\");\");\n    },\n\n    0x4a: function(context, operands) { /* aloadb */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]);\n                val = \"self.Mem1(\"+(addr >>>0)+\")\";\n            }\n            else {\n                var addr = Number(operands[1]);\n                if (addr)\n                    val = \"self.Mem1((\"+operands[0]+\"+\"+addr+\") >>>0)\";\n                else\n                    val = \"self.Mem1(\"+operands[0]+\")\";\n            }\n        }\n        else {\n            val = \"self.Mem1((\"+operands[0]+\"+\"+operands[1]+\") >>>0)\";\n        }\n        context.code.push(operands[2]+val+\");\");\n    },\n\n    0x4c: function(context, operands) { /* astore */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]) * 4;\n                val = (addr >>>0)+\",\";\n            }\n            else {\n                var addr = Number(operands[1]) * 4;\n                if (addr)\n                    val = \"(\"+operands[0]+\"+\"+addr+\") >>>0\"+\",\";\n                else\n                    val = operands[0]+\",\";\n            }\n        }\n        else {\n            val = \"(\"+operands[0]+\"+4*\"+operands[1]+\") >>>0\"+\",\";\n        }\n        context.code.push(\"self.MemW4(\"+val+operands[2]+\")\"+\";\");\n    },\n\n    0x4d: function(context, operands) { /* astores */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]) * 2;\n                val = (addr >>>0)+\",\";\n            }\n            else {\n                var addr = Number(operands[1]) * 2;\n                if (addr)\n                    val = \"(\"+operands[0]+\"+\"+addr+\") >>>0\"+\",\";\n                else\n                    val = operands[0]+\",\";\n            }\n        }\n        else {\n            val = \"(\"+operands[0]+\"+2*\"+operands[1]+\") >>>0\"+\",\";\n        }\n        context.code.push(\"self.MemW2(\"+val+operands[2]+\")\"+\";\");\n    },\n\n    0x4e: function(context, operands) { /* astoreb */\n        var val, addr;\n        if (quot_isconstant(operands[1])) {\n            if (quot_isconstant(operands[0])) {\n                /* Both operands constant */\n                addr = Number(operands[0]) + Number(operands[1]);\n                val = (addr >>>0)+\",\";\n            }\n            else {\n                var addr = Number(operands[1]);\n                if (addr)\n                    val = \"(\"+operands[0]+\"+\"+addr+\") >>>0\"+\",\";\n                else\n                    val = operands[0]+\",\";\n            }\n        }\n        else {\n            val = \"(\"+operands[0]+\"+\"+operands[1]+\") >>>0\"+\",\";\n        }\n        context.code.push(\"self.MemW1(\"+val+operands[2]+\")\"+\";\");\n    },\n\n    0x4b: function(context, operands) { /* aloadbit */\n        if (quot_isconstant(operands[1])) {\n            var bitx, addrx, bitnum;\n            bitnum = Number(operands[1]) & 0xffffffff; /* signed */\n            bitx = bitnum & 7;\n            if (quot_isconstant(operands[0])) {\n                /* Generate addrx as a number. */\n                addrx = Number(operands[0]);\n                if (bitnum >= 0) \n                    addrx += (bitnum>>3);\n                else\n                    addrx -= (1+((-1-bitnum)>>3));\n            }\n            else {\n                /* Generate addrx as an expression string. */\n                if (bitnum >= 0) {\n                    if (bitnum <= 7)\n                        addrx = operands[0];\n                    else\n                        addrx = (operands[0]+\"+\"+(bitnum>>3));\n                }\n                else {\n                    addrx = (operands[0]+\"-\"+(1+((-1-bitnum)>>3)));\n                }\n            }\n            context.code.push(operands[2]+\"(self.Mem1(\"+addrx+\") & \"+(1<<bitx)+\")?1:0);\");\n        }\n        else {\n            context.varsused[\"bitx\"] = true;\n            context.varsused[\"addrx\"] = true;\n            var sign1 = oputil_signify_operand(context, operands[1], true);\n            context.code.push(\"bitx = \"+sign1+\"&7;\");\n            context.code.push(\"if (\"+sign1+\">=0) addrx = \"+operands[0]+\" + (\"+sign1+\">>3);\");\n            context.code.push(\"else addrx = \"+operands[0]+\" - (1+((-1-(\"+sign1+\"))>>3));\");\n            context.code.push(operands[2]+\"(self.Mem1(addrx) & (1<<bitx))?1:0);\");\n        }\n    },\n\n    0x4f: function(context, operands) { /* astorebit */\n        var bitx, addrx, mask, bitnum;\n        if (quot_isconstant(operands[1])) {\n            bitnum = Number(operands[1]) & 0xffffffff; /* signed */\n            bitx = bitnum & 7;\n            if (quot_isconstant(operands[0])) {\n                /* Generate addrx as a number. */\n                addrx = Number(operands[0]);\n                if (bitnum >= 0) \n                    addrx += (bitnum>>3);\n                else\n                    addrx -= (1+((-1-bitnum)>>3));\n            }\n            else {\n                /* Generate addrx as an expression string. */\n                if (bitnum >= 0) {\n                    if (bitnum <= 7)\n                        addrx = operands[0];\n                    else\n                        addrx = (operands[0]+\"+\"+(bitnum>>3));\n                }\n                else {\n                    addrx = (operands[0]+\"-\"+(1+((-1-bitnum)>>3)));\n                }\n            }\n            mask = (1<<bitx);\n        }\n        else {\n            context.varsused[\"bitx\"] = true;\n            context.varsused[\"addrx\"] = true;\n            var sign1 = oputil_signify_operand(context, operands[1], true);\n            context.code.push(\"bitx = \"+sign1+\"&7;\");\n            context.code.push(\"if (\"+sign1+\">=0) addrx = \"+operands[0]+\" + (\"+sign1+\">>3);\");\n            context.code.push(\"else addrx = \"+operands[0]+\" - (1+((-1-(\"+sign1+\"))>>3));\");\n            addrx = \"addrx\";\n            mask = \"(1<<bitx)\";\n        }\n        if (quot_isconstant(operands[2])) {\n            if (Number(operands[2]))\n                context.code.push(\"self.MemW1(\"+addrx+\", self.Mem1(\"+addrx+\") | \"+mask+\");\");\n            else\n                context.code.push(\"self.MemW1(\"+addrx+\", self.Mem1(\"+addrx+\") & ~(\"+mask+\"));\");\n        }\n        else {\n            context.code.push(\"if (\"+operands[2]+\") self.MemW1(\"+addrx+\", self.Mem1(\"+addrx+\") | \"+mask+\");\");\n            context.code.push(\"else self.MemW1(\"+addrx+\", self.Mem1(\"+addrx+\") & ~(\"+mask+\"));\");\n        }\n    },\n\n    0x50: function(context, operands) { /* stkcount */\n        var val;\n        var count = context.offstack.length;\n        if (count)\n            val = \"self.frame.valstack.length+\" + count;\n        else\n            val = \"self.frame.valstack.length\";\n        oputil_store(context, operands[0], val);\n    },\n\n    0x51: function(context, operands) { /* stkpeek */\n        var val;\n        if (quot_isconstant(operands[0])) {\n            var pos = Number(operands[0]);\n            if (pos < context.offstack.length) {\n                val = context.offstack[context.offstack.length-(pos+1)];\n            }\n            else {\n                val = \"self.frame.valstack[self.frame.valstack.length-\"+((pos+1)-context.offstack.length)+\"]\";\n            }\n        }\n        else {\n            oputil_unload_offstate(context);\n            val = \"self.frame.valstack[self.frame.valstack.length-(\"+operands[0]+\"+1)]\";\n        }\n        oputil_store(context, operands[1], val);\n    },\n\n    0x52: function(context, operands) { /* stkswap */\n        var temp, len;\n        if (context.offstack.length < 2) {\n            transfer_to_offstack(context, 2);\n        }\n        /* We can do this with no code. */\n        len = context.offstack.length;\n        temp = context.offstack[len-1];\n        context.offstack[len-1] = context.offstack[len-2];\n        context.offstack[len-2] = temp;\n    },\n\n    0x53: function(context, operands) { /* stkroll */\n        oputil_unload_offstate(context);\n        context.varsused[\"ix\"] = true;\n        context.varsused[\"pos\"] = true;\n        context.varsused[\"roll\"] = true;\n        context.varsused[\"vals1\"] = true;\n        var sign0 = oputil_signify_operand(context, operands[0], true);\n        var sign1 = oputil_signify_operand(context, operands[1], true);\n        context.code.push(\"if (\"+sign0+\" > 0) {\");\n        context.code.push(\"if (\"+sign1+\" > 0) {\");\n        context.code.push(\"vals1 = \"+sign1+\" % \"+sign0+\";\");\n        context.code.push(\"} else {\");\n        context.code.push(\"vals1 = \"+sign0+\" - (-(\"+sign1+\")) % \"+sign0+\";\");\n        context.code.push(\"}\");\n        context.code.push(\"if (vals1) {\");\n        context.code.push(\"pos = self.frame.valstack.length - \"+sign0+\";\");\n        context.code.push(\"roll = self.frame.valstack.slice(self.frame.valstack.length-vals1, self.frame.valstack.length).concat(self.frame.valstack.slice(pos, self.frame.valstack.length-vals1));\");\n        context.code.push(\"for (ix=0; ix<\"+sign0+\"; ix++) { self.frame.valstack[pos+ix] = roll[ix]; }\");\n        context.code.push(\"roll = undefined;\");\n        context.code.push(\"}\");\n        context.code.push(\"}\");\n    },\n\n    0x54: function(context, operands) { /* stkcopy */\n        oputil_unload_offstate(context);\n        if (quot_isconstant(operands[0])) {\n            var ix, holdvar;\n            var pos = Number(operands[0]);\n            for (ix=0; ix<pos; ix++) {\n                holdvar = alloc_holdvar(context, true);\n                context.offstack.push(holdvar);\n                context.code.push(holdvar+\"=self.frame.valstack[self.frame.valstack.length-\"+(pos-ix)+\"];\");\n            }\n        }\n        else {\n            context.varsused[\"ix\"] = true;\n            context.varsused[\"jx\"] = true;\n            context.code.push(\"jx = self.frame.valstack.length-(\"+operands[0]+\");\");\n            context.code.push(\"for (ix=0; ix<\"+operands[0]+\"; ix++) { self.frame.valstack.push(self.frame.valstack[jx+ix]); }\");\n        }\n    },\n\n    0x100: function(context, operands) { /* gestalt */\n        var expr = \"self.do_gestalt((\"+operands[0]+\"),(\"+operands[1]+\"))\";\n        context.code.push(operands[2]+expr+\");\");\n    },\n\n    0x101: function(context, operands) { /* debugtrap */\n        context.code.push(\"self.fatal_error('User debugtrap encountered.', \"+operands[0]+\");\");\n    },\n\n    0x102: function(context, operands) { /* getmemsize */\n        context.code.push(operands[0]+\"self.endmem);\");\n    },\n\n    0x103: function(context, operands) { /* setmemsize */\n        context.code.push(\"self.change_memsize(\"+operands[0]+\",false);\");\n        /* An allocation failure is a fatal error, so we always return \n           success. */\n        context.code.push(operands[1]+\"0);\");\n    },\n\n    0x110: function(context, operands) { /* random */\n        var expr;\n        /* Note that we don't trust Math.random() to be absolutely random.\n           On Chrome, the last few bits aren't. That's why random(0) is\n           done in two chunks. */\n        if (quot_isconstant(operands[0])) {\n            var val = Number(operands[0]) & 0xffffffff; /* signed */\n            if (val == 0)\n                expr = \"(Math.floor(self.random_func() * 0x10000) | (Math.floor(self.random_func() * 0x10000) << 16)) >>>0\";\n            else if (val > 0)\n                expr = \"Math.floor(self.random_func() * \"+val+\")\";\n            else\n                expr = \"-Math.floor(self.random_func() * \"+(-val)+\")\";\n        }\n        else {\n            var sign0 = oputil_signify_operand(context, operands[0], true);\n            var holdvar = alloc_holdvar(context);\n            expr = holdvar;\n            context.code.push(\"if (\"+sign0+\" > 0)\");\n            context.code.push(holdvar+\" = Math.floor(self.random_func() * \"+sign0+\");\");\n            context.code.push(\"else if (\"+sign0+\" < 0)\");\n            context.code.push(holdvar+\" = -Math.floor(self.random_func() * -\"+sign0+\");\");\n            context.code.push(\"else\");\n            context.code.push(holdvar+\" = (Math.floor(self.random_func() * 0x10000) | (Math.floor(self.random_func() * 0x10000) << 16)) >>>0;\");\n        }\n        context.code.push(operands[1]+expr+\");\");\n    },\n\n    0x111: function(context, operands) { /* setrandom */\n        context.code.push(\"self.set_random(\" + operands[0] + \");\");\n    },\n\n    0x120: function(context, operands) { /* quit */\n        /* Quash the offstack. No more execution. */\n        ;;;context.code.push(\"// quashing offstack for quit: \" + context.offstack.length); //debug\n        context.offstack.length = 0;\n        context.offloc.length = 0;\n        context.offlocdirty.length = 0;\n        context.code.push(\"return self.VMStopped;\");\n        context.path_ends = true;\n    },\n\n    0x121: function(context, operands) { /* verify */\n        context.code.push(operands[0]+\"self.perform_verify());\");\n    },\n\n    0x122: function(context, operands) { /* restart */\n        /* Quash the offstack. No more execution. */\n        ;;;context.code.push(\"// quashing offstack for quit: \" + context.offstack.length); //debug\n        context.offstack.length = 0;\n        context.offloc.length = 0;\n        context.offlocdirty.length = 0;\n        context.code.push(\"self.vm_restart();\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x123: function(context, operands) { /* save */\n        oputil_unload_offstate(context);\n        context.varsused[\"ix\"] = true;\n        oputil_push_callstub(context, operands[1]);\n        context.code.push(\"ix = self.vm_save(\"+operands[0]+\");\");\n        context.code.push(\"self.pop_callstub(ix ? 0 : 1);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x124: function(context, operands) { /* restore */\n        oputil_unload_offstate(context);\n        context.code.push(\"if (self.vm_restore(\"+operands[0]+\")) {\");\n        /* Succeeded. Pop the call stub that save pushed, using -1\n           to indicate success. */\n        context.code.push(\"self.pop_callstub((-1)>>>0);\");\n        context.code.push(\"} else {\");\n        /* Failed to restore. Put back the PC, in case it got overwritten. */\n        oputil_store(context, operands[1], \"1\");\n        oputil_unload_offstate(context); // again\n        context.code.push(\"self.pc = \"+context.cp+\";\");\n        context.code.push(\"}\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x125: function(context, operands) { /* saveundo */\n        oputil_unload_offstate(context);\n        oputil_push_callstub(context, operands[0]);\n        context.code.push(\"self.vm_saveundo();\");\n        /* Any failure was a fatal error, so we return success. */\n        context.code.push(\"self.pop_callstub(0);\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x126: function(context, operands) { /* restoreundo */\n        oputil_unload_offstate(context);\n        context.code.push(\"if (self.vm_restoreundo()) {\");\n        /* Succeeded. Pop the call stub that saveundo pushed, using -1\n           to indicate success. */\n        context.code.push(\"self.pop_callstub((-1)>>>0);\");\n        context.code.push(\"} else {\");\n        /* Failed to restore. Put back the PC, in case it got overwritten. */\n        oputil_store(context, operands[0], \"1\");\n        oputil_unload_offstate(context); // again\n        context.code.push(\"self.pc = \"+context.cp+\";\");\n        context.code.push(\"}\");\n        context.code.push(\"return;\");\n        context.path_ends = true;\n    },\n\n    0x127: function(context, operands) { /* protect */\n        context.code.push(\"self.protectstart=\"+operands[0]+\";\");\n        context.code.push(\"self.protectend=self.protectstart+(\"+operands[1]+\");\");\n        context.code.push(\"if (self.protectstart==self.protectend) {\")\n        context.code.push(\"  self.protectstart=0; self.protectend=0;\");\n        context.code.push(\"}\");\n    },\n\n    0x170: function(context, operands) { /* mzero */\n        context.varsused[\"maddr\"] = true;\n        context.varsused[\"mlen\"] = true;\n        context.varsused[\"ix\"] = true;\n        context.code.push(\"mlen=\"+operands[0]+\";\");\n        context.code.push(\"maddr=\"+operands[1]+\";\");\n        context.code.push(\"for (ix=0; ix<mlen; ix++, maddr++) self.MemW1(maddr, 0);\");\n    },\n\n    0x171: function(context, operands) { /* mcopy */\n        context.varsused[\"msrc\"] = true;\n        context.varsused[\"mdest\"] = true;\n        context.varsused[\"mlen\"] = true;\n        context.varsused[\"ix\"] = true;\n        context.code.push(\"mlen=\"+operands[0]+\";\");\n        context.code.push(\"msrc=\"+operands[1]+\";\");\n        context.code.push(\"mdest=\"+operands[2]+\";\");\n\n        /* This could be optimized for the case where mlen is constant.\n           But for a rarely-used opcode, it's not really worth it. \n        */\n        context.code.push(\"if (mdest < msrc) {\");\n        context.code.push(\"for (ix=0; ix<mlen; ix++, msrc++, mdest++) self.MemW1(mdest, self.Mem1(msrc));\");\n        context.code.push(\"} else {\");\n        context.code.push(\"msrc += (mlen-1); mdest += (mlen-1);\");\n        context.code.push(\"for (ix=0; ix<mlen; ix++, msrc--, mdest--) self.MemW1(mdest, self.Mem1(msrc));\");\n        context.code.push(\"}\");\n    },\n\n    0x178: function(context, operands) { /* malloc */\n        var expr = \"self.heap_malloc(\"+operands[0]+\")\";\n        context.code.push(operands[1]+expr+\");\");\n        ;;;context.code.push(\"self.assert_heap_valid();\"); //assert\n    },\n    \n    0x179: function(context, operands) { /* mfree */\n        context.code.push(\"self.heap_free(\"+operands[0]+\");\");\n        ;;;context.code.push(\"self.assert_heap_valid();\"); //assert\n    },\n\n    0x180: function(context, operands) { /* accelfunc */\n        context.code.push(\"self.accel_funcnum_map[\"+operands[1]+\"] = \"+operands[0]+\";\");\n        context.code.push(\"self.accel_address_map[\"+operands[1]+\"] = self.accel_func_map[\"+operands[0]+\"];\");\n    },\n    \n    0x181: function(context, operands) { /* accelparam */\n        context.code.push(\"if (\"+operands[0]+\" < 9) {\");\n        context.code.push(\"  self.accel_params[\"+operands[0]+\"] = \"+operands[1]+\";\");\n        context.code.push(\"}\");\n    },\n    \n\n    0x150: function(context, operands) { /* linearsearch */\n        var expr = \"self.linear_search((\"+operands[0]+\"),(\"+operands[1]+\"),(\"+operands[2]+\"),(\"+operands[3]+\"),(\"+operands[4]+\"),(\"+operands[5]+\"),(\"+operands[6]+\"))\";\n        context.code.push(operands[7]+expr+\");\");\n    },\n\n    0x151: function(context, operands) { /* binarysearch */\n        var expr = \"self.binary_search((\"+operands[0]+\"),(\"+operands[1]+\"),(\"+operands[2]+\"),(\"+operands[3]+\"),(\"+operands[4]+\"),(\"+operands[5]+\"),(\"+operands[6]+\"))\";\n        context.code.push(operands[7]+expr+\");\");\n    },\n\n    0x152: function(context, operands) { /* linkedsearch */\n        var expr = \"self.linked_search((\"+operands[0]+\"),(\"+operands[1]+\"),(\"+operands[2]+\"),(\"+operands[3]+\"),(\"+operands[4]+\"),(\"+operands[5]+\"))\";\n        context.code.push(operands[6]+expr+\");\");\n    },\n\n    0x70: function(context, operands) { /* streamchar */\n        switch (context.curiosys) {\n        case 2: /* glk */\n            if (quot_isconstant(operands[0])) {\n                var val = Number(operands[0]) & 0xff;\n                context.code.push(\"self.Glk.glk_put_char(\"+val+\");\");\n            }\n            else {\n                context.code.push(\"self.Glk.glk_put_char((\"+operands[0]+\")&0xff);\");\n            }\n            break;\n        case 1: /* filter */\n            oputil_unload_offstate(context);\n            context.code.push(\"self.tempcallargs[0]=((\"+operands[0]+\")&0xff);\");\n            oputil_push_callstub(context, \"0,0\");\n            context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n            context.code.push(\"return;\");\n            context.path_ends = true;\n            break;\n        case 0: /* null */\n            ;;;context.code.push(\"// null streamchar \" + operands[0]); //debug\n            break;\n        }\n    },\n\n    0x71: function(context, operands) { /* streamnum */\n        switch (context.curiosys) {\n        case 2: /* glk */\n            var sign0 = oputil_signify_operand(context, operands[0]);\n            if (quot_isconstant(operands[0])) {\n                var val = Number(sign0).toString(10);\n                context.code.push(\"self.Glk.glk_put_jstring(\"+QuoteEscapeString(val)+\", true);\");\n            }\n            else {\n                context.code.push(\"self.Glk.glk_put_jstring((\"+sign0+\").toString(10), true);\");\n            }\n            break;\n        case 1: /* filter */\n            oputil_unload_offstate(context);\n            context.code.push(\"self.stream_num(\"+context.cp+\",\"+operands[0]+\", false, 0);\");\n            /* stream_num always creates a new frame in filter mode. */\n            context.code.push(\"return;\");\n            context.path_ends = true;\n            break;\n        case 0: /* null */\n            ;;;context.code.push(\"// null streamnum \" + operands[0]); //debug\n            break;\n        }\n    },\n\n    0x72: function(context, operands) { /* streamstr */\n        /* It would be nice to determine at compile-time whether the\n           value is a (cacheable) simple string value. In that case, we\n           could throw it into glk_put_jstring and continue -- no need\n           to unload the offstack or return. (Or, of the value is \n           determined to be a function, we can unload and return.)\n        */\n        oputil_unload_offstate(context);\n        context.code.push(\"if (self.stream_string(\"+context.cp+\",\"+operands[0]+\", 0, 0)) return;\");\n    },\n\n    0x73: function(context, operands) { /* streamunichar */\n        switch (context.curiosys) {\n        case 2: /* glk */\n            if (quot_isconstant(operands[0])) {\n                var val = Number(operands[0]);\n                context.code.push(\"self.Glk.glk_put_char_uni(\"+val+\");\");\n            }\n            else {\n                context.code.push(\"self.Glk.glk_put_char_uni(\"+operands[0]+\");\");\n            }\n            break;\n        case 1: /* filter */\n            oputil_unload_offstate(context);\n            context.code.push(\"self.tempcallargs[0]=(\"+operands[0]+\");\");\n            oputil_push_callstub(context, \"0,0\");\n            context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n            context.code.push(\"return;\");\n            context.path_ends = true;\n            break;\n        case 0: /* null */\n            ;;;context.code.push(\"// null streamchar \" + operands[0]); //debug\n            break;\n        }\n    },\n\n    0x140: function(context, operands) { /* getstringtbl */\n        context.code.push(operands[0]+\"self.stringtable)\");\n    },\n\n    0x141: function(context, operands) { /* setstringtbl */\n        context.code.push(\"self.set_string_table(\"+operands[0]+\");\");\n    },\n\n    0x148: function(context, operands) { /* getiosys */\n        context.code.push(operands[0]+\"self.iosysmode)\");\n        context.code.push(operands[1]+\"self.iosysrock)\");\n    },\n\n    0x149: function(context, operands) { /* setiosys */\n        context.code.push(\"self.set_iosys(\"+operands[0]+\",\"+operands[1]+\");\");\n        if (quot_isconstant(operands[0])) {\n            var val = Number(operands[0]);\n            context.curiosys = val;\n        }\n        else {\n            /* We can't compile with an unknown iosysmode. So, stop \n               compiling. */\n            oputil_unload_offstate(context);\n            context.code.push(\"self.pc = \"+context.cp+\";\");\n            context.code.push(\"return;\");\n            context.path_ends = true;\n        }\n    },\n\n    0x190: function(context, operands) { /* numtof */\n        var sign0 = oputil_signify_operand(context, operands[0]);\n        if (quot_isconstant(operands[0])) {\n            var val = Number(sign0);\n            context.code.push(operands[1]+encode_float(val)+\");\");\n        }\n        else {\n            context.code.push(operands[1]+\"self.encode_float(\"+sign0+\"));\");\n        }\n    },\n\n    0x191: function(context, operands) { /* ftonumz */\n        context.varsused[\"valf\"] = true;\n        context.varsused[\"res\"] = true;\n        context.code.push(\"valf = \"+oputil_decode_float(context, operands[0])+\";\");\n        context.code.push(\"if (!(\"+operands[0]+\" & 0x80000000)) {\");\n        context.code.push(\"  if (isNaN(valf) || !isFinite(valf) || (valf > 0x7fffffff))\");\n        context.code.push(\"    res = 0x7fffffff;\");\n        context.code.push(\"  else\");\n        context.code.push(\"    res = Math.floor(valf);\");\n        context.code.push(\"} else {\");\n        context.code.push(\"  if (isNaN(valf) || !isFinite(valf) || (valf < -0x80000000))\");\n        context.code.push(\"    res = -0x80000000;\");\n        context.code.push(\"  else\");\n        context.code.push(\"    res = Math.ceil(valf);\");\n        context.code.push(\"}\");\n        context.code.push(operands[1]+\"res>>>0);\");\n    },\n\n    0x192: function(context, operands) { /* ftonumn */\n        context.varsused[\"valf\"] = true;\n        context.varsused[\"res\"] = true;\n        context.code.push(\"valf = \"+oputil_decode_float(context, operands[0])+\";\");\n        context.code.push(\"if (!(\"+operands[0]+\" & 0x80000000)) {\");\n        context.code.push(\"  if (isNaN(valf) || !isFinite(valf))\");\n        context.code.push(\"    res = 0x7fffffff;\");\n        context.code.push(\"  else\");\n        context.code.push(\"    res = Math.round(valf);\");\n        context.code.push(\"  if (res > 0x7fffffff) res = 0x7fffffff;\");\n        context.code.push(\"} else {\");\n        context.code.push(\"  if (isNaN(valf) || !isFinite(valf))\");\n        context.code.push(\"    res = -0x80000000;\");\n        context.code.push(\"  else\");\n        context.code.push(\"    res = Math.round(valf);\");\n        context.code.push(\"  if (res < -0x80000000) res = -0x80000000;\");\n        context.code.push(\"}\");\n        context.code.push(operands[1]+\"res>>>0);\");\n    },\n\n    0x198: function(context, operands) { /* ceil */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.ceil(\"+valf+\")));\");\n    },\n\n    0x199: function(context, operands) { /* floor */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.floor(\"+valf+\")));\");\n    },\n\n    0x1A0: function(context, operands) { /* fadd */\n        var valf0 = oputil_decode_float(context, operands[0]);\n        var valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(operands[2]+\"self.encode_float(\"+valf0+\" + \"+valf1+\"));\");\n    },\n\n    0x1A1: function(context, operands) { /* fsub */\n        var valf0 = oputil_decode_float(context, operands[0]);\n        var valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(operands[2]+\"self.encode_float(\"+valf0+\" - \"+valf1+\"));\");\n    },\n\n    0x1A2: function(context, operands) { /* fmul */\n        var valf0 = oputil_decode_float(context, operands[0]);\n        var valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(operands[2]+\"self.encode_float(\"+valf0+\" * \"+valf1+\"));\");\n    },\n\n    0x1A3: function(context, operands) { /* fdiv */\n        var valf0 = oputil_decode_float(context, operands[0]);\n        var valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(operands[2]+\"self.encode_float(\"+valf0+\" / \"+valf1+\"));\");\n    },\n\n    0x1A4: function(context, operands) { /* fmod */\n        var valf0 = oputil_decode_float(context, operands[0], true);\n        var valf1 = oputil_decode_float(context, operands[1], true);\n        context.varsused[\"modv\"] = true;\n        context.varsused[\"quov\"] = true;\n        context.code.push(\"modv=(\"+valf0+\" % \"+valf1+\");\");\n        context.code.push(\"quov=self.encode_float((\"+valf0+\" - modv) / \"+valf1+\");\");\n        context.code.push(\"if (quov == 0x0 || quov == 0x80000000) {\");\n        /* When the quotient is zero, the sign has been lost in the\n           shuffle. We'll set that by hand, based on the original\n           arguments. */\n        context.code.push(\"  quov = ((\"+operands[0]+\" ^ \"+operands[1]+\") & 0x80000000) >>>0;\");\n        context.code.push(\"}\");\n        context.code.push(operands[2]+\"self.encode_float(modv));\");\n        context.code.push(operands[3]+\"quov);\");\n    },\n\n    0x1A8: function(context, operands) { /* sqrt */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.sqrt(\"+valf+\")));\");\n    },\n\n    0x1A9: function(context, operands) { /* exp */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.exp(\"+valf+\")));\");\n    },\n\n    0x1AA: function(context, operands) { /* log */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.log(\"+valf+\")));\");\n    },\n\n    0x1AB: function(context, operands) { /* pow */\n        context.varsused[\"valf\"] = true;\n        var valf0 = oputil_decode_float(context, operands[0], true);\n        var valf1 = oputil_decode_float(context, operands[1], true);\n        context.code.push(\"if (\"+operands[0]+\" == 0x3f800000) {\");\n        /* pow(1, anything) is 1 */\n        context.code.push(\"  valf = 0x3f800000;\");\n        context.code.push(\"} else if (\"+operands[0]+\" == 0xbf800000 && (\"+operands[1]+\" == 0xff800000 || \"+operands[1]+\" == 0x7f800000)) {\");\n        /* pow(-1, infinity) is 1 */\n        context.code.push(\"  valf = 0x3f800000;\");\n        context.code.push(\"} else {\");\n        context.code.push(\"  valf=self.encode_float(Math.pow(\"+valf0+\", \"+valf1+\"));\");\n        context.code.push(\"}\");\n        context.code.push(operands[2]+\"valf);\");\n    },\n\n    0x1B0: function(context, operands) { /* sin */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.sin(\"+valf+\")));\");\n    },\n\n    0x1B1: function(context, operands) { /* cos */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.cos(\"+valf+\")));\");\n    },\n\n    0x1B2: function(context, operands) { /* tan */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.tan(\"+valf+\")));\");\n    },\n\n    0x1B3: function(context, operands) { /* asin */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.asin(\"+valf+\")));\");\n    },\n\n    0x1B4: function(context, operands) { /* acos */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.acos(\"+valf+\")));\");\n    },\n\n    0x1B5: function(context, operands) { /* atan */\n        var valf = oputil_decode_float(context, operands[0]);\n        context.code.push(operands[1]+\"self.encode_float(Math.atan(\"+valf+\")));\");\n    },\n\n    0x1B6: function(context, operands) { /* atan2 */\n        var valf0 = oputil_decode_float(context, operands[0]);\n        var valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(operands[2]+\"self.encode_float(Math.atan2(\"+valf0+\", \"+valf1+\")));\");\n    },\n\n    0x1C0: function(context, operands) { /* jfeq */\n        var val, valf0, valf1, valf2;\n        context.varsused[\"fequal\"] = true;\n        context.varsused[\"fdiff\"] = true;\n        context.code.push(\"if ((\"+operands[2]+\" & 0x7f800000) == 0x7f800000 && (\"+operands[2]+\" & 0x007fffff) != 0) {\");\n        /* The delta is NaN, which can never match. */\n        context.code.push(\"  fequal = 0;\");\n        context.code.push(\"} else if ((\"+operands[0]+\" == 0xff800000 || \"+operands[0]+\" == 0x7f800000) && (\"+operands[1]+\" == 0xff800000 || \"+operands[1]+\" == 0x7f800000)) {\");\n        /* Both are infinite. Opposite infinities are never equal,\n           even if the difference is infinite, so this is easy. */\n        context.code.push(\"  fequal = (\"+operands[0]+\" == \"+operands[1]+\");\");\n        context.code.push(\"} else {\");\n        /* The other case: the values are not both infinite. */\n        if (quot_isconstant(operands[2])) {\n            val = Number(operands[2]);\n            valf2 = \"\" + decode_float(val & 0x7fffffff);\n        }\n        else {\n            val = \"self.decode_float((\"+operands[2]+\") & 0x7fffffff)\";\n            valf2 = alloc_holdvar(context);\n            context.code.push(valf2+\"=\"+val+\";\");\n        }\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"  fdiff = \"+valf1+\" - \"+valf0+\";\");\n        context.code.push(\"  fequal = (fdiff <= \"+valf2+\" && fdiff >= -(\"+valf2+\"));\");\n        context.code.push(\"}\");\n        context.code.push(\"if (fequal) {\");\n        oputil_perform_jump(context, operands[3]);\n        context.code.push(\"}\");\n    },\n\n    0x1C1: function(context, operands) { /* jfne */\n        var val, valf0, valf1, valf2;\n        context.varsused[\"fequal\"] = true;\n        context.varsused[\"fdiff\"] = true;\n        context.code.push(\"if ((\"+operands[2]+\" & 0x7f800000) == 0x7f800000 && (\"+operands[2]+\" & 0x007fffff) != 0) {\");\n        /* The delta is NaN, which can never match. */\n        context.code.push(\"  fequal = 0;\");\n        context.code.push(\"} else if ((\"+operands[0]+\" == 0xff800000 || \"+operands[0]+\" == 0x7f800000) && (\"+operands[1]+\" == 0xff800000 || \"+operands[1]+\" == 0x7f800000)) {\");\n        /* Both are infinite. Opposite infinities are never equal,\n           even if the difference is infinite, so this is easy. */\n        context.code.push(\"  fequal = (\"+operands[0]+\" == \"+operands[1]+\");\");\n        context.code.push(\"} else {\");\n        /* The other case: the values are not both infinite. */\n        if (quot_isconstant(operands[2])) {\n            val = Number(operands[2]);\n            valf2 = \"\" + decode_float(val & 0x7fffffff);\n        }\n        else {\n            val = \"self.decode_float((\"+operands[2]+\") & 0x7fffffff)\";\n            valf2 = alloc_holdvar(context);\n            context.code.push(valf2+\"=\"+val+\";\");\n        }\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"  fdiff = \"+valf1+\" - \"+valf0+\";\");\n        context.code.push(\"  fequal = (fdiff <= \"+valf2+\" && fdiff >= -(\"+valf2+\"));\");\n        context.code.push(\"}\");\n        context.code.push(\"if (!fequal) {\");\n        oputil_perform_jump(context, operands[3]);\n        context.code.push(\"}\");\n    },\n\n    0x1C2: function(context, operands) { /* jflt */\n        var valf0, valf1;\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"if (\"+valf0+\" < \"+valf1+\") {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x1C3: function(context, operands) { /* jfle */\n        var valf0, valf1;\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"if (\"+valf0+\" <= \"+valf1+\") {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x1C4: function(context, operands) { /* jfgt */\n        var valf0, valf1;\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"if (\"+valf0+\" > \"+valf1+\") {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x1C5: function(context, operands) { /* jfge */\n        var valf0, valf1;\n        valf0 = oputil_decode_float(context, operands[0]);\n        valf1 = oputil_decode_float(context, operands[1]);\n        context.code.push(\"if (\"+valf0+\" >= \"+valf1+\") {\");\n        oputil_perform_jump(context, operands[2]);\n        context.code.push(\"}\");\n    },\n\n    0x1C8: function(context, operands) { /* jisnan */\n        context.code.push(\"if ((\"+operands[0]+\" & 0x7f800000) == 0x7f800000 && (\"+operands[0]+\" & 0x007fffff) != 0) {\");\n        oputil_perform_jump(context, operands[1]);\n        context.code.push(\"}\");\n    },\n\n    0x1C9: function(context, operands) { /* jisinf */\n        context.code.push(\"if (\"+operands[0]+\" == 0xff800000 || \"+operands[0]+\" == 0x7f800000) {\");\n        oputil_perform_jump(context, operands[1]);\n        context.code.push(\"}\");\n    },\n\n    0x130: function(context, operands) { /* glk */\n        var mayblock;\n        if (quot_isconstant(operands[0]))\n            mayblock = self.Glk.call_may_not_return(Number(operands[0]));\n        else\n            mayblock = true;\n        if (mayblock) {\n            context.code.push(\"  self.prevpc = \"+context.prevcp+\";\");\n            context.code.push(\"  self.pc = \"+context.cp+\";\");\n        }\n        context.code.push(\"self.tempglkargs.length = \" + operands[1] + \";\");\n        if (quot_isconstant(operands[1])) {\n            var ix;\n            var argc = Number(operands[1]);\n            for (ix=0; ix<argc; ix++) {\n                if (context.offstack.length) {\n                    var holdvar = pop_offstack_holdvar(context);\n                    context.code.push(\"self.tempglkargs[\"+ix+\"]=\"+holdvar+\";\");\n                }\n                else {\n                    context.code.push(\"self.tempglkargs[\"+ix+\"]=self.frame.valstack.pop();\");\n                }\n            }\n            oputil_unload_offstate(context);\n        }\n        else {\n            context.varsused[\"ix\"] = true;\n            oputil_unload_offstate(context);\n            context.code.push(\"for (ix=0; ix<\"+operands[1]+\"; ix++) { self.tempglkargs[ix]=self.frame.valstack.pop(); }\");\n        }\n        /* In the blocking case, we don't perform a normal store; we write a\n           literal form of operands[2] into a global and get out. Fortunately\n           we just unloaded the offstack. The non-blocking case is a normal\n           store. */\n        context.varsused[\"glkret\"] = true;\n        context.code.push(\"glkret = self.GiDispa.get_function(\"+operands[0]+\")(self.tempglkargs);\");\n        if (mayblock) {\n            context.code.push(\"if (glkret === self.Glk.DidNotReturn) {\");\n            context.code.push(\"  self.resumefuncop = \"+oputil_record_funcop(operands[2])+\";\");\n            context.code.push(\"  self.resumevalue = 0;\");\n            context.code.push(\"  self.pc = \"+context.cp+\";\");\n            context.code.push(\"  self.done_executing = true;\");\n            context.code.push(\"  return;\");\n            context.code.push(\"}\");\n        }\n        oputil_store(context, operands[2], \"glkret\");\n    }\n}\n\n/* Select a currently-unused \"_hold*\" variable, and mark it used. \n   If use is true, it's marked \"1\", meaning it's going onto the offstack\n   or offloc. \n*/\nfunction alloc_holdvar(context, use) {\n    var ix = 0;\n    var key;\n    while (true) {\n        key = \"_hold\" + ix;\n        if (!context.holduse[key]) {\n            context.holduse[key] = (use ? 1 : true);\n            return key;\n        }\n        ix++;\n    }\n}\n\n/* Remove a value from the offstack. If it is a constant, return it. If it \n   is a _hold var, mark it as not used by the offstack any more, and return \n   it (now a temporary holdvar). \n   (Do not call this if the offstack is empty.)\n*/\nfunction pop_offstack_holdvar(context) {\n    var holdvar = context.offstack.pop();\n    if (quot_isconstant(holdvar)) {\n        return holdvar;\n    }\n\n    var use = context.holduse[holdvar];\n    ;;;if (isNaN(use) || use === false || use === true) {\n    ;;;    fatal_error(\"Offstack variable not marked as stack.\", holdvar); //assert\n    ;;;}\n    use--;\n    if (use == 0)\n        use = true; // Not on the stack any more\n    context.holduse[holdvar] = use;\n    return holdvar;\n}\n\n/* Push a variable value onto the offstack. (This must be a holdvar, not\n   a constant or expression.) Mark it as used an additional time by the\n   offstate.\n*/\nfunction push_offstack_holdvar(context, holdvar) {\n    context.offstack.push(holdvar);\n\n    var use = context.holduse[holdvar];\n    if (!use || use === true)\n        use = 1;\n    else\n        use++;\n    context.holduse[holdvar] = use;\n}\n\n/* Push a constant or holdvar into the offloc array. Reduce the usage of\n   the holdvar already there, if there was one. If inchold is true,\n   increase the usage of the new holdvar. (Only set this if value *is*\n   a holdvar, and if you haven't already set its use.)\n\n   If value is undefined, this erases the entry in the offloc array,\n   instead.\n*/\nfunction store_offloc_value(context, addr, value, inchold) {\n    var oldvar = context.offloc[addr];\n    if (oldvar && quot_isholdvar(oldvar)) {\n        var use = context.holduse[oldvar];\n        use--;\n        if (use == 0)\n            use = true; // Not on the offloc any more\n        context.holduse[oldvar] = use;\n    }\n\n    if (value === undefined) {\n        context.offloc[addr] = undefined;\n        context.offlocdirty[addr] = false;\n        return;\n    }\n\n    context.offloc[addr] = value;\n    context.offlocdirty[addr] = true;\n\n    if (inchold) {\n        var holdvar = value;\n        var use = context.holduse[holdvar];\n        if (!use || use === true)\n            use = 1;\n        else\n            use++;\n        context.holduse[holdvar] = use;\n    }\n}\n\n/* Transfer values from the real stack to the offstack until there are at\n   least count on the offstack. (Do not call this if there are insufficient\n   values on the real stack.)\n*/\nfunction transfer_to_offstack(context, count) {\n    var holdvar;\n    while (context.offstack.length < count) {\n        holdvar = alloc_holdvar(context, true);\n        context.offstack.unshift(holdvar);\n        context.code.push(holdvar+\"=self.frame.valstack.pop();\");\n    }\n}\n\n/* Check whether a quoted value is a constant. */\nfunction quot_isconstant(val) {\n    return (val[0] === \"0\");\n}\n\n/* Check whether a quoted value is a holdvar. */\nfunction quot_isholdvar(val) {\n    return (val[0] === \"_\");\n}\n\n/* Read the list of operands of an instruction, and put accessor code\n   in operands. This assumes that the CP is at the beginning of the\n   operand mode list (right after an opcode number.) Upon return,\n   the CP will be at the beginning of the next instruction.\n\n   The results go into operands[0], operands[1], etc. But these are not\n   the values themselves; what you get are JS expressions which will\n   generate them. The opcode handlers then insert these expressions\n   into the code being generated.\n\n   (At this stage, operands are always unsigned integers. A constant\n   -1 comes out as \"0xffffffff\".)\n\n   What you get depends on the operand type. The Glulx spec just\n   has Load and Store operands, but this function handles a couple of\n   variations.\n\n   Load operand types:\n\n   \"E\" (expression): The returned value is an arbitrary expression. It\n   may have side effects, so the opcode handler must use the expression\n   exactly once. If there are several \"E\" operands, the handler must\n   use them in order.\n   \n   \"L\" (load): The returned value is either a numeric constant or a\n   \"_holdN\" temporary variable. In the latter case, a line of the form\n   \"_holdN = EXPRESSION\" has been inserted into the generated code\n   (before the opcode handler's code). This is more expensive than\n   \"E\", but safer, because the value will not have side effects.\n\n   (Conveniently, \"E\" and \"L\" values can be categorized by their first\n   character. Constants begin with \"0\"; temporary variables begin with\n   \"_\"; anything else is a more complex expression.)\n\n   Store operand types:\n\n   \"F\" (function): The returned value is an object. When this is passed\n   to oputil_store(), it will generate code to store the value. (Do not\n   use more than one \"F\" per opcode.)\n\n   \"S\" (store): The returned value is an expression of the form \"FUNC(\".\n   Any expression can be appended, with a close-paren, to store a value\n   in the desired place. This is faster than \"F\", but less flexible;\n   it messes with the offstack in a confusing way, and also can't treat\n   constants specially.\n\n   \"C\" (callstub): The returned value is an expression of the form \n   \"desttype,destaddr\" -- two of the values in a Glulx call stub. The\n   oputil_push_callstub() function knows how to generate code that pushes\n   a call stub, if you pass these values in.\n   \n*/\nfunction parse_operands(context, cp, oplist, operands) {\n    var modeaddr;\n    var ix, modeval, mode;\n    var value, addr;\n    var holdvar;\n\n    operands.desttype = 0;\n    operands.numops = oplist.numops;\n\n    modeaddr = cp;\n    cp += ((oplist.numops+1) >> 1);\n\n    for (ix=0; ix<oplist.numops; ix++) {\n        if ((ix & 1) == 0) {\n            modeval = Mem1(modeaddr);\n            mode = (modeval & 0x0F);\n        }\n        else {\n            mode = ((modeval >> 4) & 0x0F);\n            modeaddr++;\n        }\n\n        var optype = oplist.formlist[ix];\n\n        if (optype == \"L\") {\n            switch (mode) {\n\n            case 8: /* pop off stack */\n                if (context.offstack.length) {\n                    operands[ix] = pop_offstack_holdvar(context);\n                }\n                else {\n                    holdvar = alloc_holdvar(context);\n                    context.code.push(holdvar+\"=self.frame.valstack.pop();\");\n                    operands[ix] = holdvar;\n                }\n                continue;\n                \n            case 0: /* constant zero */\n                operands[ix] = \"0\";\n                continue;\n                \n            case 1: /* one-byte constant */\n                /* Sign-extend from 8 bits to 32 */\n                value = QuoteMem1(cp);\n                cp++;\n                operands[ix] = value;\n                continue;\n                \n            case 2: /* two-byte constant */\n                /* Sign-extend the first byte from 8 bits to 32; the subsequent\n                   byte must not be sign-extended. */\n                value = QuoteMem2(cp);\n                cp += 2;\n                operands[ix] = value;\n                continue;\n                \n            case 3: /* four-byte constant */\n                /* Bytes must not be sign-extended. */\n                value = QuoteMem4(cp);\n                cp += 4;\n                operands[ix] = value;\n                continue;\n            }\n\n            if (mode >= 9 && mode <= 11) {\n                if (mode == 9) {\n                    addr = Mem1(cp);\n                    cp++;\n                }\n                else if (mode == 10) {\n                    addr = Mem2(cp);\n                    cp += 2;\n                }\n                else if (mode == 11) {\n                    addr = Mem4(cp);\n                    cp += 4;\n                }\n\n                if (context.offloc[addr] !== undefined) {\n                    operands[ix] = context.offloc[addr];\n                    continue;\n                }\n\n                if (oplist.argsize == 4) {\n                    value = \"self.frame.locals[\"+addr+\"]\";\n                }\n                else if (oplist.argsize == 2) {\n                    value = \"self.frame.locals[\"+addr+\"] & 0xffff\";\n                }\n                else {\n                    value = \"self.frame.locals[\"+addr+\"] & 0xff\";\n                }\n                holdvar = alloc_holdvar(context, true);\n                context.code.push(holdvar+\"=(\"+value+\");\");\n                context.offloc[addr] = holdvar;\n                context.offlocdirty[addr] = false;\n                operands[ix] = holdvar;\n                continue;\n            }\n\n            switch (mode) {\n            case 15: /* main memory RAM, four-byte address */\n                addr = Mem4(cp) + ramstart;\n                cp += 4;\n                break; \n\n            case 14: /* main memory RAM, two-byte address */\n                addr = Mem2(cp) + ramstart;\n                cp += 2;\n                break; \n\n            case 13: /* main memory RAM, one-byte address */\n                addr = Mem1(cp) + ramstart;\n                cp++;\n                break; \n        \n            case 7: /* main memory, four-byte address */\n                addr = Mem4(cp);\n                cp += 4;\n                break;\n\n            case 6: /* main memory, two-byte address */\n                addr = Mem2(cp);\n                cp += 2;\n                break;\n\n            case 5: /* main memory, one-byte address */\n                addr = Mem1(cp);\n                cp++;\n                break;\n\n            default:\n                fatal_error(\"Unknown addressing mode in load operand.\");\n            }\n\n            /* The main-memory cases. */\n            if (oplist.argsize == 4) {\n                value = \"self.Mem4(\"+addr+\")\";\n            }\n            else if (oplist.argsize == 2) {\n                value = \"self.Mem2(\"+addr+\")\";\n            }\n            else {\n                value = \"self.Mem1(\"+addr+\")\";\n            }\n            holdvar = alloc_holdvar(context);\n            context.code.push(holdvar+\"=(\"+value+\");\");\n            operands[ix] = holdvar;\n            continue;\n\n        }\n        else if (optype == \"E\") {\n            switch (mode) {\n\n            case 8: /* pop off stack */\n                if (context.offstack.length) {\n                    operands[ix] = pop_offstack_holdvar(context);\n                }\n                else {\n                    operands[ix] = \"self.frame.valstack.pop()\";\n                }\n                continue;\n                \n            case 0: /* constant zero */\n                operands[ix] = \"0\";\n                continue;\n                \n            case 1: /* one-byte constant */\n                /* Sign-extend from 8 bits to 32 */\n                value = QuoteMem1(cp);\n                cp++;\n                operands[ix] = value;\n                continue;\n                \n            case 2: /* two-byte constant */\n                /* Sign-extend the first byte from 8 bits to 32; the subsequent\n                   byte must not be sign-extended. */\n                value = QuoteMem2(cp);\n                cp += 2;\n                operands[ix] = value;\n                continue;\n                \n            case 3: /* four-byte constant */\n                /* Bytes must not be sign-extended. */\n                value = QuoteMem4(cp);\n                cp += 4;\n                operands[ix] = value;\n                continue;\n            }\n\n            if (mode >= 9 && mode <= 11) {\n                if (mode == 9) {\n                    addr = Mem1(cp);\n                    cp++;\n                }\n                else if (mode == 10) {\n                    addr = Mem2(cp);\n                    cp += 2;\n                }\n                else if (mode == 11) {\n                    addr = Mem4(cp);\n                    cp += 4;\n                }\n\n                if (context.offloc[addr] !== undefined) {\n                    operands[ix] = context.offloc[addr];\n                    continue;\n                }\n\n                if (oplist.argsize == 4) {\n                    value = \"self.frame.locals[\"+addr+\"]\";\n                }\n                else if (oplist.argsize == 2) {\n                    value = \"self.frame.locals[\"+addr+\"] & 0xffff\";\n                }\n                else {\n                    value = \"self.frame.locals[\"+addr+\"] & 0xff\";\n                }\n                holdvar = alloc_holdvar(context, true);\n                context.code.push(holdvar+\"=(\"+value+\");\");\n                context.offloc[addr] = holdvar;\n                context.offlocdirty[addr] = false;\n                operands[ix] = holdvar;\n                continue;\n            }\n\n            switch (mode) {\n            case 15: /* main memory RAM, four-byte address */\n                addr = Mem4(cp) + ramstart;\n                cp += 4;\n                break; \n\n            case 14: /* main memory RAM, two-byte address */\n                addr = Mem2(cp) + ramstart;\n                cp += 2;\n                break; \n\n            case 13: /* main memory RAM, one-byte address */\n                addr = Mem1(cp) + ramstart;\n                cp++;\n                break; \n        \n            case 7: /* main memory, four-byte address */\n                addr = Mem4(cp);\n                cp += 4;\n                break;\n\n            case 6: /* main memory, two-byte address */\n                addr = Mem2(cp);\n                cp += 2;\n                break;\n\n            case 5: /* main memory, one-byte address */\n                addr = Mem1(cp);\n                cp++;\n                break;\n\n            default:\n                fatal_error(\"Unknown addressing mode in load operand.\");\n            }\n\n            /* The main-memory cases. */\n            if (oplist.argsize == 4) {\n                value = \"self.Mem4(\"+addr+\")\";\n            }\n            else if (oplist.argsize == 2) {\n                value = \"self.Mem2(\"+addr+\")\";\n            }\n            else {\n                value = \"self.Mem1(\"+addr+\")\";\n            }\n            operands[ix] = value;\n            continue;\n\n        }\n        else if (optype == \"S\") {\n            switch (mode) {\n\n            case 8: /* push on stack */\n                /* Not on the actual stack, yet, but on the offstack. */\n                holdvar = alloc_holdvar(context, true);\n                context.offstack.push(holdvar);\n                operands[ix] = holdvar+\"=(\";\n                continue;\n                \n            case 0: /* discard value */\n                operands[ix] = \"(\";\n                continue;\n            }\n                \n            if (mode >= 9 && mode <= 11) {\n                if (mode == 9) {\n                    addr = Mem1(cp);\n                    cp++;\n                }\n                else if (mode == 10) {\n                    addr = Mem2(cp);\n                    cp += 2;\n                }\n                else if (mode == 11) {\n                    addr = Mem4(cp);\n                    cp += 4;\n                }\n                \n                /* The local-variable cases. */\n                if (oplist.argsize == 4) {\n                    holdvar = alloc_holdvar(context, true);\n                    store_offloc_value(context, addr, holdvar, false);\n                    operands[ix] = holdvar+\"=(\";\n                }\n                else if (oplist.argsize == 2) {\n                    store_offloc_value(context, addr, undefined);\n                    operands[ix] = \"self.frame.locals[\"+addr+\"]=(0xffff &\";\n                }\n                else {\n                    store_offloc_value(context, addr, undefined);\n                    operands[ix] = \"self.frame.locals[\"+addr+\"]=(0xff &\";\n                }\n                continue;\n            }\n\n            switch (mode) {\n            case 15: /* main memory RAM, four-byte address */\n                addr = Mem4(cp) + ramstart;\n                cp += 4;\n                break; \n\n            case 14: /* main memory RAM, two-byte address */\n                addr = Mem2(cp) + ramstart;\n                cp += 2;\n                break; \n\n            case 13: /* main memory RAM, one-byte address */\n                addr = Mem1(cp) + ramstart;\n                cp++;\n                break; \n        \n            case 7: /* main memory, four-byte address */\n                addr = Mem4(cp);\n                cp += 4;\n                break;\n\n            case 6: /* main memory, two-byte address */\n                addr = Mem2(cp);\n                cp += 2;\n                break;\n\n            case 5: /* main memory, one-byte address */\n                addr = Mem1(cp);\n                cp++;\n                break;\n\n            default:\n                fatal_error(\"Unknown addressing mode in store operand.\");\n            }\n\n            /* The main-memory cases. */\n            if (oplist.argsize == 4) {\n                value = \"self.MemW4(\"+addr+\",\";\n            }\n            else if (oplist.argsize == 2) {\n                value = \"self.MemW2(\"+addr+\",\";\n            }\n            else {\n                value = \"self.MemW1(\"+addr+\",\";\n            }\n            operands[ix] = value;\n            continue;\n        }\n        else if (optype == \"F\") {\n            var funcop = operands.func_store;\n\n            switch (mode) {\n\n            case 8: /* push on stack */\n                funcop.mode = 8;\n                funcop.argsize = oplist.argsize;\n                operands[ix] = funcop;\n                continue;\n                \n            case 0: /* discard value */\n                funcop.mode = 0;\n                funcop.argsize = oplist.argsize;\n                operands[ix] = funcop;\n                continue;\n            }\n                \n            if (mode >= 9 && mode <= 11) {\n                if (mode == 9) {\n                    addr = Mem1(cp);\n                    cp++;\n                }\n                else if (mode == 10) {\n                    addr = Mem2(cp);\n                    cp += 2;\n                }\n                else if (mode == 11) {\n                    addr = Mem4(cp);\n                    cp += 4;\n                }\n                \n                /* The local-variable cases. */\n                funcop.mode = 11;\n                funcop.addr = addr;\n                funcop.argsize = oplist.argsize;\n                operands[ix] = funcop;\n                continue;\n            }\n\n            switch (mode) {\n            case 15: /* main memory RAM, four-byte address */\n                addr = Mem4(cp) + ramstart;\n                cp += 4;\n                break; \n\n            case 14: /* main memory RAM, two-byte address */\n                addr = Mem2(cp) + ramstart;\n                cp += 2;\n                break; \n\n            case 13: /* main memory RAM, one-byte address */\n                addr = Mem1(cp) + ramstart;\n                cp++;\n                break; \n        \n            case 7: /* main memory, four-byte address */\n                addr = Mem4(cp);\n                cp += 4;\n                break;\n\n            case 6: /* main memory, two-byte address */\n                addr = Mem2(cp);\n                cp += 2;\n                break;\n\n            case 5: /* main memory, one-byte address */\n                addr = Mem1(cp);\n                cp++;\n                break;\n\n            default:\n                fatal_error(\"Unknown addressing mode in store operand.\");\n            }\n\n            /* The main-memory cases. */\n            funcop.mode = 15;\n            funcop.addr = addr;\n            funcop.argsize = oplist.argsize;\n            operands[ix] = funcop;\n            continue;\n        }\n        else if (optype == \"C\") {\n            switch (mode) {\n\n            case 8: /* push on stack */\n                operands[ix] = \"3,0\";\n                continue;\n                \n            case 0: /* discard value */\n                operands[ix] = \"0,0\";\n                continue;\n            }\n                \n            if (mode >= 9 && mode <= 11) {\n                if (mode == 9) {\n                    addr = Mem1(cp);\n                    cp++;\n                }\n                else if (mode == 10) {\n                    addr = Mem2(cp);\n                    cp += 2;\n                }\n                else if (mode == 11) {\n                    addr = Mem4(cp);\n                    cp += 4;\n                }\n                \n                /* The local-variable cases. */\n                operands[ix] = \"2,\"+addr;\n                continue;\n            }\n\n            switch (mode) {\n            case 15: /* main memory RAM, four-byte address */\n                addr = Mem4(cp) + ramstart;\n                cp += 4;\n                break; \n\n            case 14: /* main memory RAM, two-byte address */\n                addr = Mem2(cp) + ramstart;\n                cp += 2;\n                break; \n\n            case 13: /* main memory RAM, one-byte address */\n                addr = Mem1(cp) + ramstart;\n                cp++;\n                break; \n        \n            case 7: /* main memory, four-byte address */\n                addr = Mem4(cp);\n                cp += 4;\n                break;\n\n            case 6: /* main memory, two-byte address */\n                addr = Mem2(cp);\n                cp += 2;\n                break;\n\n            case 5: /* main memory, one-byte address */\n                addr = Mem1(cp);\n                cp++;\n                break;\n\n            default:\n                fatal_error(\"Unknown addressing mode in store operand.\");\n            }\n\n            /* The main-memory cases. */\n            operands[ix] = \"1,\"+addr;\n            continue;\n        }\n        else {\n            fatal_error(\"Unknown operand type.\", optype);\n        }\n    }\n\n    return cp;\n}\n\n/* Construct a VMFunc for the function at the given address.\n*/\nfunction compile_func(funcaddr) {\n    var addr = funcaddr;\n\n    /* Check the Glulx type identifier byte. */\n    var functype = Mem1(addr);\n    if (functype != 0xC0 && functype != 0xC1) {\n        if (functype >= 0xC0 && functype <= 0xDF)\n            fatal_error(\"Call to unknown type of function.\", addr);\n        else\n            fatal_error(\"Call to non-function.\", addr);\n    }\n    addr++;\n    \n    /* Go through the function's locals-format list, and construct a\n       slightly nicer description of the locals. (An array of [size, num].) */\n    var localsformat = [];\n    var rawstart = addr;\n    var ix = 0;\n    while (1) {\n        /* Grab two bytes from the locals-format list. These are \n           unsigned (0..255 range). */\n        var loctype = Mem1(addr);\n        addr++;\n        var locnum = Mem1(addr);\n        addr++;\n\n        if (loctype == 0) {\n            break;\n        }\n        if (loctype != 1 && loctype != 2 && loctype != 4) {\n            fatal_error(\"Invalid local variable size in function header.\", loctype);\n        }\n        \n        localsformat.push({ size:loctype, count:locnum });\n    }\n\n    /* We also copy the raw format list. This will be handy later on,\n       when we need to serialize the stack. Note that it might be\n       padded with extra zeroes to a four-byte boundary. */\n    var rawformat = memmap.slice(rawstart, addr);\n    while (rawformat.length % 4)\n        rawformat.push(0);\n\n    return new VMFunc(funcaddr, addr, localsformat, rawformat);\n}\n\n/* Construct a path for the given function starting at the given address.\n\n   A path is a sequence of JS statements (eval'ed into a JS function)\n   which implement the opcodes at that address. We compile as many\n   opcodes as we efficiently can; compilation stops at the first\n   call, return, unconditional branch, or so on. We also stop compilation\n   if we reach an opcode which we know to be the *destination* of a\n   branch. (The idea is that we're going to have to create a path\n   starting there anyhow -- you can't jump into the middle of a JS\n   function. So we avoid compiling those opcodes twice.)\n\n   The path function returns the special value VMStopped on @quit or \n   if the top-level function exits. This will stop VM execution. \n   (Note that glk_exit() doesn't cause this -- it technically leaves\n   the VM paused forever rather than stopped.)\n\n   After executing a path, the VM state (pc, stack, etc) are set\n   appropriately for the end of the path. However, we don't maintain\n   that state opcode by opcode *inside* the path.\n*/\nfunction compile_path(vmfunc, startaddr, startiosys) {\n    var cp = startaddr;\n    var opcode;\n    var opcodecp;\n    var key;\n\n    /* This will hold all sorts of useful information about the code\n       sequence we're compiling. */\n    var context = {\n        vmfunc: vmfunc,\n\n        cp: null, /* Will be filled in as we go */\n        prevcp: null, /* ditto */\n\n        /* The iosysmode, as of cp. This is always a literal value;\n           if it becomes unknown-at-compile-time, we stop compiling. */\n        curiosys: startiosys,\n\n        /* List of code lines. */\n        code: [],\n\n        /* Dict indicating which _hold variables are in use. A true value\n           means that the variable is used in this opcode; false means\n           it is not, but has been used before in the path; an integer\n           means the variable is in use on offstack or offloc (N times). */\n        holduse: {},\n\n        /* Dict indicating which other ad-hoc variables are in use. */\n        varsused: {},\n\n        /* A stack of quoted values (constants and _hold variables)\n           which should be on the value stack, but temporarily aren't. */\n        offstack: [],\n\n        /* An array of quoted values (constants and _hold variables)\n           which should be in the locals array, but temporarily aren't. */\n        offloc: [],\n\n        /* Indicates whether the values in offloc need to be written back\n           to the locals array. (True means yes; false means it's just a\n           a cached value and doesn't need to be written.) Same indices as \n           offloc. */\n        offlocdirty: [],\n\n        /* Set true when no more opcodes should be compiled for this path. */\n        path_ends: false\n    };\n\n    /* This will hold the operand information for each opcode we compile.\n       We'll recycle the object rather than allocating a new one each \n       time. */\n    var operands = {};\n    /* Another object to recycle. */\n    operands.func_store = {};\n\n    context.code.push(\"\"); /* May be replaced by the _hold var declarations. */\n\n    while (!context.path_ends) {\n\n        /* Stash the current opcode's address, in case the interpreter needs to\n           serialize the VM state out-of-band. */\n        context.prevcp = cp;\n\n        /* Fetch the opcode number. */\n        opcodecp = cp;\n        opcode = Mem1(cp);\n        if (opcode === undefined) \n            fatal_error(\"Tried to compile nonexistent address\", cp);\n        cp++;\n\n        if (opcode & 0x80) {\n            /* More than one-byte opcode. */\n            if (opcode & 0x40) {\n                /* Four-byte opcode */\n                opcode &= 0x3F;\n                opcode = (opcode * 0x100) | Mem1(cp);\n                cp++;\n                opcode = (opcode * 0x100) | Mem1(cp);\n                cp++;\n                opcode = (opcode * 0x100) | Mem1(cp);\n                cp++;\n            }\n            else {\n                /* Two-byte opcode */\n                opcode &= 0x7F;\n                opcode = (opcode * 0x100) | Mem1(cp);\n                cp++;\n            }\n        }\n\n        /* Now we have an opcode number. */\n        ;;;context.code.push(\"// \" + opcodecp.toString(16) + \": opcode \" + opcode.toString(16)); //debug\n\n        /* Fetch the structure that describes how the operands for this\n           opcode are arranged. This is a pointer to an immutable, \n           static object. */\n        var oplist = operandlist_table[opcode];\n        if (!oplist)\n            fatal_error(\"Encountered unknown opcode.\", opcode);\n        cp = parse_operands(context, cp, oplist, operands);\n        /* Some ophandlers need the next PC -- the address of the next\n           instruction. That's cp right now. */\n        context.cp = cp; \n\n        var ophandler = opcode_table[opcode];\n        if (!ophandler)\n            fatal_error(\"Encountered unhandled opcode.\", opcode);\n        ophandler(context, operands);\n\n        /* Any _hold variables which were used in this opcode (only)\n           are no longer used. Variables in the offstate are immune\n           to this. */\n        for (key in context.holduse) {\n            if (context.holduse[key] === true)\n                context.holduse[key] = false;\n        }\n\n        ;;;if (context.offstack.length) context.code.push(\"// offstack: \" + context.offstack.join(\",\")); //debug\n        ;;;if (context.offloc.length) context.code.push(\"// offloc: \" + context.offloc.join(\",\") + \"; dirty: \" + context.offlocdirty.join(\",\")); //debug\n        //context.code.push(\"// holduse: \" + qobjdump(context.holduse));\n\n        /* Check if any other compilation starts, or will start, at this\n           address. If so, no need to compile further. */\n        if (vmfunc.pathaddrs[cp] && !context.path_ends) {\n            ;;;context.code.push(\"// reached jump-in point\"); //debug\n            context.code.push(\"self.pc=\"+cp+\";\");\n            oputil_unload_offstate(context);\n            context.code.push(\"return;\");\n            context.path_ends = true;\n        }\n    }\n\n    if (context.offstack.length) \n        fatal_error(\"Path compilation ended with nonempty offstack.\", context.offstack.length);\n    if (context.offloc.length) \n        fatal_error(\"Path compilation ended with nonempty offloc.\", context.offloc.length);\n\n    /* Declare all the _hold variables, and other variables, that we need. */\n    {\n        var ls = [];\n        for (key in context.holduse)\n            ls.push(key);\n        for (key in context.varsused)\n            ls.push(key);\n        if (ls.length)\n            context.code[0] = \"var \" + ls.join(\",\") + \";\";\n    }\n\n    //qlog(\"### code at \" + startaddr.toString(16) + \":\\n\" + context.code.join(\"\\n\"));\n    return make_code(context.code.join(\"\\n\"), \"_func_path_\"+startaddr);\n}\n\n/* Prepare for execution of a new function. The argcount is the number\n   of arguments passed in; the arguments themselves are in the \n   tempcallargs array. (We don't rely on tempcallargs.length, as that\n   can be greater than argcount.)\n\n   This puts a new call frame onto the stack, and fills in its locals\n   (or valstack, for a 0xC0 function.) The pc is set to the function's\n   starting address.\n*/\nfunction enter_function(addr, argcount) {\n    var ix;\n\n    total_function_calls++; //###stats\n\n    /* If this address has been registered for an accelerated function,\n       dispatch it. */\n    var accelfunc = accel_address_map[addr];\n    if (accelfunc !== undefined) {\n        accel_function_calls++; //###stats\n        var val = accelfunc(argcount, self.tempcallargs);\n        pop_callstub(val);\n        return;\n    }\n\n    var vmfunc = vmfunc_table[addr];\n    if (vmfunc === undefined) {\n        vmfunc = compile_func(addr);\n        if (addr < ramstart)\n            vmfunc_table[addr] = vmfunc;\n    }\n\n    self.pc = vmfunc.startpc;\n\n    var newframe = new StackFrame(vmfunc);\n    newframe.depth = stack.length;\n    if (stack.length == 0)\n        newframe.framestart = 0;\n    else\n        newframe.framestart = self.frame.framestart + self.frame.framelen + 4*self.frame.valstack.length;\n    stack.push(newframe);\n    self.frame = newframe;\n\n    if (vmfunc.functype == 0xC0) {\n        /* Push the function arguments on the stack. The locals have already\n           been zeroed. */\n        for (ix=argcount-1; ix >= 0; ix--)\n            self.frame.valstack.push(self.tempcallargs[ix]);\n        self.frame.valstack.push(argcount);\n    }\n    else {\n        /* Copy in function arguments. This is a bit gross, since we have to\n           follow the locals format. If there are fewer arguments than locals,\n           that's fine -- we've already zeroed out this space. If there are\n           more arguments than locals, the extras are silently dropped. */\n        for (ix=0; ix<argcount; ix++) {\n            var form = vmfunc.localsindex[ix];\n            if (form === undefined)\n                break;\n            if (form.size == 4)\n                self.frame.locals[form.pos] = self.tempcallargs[ix];\n            else if (form.size == 2)\n                self.frame.locals[form.pos] = self.tempcallargs[ix] & 0xFFFF;\n            else if (form.size == 1)\n                self.frame.locals[form.pos] = self.tempcallargs[ix] & 0xFF;\n        }\n    }\n\n    //qlog(\"### framestart \" + self.frame.framestart + \", filled-in locals \" + qobjdump(self.frame.locals) + \", valstack \" + qobjdump(self.frame.valstack));\n}\nself.enter_function = enter_function;\n\n/* Pop the current call frame off the stack. This is very simple.\n   Returns true if the top-level stack frame is popped (thus stopping\n   the VM).\n*/\nfunction leave_function() {\n    var olddepth = self.frame.depth;\n\n    stack.pop();\n    if (stack.length == 0) {\n        self.frame = null;\n        return true;\n    }\n    self.frame = stack[stack.length-1];\n\n    if (self.frame.depth != olddepth-1)\n        fatal_error(\"Stack inconsistent after function exit.\");\n}\nself.leave_function = leave_function;\n\n/* Pop the stack down until it has length val. Used in the throw opcode. */\nfunction pop_stack_to(val) {\n    /* Down to the correct frame, if necessary. */\n    while (stack.length && stack[stack.length-1].framestart > val)\n        stack.pop();\n    if (stack.length == 0)\n        fatal_error(\"Stack evaporated during throw.\");\n    self.frame = stack[stack.length-1];\n\n    val -= (self.frame.framestart+self.frame.framelen);\n    if (val < 0)\n        fatal_error(\"Attempted to throw below the frame value stack.\");\n    if (val & 3)\n        fatal_error(\"Attempted to throw to an unaligned address.\");\n    val >>>= 2;\n    if (val > self.frame.valstack.length)\n        fatal_error(\"Attempted to throw beyond the frame value stack.\");\n    /* Down to the correct position in the valstack. */\n    self.frame.valstack.length = val;\n}\nself.pop_stack_to = pop_stack_to;\n\n/* Pop a callstub off the stack, and store a value at the appropriate \n   location. (When returning from a function, for example, the value is\n   the function return value, and it gets stored wherever the function\n   call wants it. The pc winds up pointing after the function call\n   opcode.)\n*/\nfunction pop_callstub(val) {\n    var destaddr, desttype;\n\n    //qlog(\"### return value \" + val.toString(16));\n    if (isNaN(val))\n        fatal_error(\"Function returned undefined value.\");\n\n    /* This somewhat clumsy way of popping off the last four elements of  the\n     * stack turns out to be significantly faster, which is great, because this\n     * function is extremely hot. */\n    var valstack = self.frame.valstack;\n    var vallen = valstack.length;\n    var framestart = valstack[vallen - 1];\n    if (framestart != self.frame.framestart) {\n        valstack.length -= 1;\n        fatal_error(\"Call stub frameptr (\" + framestart + \") \" +\n            \"does not match frame (\" + self.frame.framestart + \")\");\n    }\n    self.pc = valstack[vallen - 2];\n    destaddr = valstack[vallen - 3];\n    desttype = valstack[vallen - 4];\n    valstack.length -= 4;\n\n    switch (desttype) {\n    case 0:\n        return;\n    case 1:\n        MemW4(destaddr, val);\n        return;\n    case 2:\n        self.frame.locals[destaddr] = val;\n        return;\n    case 3:\n        self.frame.valstack.push(val);\n        return;\n\n    case 0x11:\n        fatal_error(\"String-terminator call stub at end of function call.\");\n        return;\n\n    case 0x10:\n        /* This call stub was pushed during a string-decoding operation!\n           We have to restart it. (Note that the return value is discarded.) */\n        stream_string(0, self.pc, 0xE1, destaddr); \n        return;\n\n    case 0x12:\n        /* This call stub was pushed during a number-printing operation.\n           Restart that. (Return value discarded.) */\n        stream_num(0, self.pc, true, destaddr);\n        return;\n\n    case 0x13:\n        /* This call stub was pushed during a C-string printing operation.\n           We have to restart it. (Note that the return value is discarded.) */\n        stream_string(0, self.pc, 0xE0, destaddr); \n        return;\n\n    case 0x14:\n        /* This call stub was pushed during a Unicode printing operation.\n           We have to restart it. (Note that the return value is discarded.) */\n        stream_string(0, self.pc, 0xE2, destaddr); \n        return;\n\n    default:\n        fatal_error(\"Unrecognized desttype in callstub.\", desttype);\n    }\n}\nself.pop_callstub = pop_callstub;\n\n/* Do the value-storing part of an already-popped call stub. (This is a\n   subset of the pop_callstub() work.) \n*/\nfunction store_operand(desttype, destaddr, val) {\n    switch (desttype) {\n    case 0:\n        return;\n    case 1:\n        MemW4(destaddr, val);\n        return;\n    case 2:\n        self.frame.locals[destaddr] = val;\n        return;\n    case 3:\n        self.frame.valstack.push(val);\n        return;\n    default:\n        fatal_error(\"Unrecognized desttype in callstub.\", desttype);\n    }\n}\nself.store_operand = store_operand;\n\n/* Do the value-storing work for a funcop. A null funcop is equivalent\n   to mode 0 \"discard\".\n*/\nfunction store_operand_by_funcop(funcop, val) {\n    if (!funcop)\n        return;\n\n    switch (funcop.mode) {\n\n    case 8: /* push on stack */\n        self.frame.valstack.push(val);\n        return;\n\n    case 0: /* discard value */\n        return;\n\n    case 11: /* The local-variable cases. */\n        if (funcop.argsize == 4) {\n            self.frame.locals[funcop.addr] = (val);\n        }\n        else if (funcop.argsize == 2) {\n            self.frame.locals[funcop.addr] = (0xffff & val);\n        }\n        else {\n            self.frame.locals[funcop.addr] = (0xff & val);\n        }\n        return;\n\n    case 15: /* The main-memory cases. */\n        if (funcop.argsize == 4) {\n            MemW4(funcop.addr, val);\n        }\n        else if (funcop.argsize == 2) {\n            MemW2(funcop.addr, val);\n        }\n        else {\n            MemW1(funcop.addr, val);\n        }\n        return;\n\n    default:\n        fatal_error(\"Unknown addressing mode in store func by operand.\");\n\n    }\n}\n\n/* Backtrack through the current opcode (at prevpc), and figure out whether\n   its input arguments are on the stack or not. This will be important when\n   setting up the saved VM state for restarting its opcode.\n   \n   Returns an object { selop, argsop, resop }.\n */\nfunction parse_partial_operand()\n{\n    var addr = self.prevpc;\n    \n    /* Fetch the opcode number. */\n    var opcode = Mem1(addr);\n    addr++;\n    if (opcode & 0x80) {\n        /* More than one-byte opcode. */\n        if (opcode & 0x40) {\n            /* Four-byte opcode */\n            opcode &= 0x3F;\n            opcode = (opcode << 8) | Mem1(addr);\n            addr++;\n            opcode = (opcode << 8) | Mem1(addr);\n            addr++;\n            opcode = (opcode << 8) | Mem1(addr);\n            addr++;\n        }\n        else {\n            /* Two-byte opcode */\n            opcode &= 0x7F;\n            opcode = (opcode << 8) | Mem1(addr);\n            addr++;\n        }\n    }\n    \n    if (opcode != 0x130) { /* op_glk */\n        qlog(\"parse_partial_operand: parsed wrong opcode: \" + opcode);\n        return null;\n    }\n    \n    /* @glk has operands LLS. */\n    return {\n        selop  : Mem1(addr) & 0x0F,\n        argsop : (Mem1(addr) >> 4) & 0x0F,\n        resop  : Mem1(addr+1) & 0x0F\n    };\n}\n\n/* Set the VM's random-number function to either a \"true\" RNG (Javascript's\n   Math.random), or a seeded deterministic RNG.\n*/\nfunction set_random(val) {\n    if (val == 0) {\n        self.random_func = Math.random;\n    }\n    else {\n        srand_set_seed(val);\n        self.random_func = srand_get_random;\n    }\n}\nself.set_random = set_random;\n\n/* Here is a pretty standard random-number generator and seed function.\n   It is used for the deterministic mode of the Glulx RNG. (In the\n   normal, non-deterministic mode, we rely on Math.random() -- hopefully\n   that pulls some nice juicy entropy from the OS.)\n*/\nvar srand_table = undefined; /* Array[0..54] */\nvar srand_index1, srand_index2;\n\nfunction srand_set_seed(seed) {\n    var i, ii, k, val, loop;\n\n    if (srand_table === undefined)\n        srand_table = Array(55);\n\n    srand_table[54] = seed;\n    srand_index1 = 0;\n    srand_index2 = 31;\n    \n    k = 1;\n\n    for (i = 0; i < 55; i++) {\n        ii = (21 * i) % 55;\n        srand_table[ii] = k;\n        k = (seed - k) >>>0;\n        seed = srand_table[ii];\n    }\n    for (loop = 0; loop < 4; loop++) {\n        for (i = 0; i < 55; i++) {\n            val = srand_table[i] - srand_table[ (1 + i + 30) % 55];\n            srand_table[i] = val >>>0;\n        }\n    }\n}\n\nfunction srand_get_random() {\n    srand_index1 = (srand_index1 + 1) % 55;\n    srand_index2 = (srand_index2 + 1) % 55;\n    srand_table[srand_index1] = (srand_table[srand_index1] - srand_table[srand_index2]) >>>0;\n    return srand_table[srand_index1] / 0x100000000;\n}\n\n/* accel_funcnum_map maps VM addresses to the index number of the (native)\n   functions used to accelerate them. accel_address_map maps VM addresses\n   directly to the native functions. (So accel_address_map[x] ==\n   accel_func_map[accel_funcnum_map[x]].) These are also referenced from\n   self. */\nvar accel_address_map = {};\nvar accel_funcnum_map = {};\nself.accel_address_map = accel_address_map;\nself.accel_funcnum_map = accel_funcnum_map;\n\n/* A list of the nine parameter fields used by the accelerated functions. */\nvar accel_params = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\nself.accel_params = accel_params;\n\n/* The code for all the functions we can accelerate. Unrecognized indexes,\n   including zero, map to undefined.\n\n   Remember that there may be fewer arguments than expected, and any beyond\n   argc should be taken as zero.\n*/\nvar accel_func_map = {\n    1: function func_1_z__region(argc, argv) {\n        if (argc < 1)\n            return 0;\n\n        var addr = argv[0];\n        if (addr < 36)\n            return 0;\n        if (addr >= self.endmem)\n            return 0;\n\n        var tb = Mem1(addr);\n        if (tb >= 0xE0) {\n            return 3;\n        }\n        if (tb >= 0xC0) {\n            return 2;\n        }\n        if (tb >= 0x70 && tb <= 0x7F && addr >= ramstart) {\n            return 1;\n        }\n        return 0;\n    },\n\n    2: function func_2_cp__tab(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        /* func_1_z__region(obj) */\n        if (accel_func_map[1](argc, argv) != 1) { \n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to find the \\\".\\\" of (something) **]\\n\");\n            return 0;\n        }\n\n        var otab = Mem4(obj + 16);\n        if (!otab)\n            return 0;\n\n        var max = Mem4(otab);\n        otab += 4;\n        /* @binarysearch id 2 otab 10 max 0 0 res; */\n        return binary_search(id, 2, otab, 10, max, 0, 0);\n    },\n\n    3: function func_3_ra__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var prop = accel_helper_get_prop(obj, id);\n        if (prop == 0)\n            return 0;\n\n        return Mem4(prop + 4);\n    },\n\n    4: function func_4_rl__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var prop = accel_helper_get_prop(obj, id);\n        if (prop == 0)\n            return 0;\n\n        return 4 * Mem2(prop + 2);\n    },\n\n    5: function func_5_oc__cl(argc, argv) {\n        var zr, prop, inlist, inlistlen, jx;\n\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var cla = ((argc > 1) ? argv[1] : 0);\n\n        /* func_1_z__region(obj) */\n        zr = accel_func_map[1](argc, argv);\n        if (zr == 3)\n            return (cla == accel_params[5]) ? 1 : 0;\n        if (zr == 2)\n            return (cla == accel_params[4]) ? 1 : 0;\n        if (zr != 1)\n            return 0;\n    \n        if (cla == accel_params[2]) {\n            if (accel_helper_obj_in_class(obj))\n                return 1;\n            if (obj == accel_params[2])\n                return 1;\n            if (obj == accel_params[5])\n                return 1;\n            if (obj == accel_params[4])\n                return 1;\n            if (obj == accel_params[3])\n                return 1;\n            return 0;\n        }\n        if (cla == accel_params[3]) {\n            if (accel_helper_obj_in_class(obj))\n                return 0;\n            if (obj == accel_params[2])\n                return 0;\n            if (obj == accel_params[5])\n                return 0;\n            if (obj == accel_params[4])\n                return 0;\n            if (obj == accel_params[3])\n                return 0;\n            return 1;\n        }\n        if ((cla == accel_params[5]) || (cla == accel_params[4]))\n            return 0;\n    \n        if (!accel_helper_obj_in_class(cla)) {\n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to apply 'ofclass' with non-class **]\\n\");\n            return 0;\n        }\n    \n        prop = accel_helper_get_prop(obj, 2);\n        if (prop == 0)\n           return 0;\n    \n        inlist = Mem4(prop + 4);\n        if (inlist == 0)\n           return 0;\n    \n        inlistlen = Mem2(prop + 2);\n        for (jx = 0; jx < inlistlen; jx++) {\n            if (Mem4(inlist + (4 * jx)) == cla)\n                return 1;\n        }\n        return 0;\n    },\n\n    6: function func_6_rv__pr(argc, argv) {\n        var id = ((argc > 1) ? argv[1] : 0);\n        var addr;\n\n        /* func_3_ra__pr */\n        addr = accel_func_map[3](argc, argv);\n        \n        if (addr == 0) {\n            /* id > 0 && id < indiv_prop_start */\n            if ((id > 0) && (id < accel_params[1])) {\n                /* Mem4(cpv__start + 4*id) */\n                return Mem4(accel_params[8] + (4 * id));\n            }\n\n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to read (something) **]\\n\");\n            return 0;\n        }\n\n        return Mem4(addr);\n    },\n\n    7: function func_7_op__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var indiv_prop_start = accel_params[1];\n\n        /* func_1_z__region(obj) */\n        var zr = accel_func_map[1](argc, argv);\n        if (zr == 3) {\n            /* print is INDIV_PROP_START+6 */\n            if (id == indiv_prop_start+6)\n                return 1;\n            /* print_to_array is INDIV_PROP_START+7 */\n            if (id == indiv_prop_start+7)\n                return 1;\n            return 0;\n        }\n        if (zr == 2) {\n            /* call is INDIV_PROP_START+5 */\n            return ((id == indiv_prop_start+5) ? 1 : 0);\n        }\n        if (zr != 1)\n            return 0;\n    \n        if ((id >= indiv_prop_start) && (id < indiv_prop_start+8)) {\n            if (accel_helper_obj_in_class(obj))\n                return 1;\n        }\n    \n        /* func_3_ra__pr */\n        return ((accel_func_map[3](argc, argv)) ? 1 : 0);\n    },\n\n    8: function func_8_cp__tab(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        /* func_1_z__region(obj) */\n        if (accel_func_map[1](argc, argv) != 1) { \n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to find the \\\".\\\" of (something) **]\\n\");\n            return 0;\n        }\n\n        /*  otab = Mem4(obj + 4*(3+(int)(num_attr_bytes/4))); */\n        var otab = Mem4(obj + 4*(3+(accel_params[7]>>2)));\n        if (!otab)\n            return 0;\n\n        var max = Mem4(otab);\n        otab += 4;\n        /* @binarysearch id 2 otab 10 max 0 0 res; */\n        return binary_search(id, 2, otab, 10, max, 0, 0);\n    },\n\n    9: function func_9_ra__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var prop = accel_helper_get_prop_new(obj, id);\n        if (prop == 0)\n            return 0;\n\n        return Mem4(prop + 4);\n    },\n\n    10: function func_10_rl__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var prop = accel_helper_get_prop_new(obj, id);\n        if (prop == 0)\n            return 0;\n\n        return 4 * Mem2(prop + 2);\n    },\n\n    11: function func_11_oc__cl(argc, argv) {\n        var zr, prop, inlist, inlistlen, jx;\n\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var cla = ((argc > 1) ? argv[1] : 0);\n\n        /* func_1_z__region(obj) */\n        zr = accel_func_map[1](argc, argv);\n        if (zr == 3)\n            return (cla == accel_params[5]) ? 1 : 0;\n        if (zr == 2)\n            return (cla == accel_params[4]) ? 1 : 0;\n        if (zr != 1)\n            return 0;\n    \n        if (cla == accel_params[2]) {\n            if (accel_helper_obj_in_class(obj))\n                return 1;\n            if (obj == accel_params[2])\n                return 1;\n            if (obj == accel_params[5])\n                return 1;\n            if (obj == accel_params[4])\n                return 1;\n            if (obj == accel_params[3])\n                return 1;\n            return 0;\n        }\n        if (cla == accel_params[3]) {\n            if (accel_helper_obj_in_class(obj))\n                return 0;\n            if (obj == accel_params[2])\n                return 0;\n            if (obj == accel_params[5])\n                return 0;\n            if (obj == accel_params[4])\n                return 0;\n            if (obj == accel_params[3])\n                return 0;\n            return 1;\n        }\n        if ((cla == accel_params[5]) || (cla == accel_params[4]))\n            return 0;\n    \n        if (!accel_helper_obj_in_class(cla)) {\n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to apply 'ofclass' with non-class **]\\n\");\n            return 0;\n        }\n    \n        prop = accel_helper_get_prop_new(obj, 2);\n        if (prop == 0)\n           return 0;\n    \n        inlist = Mem4(prop + 4);\n        if (inlist == 0)\n           return 0;\n    \n        inlistlen = Mem2(prop + 2);\n        for (jx = 0; jx < inlistlen; jx++) {\n            if (Mem4(inlist + (4 * jx)) == cla)\n                return 1;\n        }\n        return 0;\n    },\n\n    12: function func_12_rv__pr(argc, argv) {\n        var id = ((argc > 1) ? argv[1] : 0);\n        var addr;\n\n        /* func_9_ra__pr */\n        addr = accel_func_map[9](argc, argv);\n        \n        if (addr == 0) {\n            /* id > 0 && id < indiv_prop_start */\n            if ((id > 0) && (id < accel_params[1])) {\n                /* Mem4(cpv__start + 4*id) */\n                return Mem4(accel_params[8] + (4 * id));\n            }\n\n            self.Glk.glk_put_jstring(\"\\n[** Programming error: tried to read (something) **]\\n\");\n            return 0;\n        }\n\n        return Mem4(addr);\n    },\n\n    13: function func_13_op__pr(argc, argv) {\n        var obj = ((argc > 0) ? argv[0] : 0);\n        var id = ((argc > 1) ? argv[1] : 0);\n\n        var indiv_prop_start = accel_params[1];\n\n        /* func_1_z__region(obj) */\n        var zr = accel_func_map[1](argc, argv);\n        if (zr == 3) {\n            /* print is INDIV_PROP_START+6 */\n            if (id == indiv_prop_start+6)\n                return 1;\n            /* print_to_array is INDIV_PROP_START+7 */\n            if (id == indiv_prop_start+7)\n                return 1;\n            return 0;\n        }\n        if (zr == 2) {\n            /* call is INDIV_PROP_START+5 */\n            return ((id == indiv_prop_start+5) ? 1 : 0);\n        }\n        if (zr != 1)\n            return 0;\n    \n        if ((id >= indiv_prop_start) && (id < indiv_prop_start+8)) {\n            if (accel_helper_obj_in_class(obj))\n                return 1;\n        }\n    \n        /* func_9_ra__pr */\n        return ((accel_func_map[9](argc, argv)) ? 1 : 0);\n    }\n};\nself.accel_func_map = accel_func_map;\n\nvar accel_helper_temp_args = [ 0, 0 ];\n\nfunction accel_helper_obj_in_class(obj)\n{\n    /* This checks whether obj is contained in Class, not whether\n       it is a member of Class. */\n    /* (Mem4(obj + 13 + num_attr_bytes) == class_metaclass) */\n    return (Mem4(obj + 13 + accel_params[7]) == accel_params[2]);\n}\n\n/* Look up a property entry. */\nfunction accel_helper_get_prop(obj, id)\n{\n    var cla = 0;\n    var prop;\n\n    if (id & 0xFFFF0000) {\n        /* Mem4(classes_table+...) */\n        cla = Mem4(accel_params[0]+((id & 0xFFFF) * 4));\n        accel_helper_temp_args[0] = obj;\n        accel_helper_temp_args[1] = cla;\n        /* func_5_oc__cl */\n        if (accel_func_map[5](2, accel_helper_temp_args) == 0)\n            return 0;\n\n        id = id >> 16;\n        obj = cla;\n    }\n\n    accel_helper_temp_args[0] = obj;\n    accel_helper_temp_args[1] = id;\n    /* func_2_cp__tab */\n    prop = accel_func_map[2](2, accel_helper_temp_args);\n    if (prop == 0)\n        return 0;\n\n    if (accel_helper_obj_in_class(obj) && (cla == 0)) {\n        /* id < num_attr_bytes || id >= num_attr_bytes+8 */\n        if ((id < accel_params[1]) || (id >= accel_params[1]+8))\n            return 0;\n    }\n\n    /* Mem4(self) -- the global variable self */\n    if (Mem4(accel_params[6]) != obj) {\n        if (Mem1(prop + 9) & 1)\n            return 0;\n    }\n    return prop;\n}\n\n/* Look up a property entry. This is part of the newer set of accel\n   functions (8 through 13), which support increasing NUM_ATTR_BYTES.\n   It is identical to get_prop() except that it calls the new versions\n   of func_5 and func_2. */\nfunction accel_helper_get_prop_new(obj, id)\n{\n    var cla = 0;\n    var prop;\n\n    if (id & 0xFFFF0000) {\n        /* Mem4(classes_table+...) */\n        cla = Mem4(accel_params[0]+((id & 0xFFFF) * 4));\n        accel_helper_temp_args[0] = obj;\n        accel_helper_temp_args[1] = cla;\n        /* func_11_oc__cl */\n        if (accel_func_map[11](2, accel_helper_temp_args) == 0)\n            return 0;\n\n        id = id >> 16;\n        obj = cla;\n    }\n\n    accel_helper_temp_args[0] = obj;\n    accel_helper_temp_args[1] = id;\n    /* func_8_cp__tab */\n    prop = accel_func_map[8](2, accel_helper_temp_args);\n    if (prop == 0)\n        return 0;\n\n    if (accel_helper_obj_in_class(obj) && (cla == 0)) {\n        /* id < num_attr_bytes || id >= num_attr_bytes+8 */\n        if ((id < accel_params[1]) || (id >= accel_params[1]+8))\n            return 0;\n    }\n\n    /* Mem4(self) -- the global variable self */\n    if (Mem4(accel_params[6]) != obj) {\n        if (Mem1(prop + 9) & 1)\n            return 0;\n    }\n    return prop;\n}\n\n\n/* Set the current table address, and rebuild decoding tree. */\nfunction set_string_table(addr) {\n    if (self.stringtable == addr)\n        return;\n\n    /* Drop the existing cache and tree. */\n    decoding_tree = undefined;\n    vmstring_table = undefined;\n\n    /* Set the register. */\n    self.stringtable = addr;\n\n    if (self.stringtable == 0) {\n        return;\n    }\n\n    var textenv = vmtextenv_table[self.stringtable];\n    if (textenv === undefined) {\n        /* We will need a new VMTextEnv. */\n        /* If the table is entirely in ROM, we can build a decoding tree.\n           If not, leave it undefined in the VMTextEnv. */\n        var dectab = undefined;\n        var tablelen = Mem4(self.stringtable);\n        var rootaddr = Mem4(self.stringtable+8);\n        var cache_stringtable = (self.stringtable+tablelen <= ramstart);\n        if (cache_stringtable) {\n            //qlog(\"building decoding table at \" + self.stringtable.toString(16) + \", length \" + tablelen.toString(16));\n            var tmparray = Array(1);\n            //var pathstart = new Date().getTime(); //debug\n            build_decoding_tree(tmparray, rootaddr, 4 /*CACHEBITS*/, 0);\n            dectab = tmparray[0];\n            if (dectab === undefined)\n                fatal_error(\"Failed to create decoding tree.\");\n            //qlog(\"done building; time = \" + ((new Date().getTime())-pathstart) + \" ms\"); //debug\n        }\n\n        textenv = new VMTextEnv(self.stringtable, dectab);\n        vmtextenv_table[self.stringtable] = textenv;\n    }\n\n    decoding_tree = textenv.decoding_tree;\n    vmstring_table = textenv.vmstring_tables[self.iosysmode];\n}\nself.set_string_table = set_string_table;\n\n/* Set the VM iosys, and adjust the vmstring_table register appropriately. \n*/\nfunction set_iosys(mode, rock) {\n    switch (mode) {\n    case 0: /* null */\n        rock = 0;\n        break;\n    case 1: /* filter */\n        break;\n    case 2: /* glk */\n        rock = 0;\n        break;\n    default: /* pretend it's null */\n        mode = 0;\n        rock = 0;\n        break;\n    }\n\n    self.iosysmode = mode;\n    self.iosysrock = rock;\n\n    var textenv = vmtextenv_table[self.stringtable];\n    if (textenv === undefined)\n        vmstring_table = undefined;\n    else\n        vmstring_table = textenv.vmstring_tables[self.iosysmode];\n}\nself.set_iosys = set_iosys;\n\n/* The form of the decoding tree is a tree of arrays and leaf objects.\n   An array always has 16 entries (2^CACHESIZE). Every object, including\n   the array, has a \"type\" field corresponding to the Glulx node type.\n\n   The arrays have a peculiar structure (inherited from Glulxe). Each one\n   encapsulates a subtree of binary branch nodes, up to four nodes deep. This\n   lets you traverse the tree four levels at a time (using four input bits at\n   a time). The first input bit is the 1s place of the array index, and so \n   on.\n\n   Life gets complicated if we want to encode *fewer* than four levels. A\n   subtree with only one branch (and two leaves) must duplicate each leaf\n   four times: 0,1,0,1,... This is because the decoder will index using\n   four bits at a time, but the high bits will be undefined.\n\n   The initial argument is the array we're writing into. If this is the\n   top-level call, it will be a fake (length-one) array -- see above.\n*/\nfunction build_decoding_tree(cablist, nodeaddr, depth, mask) {\n    var ix, type, cab;\n    var depthbit;\n\n    type = Mem1(nodeaddr);\n\n    if (type == 0 && depth == 4) { /*CACHEBITS*/\n        /* Start a new array. */\n        cab = Array(16); /*CACHESIZE*/\n        cab.type = 0;\n        cab.depth = 4; /*CACHEBITS*/\n        cablist[mask] = cab;\n        build_decoding_tree(cab, nodeaddr, 0, 0);\n        return;\n    }\n\n    if (type == 0) {\n        var leftaddr  = Mem4(nodeaddr+1);\n        var rightaddr = Mem4(nodeaddr+5);\n        build_decoding_tree(cablist, leftaddr, depth+1, mask);\n        build_decoding_tree(cablist, rightaddr, depth+1, (mask | (1 << depth)));\n        return;\n    }\n\n    /* Leaf node. */\n    nodeaddr++;\n\n    cab = {};\n    cab.type = type;\n    cab.depth = depth;\n    switch (type) {\n    case 0x02: /* 8-bit character */\n        cab.value = Mem1(nodeaddr);\n        cab.cchar = CharToString(cab.value);\n        break;\n    case 0x04: /* Unicode character */\n        cab.value = Mem4(nodeaddr);\n        cab.cchar = CharToString(cab.value);\n        break;\n    case 0x03: /* C-style string */\n    case 0x05: /* C-style unicode string */\n        /* If the address is in ROM, we could read it, convert to a JS\n           string, and store it in the node. */\n        cab.addr = nodeaddr;\n        break;\n    case 0x08: /* indirect ref */\n    case 0x09: /* double-indirect ref */\n        cab.addr = Mem4(nodeaddr);\n        break;\n    case 0x0A: /* indirect ref with arguments */\n    case 0x0B: /* double-indirect ref with arguments */\n        cab.addr = nodeaddr;\n        break;\n    case 0x01: /* terminator */\n        break;\n    default:\n        fatal_error(\"Unknown node type in string table.\", type);\n    }\n\n    depthbit = (1 << depth);\n    for (ix = mask; ix < 16 /* CACHESIZE */; ix += depthbit) {\n        cablist[ix] = cab;\n    }\n}\n\n/* Print a (signed, decimal) integer. The incoming value is actually\n   unsigned, so we have to convert it (using the \"& 0xffffffff\" trick)\n   before stringifying it.\n\n   This is only called when the iosysmode is filter. However, we could\n   re-enter (with inmiddle true) with some other iosysmode, so we handle\n   all the cases.\n*/\nfunction stream_num(nextcp, value, inmiddle, charnum) {\n    var buf = (value & 0xffffffff).toString(10);\n\n    //qlog(\"### stream_num(\" + nextcp + \", \" + buf + \", \" + inmiddle + \", \" + charnum + \") iosys \" + self.iosysmode);\n\n    switch (self.iosysmode) {\n    case 2: /* glk */\n        if (charnum)\n            buf = buf.slice(charnum);\n        self.Glk.glk_put_jstring(buf, true);\n        break;\n\n    case 1: /* filter */\n        if (!inmiddle) {\n            // push_callstub(0x11, 0);\n            self.frame.valstack.push(0x11, 0, nextcp, self.frame.framestart);\n            inmiddle = true;\n        }\n        if (charnum < buf.length) {\n            var ch = buf.charCodeAt(charnum);\n            /* Note that value is unsigned here -- only unsigned values\n               go on the stack. */\n            // push_callstub(0x12, charnum+1);\n            self.frame.valstack.push(0x12, charnum+1, value, self.frame.framestart);\n            self.tempcallargs[0] = ch;\n            enter_function(self.iosysrock, 1);\n            return true;\n        }\n        break;\n\n    case 0: /* null */\n        break;\n    }\n\n    if (inmiddle) {\n        var desttype, destaddr;\n        /* String terminated. Carry out a pop_callstub_string(). */\n        if (self.frame.valstack.pop() != self.frame.framestart)\n            fatal_error(\"Call stub frameptr does not match frame.\");\n        self.pc = self.frame.valstack.pop();\n        destaddr = self.frame.valstack.pop();\n        desttype = self.frame.valstack.pop();\n        if (desttype != 0x11) \n            fatal_error(\"String-on-string call stub while printing number.\");\n    }\n}\nself.stream_num = stream_num;\n\n/* Look up a string, and print or execute it.\n\n   This returns true if a sub-function needs to be called. In this case,\n   the pc and stack are already set up, so the caller needs to return\n   to the main execution loop.\n\n   This returns false if execution can continue for the caller. This is the\n   simple case, where the caller began at the start of a string and the\n   whole thing got printed.\n*/\nfunction stream_string(nextcp, addr, inmiddle, bitnum) {\n    var substring = (inmiddle != 0);\n    var addrkey, strop, res;\n    var desttype, destaddr;\n\n    //qlog(\"### stream_string(\"+addr+\") from cp=\"+nextcp+\" $\"+nextcp.toString(16)+\" in iosys \"+self.iosysmode);\n\n    while (true) {\n        strop = undefined;\n        if (inmiddle == 0)\n            addrkey = addr;\n        else\n            addrkey = addr+\"/\"+inmiddle+\"/\"+bitnum;\n\n        if (vmstring_table !== undefined && addr < ramstart) {\n            strop = vmstring_table[addrkey];\n            if (strop === undefined) {\n                strop = compile_string(self.iosysmode, addr, inmiddle, bitnum);\n                vmstring_table[addrkey] = strop;\n                strings_compiled++; //###stats\n                strings_cached++; //###stats\n            }\n        }\n        else {\n            strop = compile_string(self.iosysmode, addr, inmiddle, bitnum);\n            strings_compiled++; //###stats\n        }\n\n        //qlog(\"### strop(\" + addrkey + (substring?\":[sub]\":\"\") + \"): \" + strop);\n    \n        if (!(strop instanceof Function)) {\n            self.Glk.glk_put_jstring(strop);\n            if (!substring)\n                return false;\n        }\n        else {\n            res = strop(self, nextcp, substring);\n            if (res instanceof Array) {\n                /* Entered a substring */\n                substring = true;\n                addr = res[0];\n                inmiddle = res[1];\n                bitnum = res[2];\n                //qlog(\"### push to addr=\"+addr+\"/\"+inmiddle+\"/\"+bitnum);\n                continue;\n            }\n            if (res) {\n                /* Entered a function. The pc is set. */\n                return true;\n            }\n            /* Else, string terminated. */\n        }\n        \n        /* String terminated. Carry out a pop_callstub_string(). */\n        if (self.frame.valstack.pop() != self.frame.framestart)\n            fatal_error(\"Call stub frameptr does not match frame.\");\n        self.pc = self.frame.valstack.pop();\n        destaddr = self.frame.valstack.pop();\n        desttype = self.frame.valstack.pop();\n\n        if (desttype == 0x11) {\n            /* The call stub for the top-level string. Return to the main\n               execution loop. */\n            return true;\n        }\n        else if (desttype == 0x10) {\n            /* The call stub for a sub-function. Continue the compressed\n               string that called it. */\n            substring = true;\n            bitnum = destaddr;\n            inmiddle = 0xE1;\n            addr = self.pc;\n            //qlog(\"### end; pop to addr=\"+addr+\"/\"+inmiddle+\"/\"+bitnum);\n        }\n        else {\n            fatal_error(\"Function-terminator call stub at end of string.\");\n        }\n    }\n}\nself.stream_string = stream_string;\n\n/* Generate a function which outputs the string, or rather one path of it.\n   Like function paths, a string path only runs up to the first internal\n   call; then it exits so that the main terp loop can start working on\n   the function.\n\n   The generated function returns true if a VM function is set up to go next;\n   an array [addr, inmiddle, bitnum] if a new (or re-entering) string is set\n   up; or false if the string has ended normally. In the latter case, a\n   string-callstub needs to be popped and used.\n\n   If the string ends with no sub-strings or sub-calls (the substring flag\n   stays false, and there is no stack activity), then this doesn't bother with\n   a function. It returns a plain string.\n*/\nfunction compile_string(curiosys, startaddr, inmiddle, startbitnum) {\n    var addr = startaddr;\n    var bitnum = startbitnum;\n    var retval = undefined;\n    var ch, type;\n\n    if (!addr)\n        fatal_error(\"Called compile_string with null address.\");\n\n    /* This will hold all sorts of useful information about the code\n       sequence we're compiling. */\n    var context = {\n        startaddr: startaddr,\n        startbitnum: startbitnum,\n        buffer: [],\n        code: []\n    }\n\n    if (inmiddle == 0) {\n        type = Mem1(addr);\n        if (type == 0xE2)\n            addr+=4;\n        else\n            addr++;\n        bitnum = 0;\n    }\n    else {\n        type = inmiddle;\n    }\n\n    if (type == 0xE1) {\n        if (decoding_tree) {\n            var bits, numbits, readahead, tmpaddr;\n            var cablist, cab;\n            var done = false;\n\n            /* bitnum is already set right */\n            bits = Mem1(addr); \n            if (bitnum)\n                bits >>= bitnum;\n            numbits = (8 - bitnum);\n            readahead = false;\n            \n            if (!(decoding_tree instanceof Array)) {\n                /* This is a bit of a cheat. If the top-level block is not\n                   a branch, then it must be a string-terminator -- otherwise\n                   the string would be an infinite repetition of that block.\n                   We check for this case and bail immediately. */\n                done = true;\n            }\n\n            cablist = decoding_tree;\n            while (!done) {\n                if (numbits < 4) { /* CACHEBITS */\n                    /* readahead is certainly false */\n                    var newbyte = Mem1(addr+1);\n                    bits |= (newbyte << numbits);\n                    numbits += 8;\n                    readahead = true;\n                }\n\n                cab = cablist[bits & 0x0F]; /* CACHEMASK */\n                numbits -= cab.depth;\n                bits >>= cab.depth;\n                bitnum += cab.depth;\n                if (bitnum >= 8) {\n                    addr += 1;\n                    bitnum -= 8;\n                    if (readahead) {\n                        readahead = false;\n                    }\n                    else {\n                        var newbyte = Mem1(addr);\n                        bits |= (newbyte << numbits);\n                        numbits += 8;\n                    }\n                }\n\n                if (cab instanceof Array) {\n                    /* non-leaf node */\n                    cablist = cab;\n                    continue;\n                }\n\n                switch (cab.type) {\n                case 0x01: /* string terminator */\n                    done = true;\n                    break;\n                case 0x02: /* single character */\n                case 0x04: /* single Unicode character */\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        context.buffer.push(cab.cchar);\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        context.code.push(\"self.tempcallargs[0]=\"+cab.value+\";\");\n                        context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n                        retval = true;\n                        done = true;\n                        break;\n                    }\n                    cablist = decoding_tree;\n                    break;\n                case 0x03: /* C string */\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        tmpaddr = cab.addr;\n                        while (true) {\n                            ch = Mem1(tmpaddr);\n                            if (ch == 0)\n                                break;\n                            context.buffer.push(CharToString(ch));\n                            tmpaddr++;\n                        }\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        retval = \"[\"+(cab.addr)+\", 0xE0, 0]\";\n                        done = true;\n                        break;\n                    }\n                    cablist = decoding_tree;\n                    break;\n                case 0x05: /* C Unicode string */\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        tmpaddr = cab.addr;\n                        while (true) {\n                            ch = Mem4(tmpaddr);\n                            if (ch == 0)\n                                break;\n                            context.buffer.push(CharToString(ch));\n                            tmpaddr += 4;\n                        }\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        retval = \"[\"+(cab.addr)+\", 0xE2, 0]\";\n                        done = true;\n                        break;\n                    }\n                    cablist = decoding_tree;\n                    break;\n                case 0x08:\n                case 0x09:\n                case 0x0A:\n                case 0x0B: \n                    oputil_flush_string(context);\n                    oputil_push_substring_callstub(context);\n                    /* It's not worth precomputing this type-test. We could\n                       do it for a single-indirect to a ROM address, and\n                       it'd be mostly okay if we weren't caching this\n                       JIT code. But those aren't the common cases, so\n                       let's not bother. */\n                    context.code.push(\"var otype, retval;\");\n                    context.code.push(\"var oaddr = \"+(cab.addr)+\";\");\n                    if (cab.type >= 0x09)\n                        context.code.push(\"oaddr = self.Mem4(oaddr);\");\n                    if (cab.type == 0x0B)\n                        context.code.push(\"oaddr = self.Mem4(oaddr);\");\n                    context.code.push(\"otype = self.Mem1(oaddr);\");\n                    retval = \"retval\";\n                    done = true;\n\n                    oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                    context.code.push(\"if (otype >= 0xE0 && otype <= 0xFF) {\");\n                    context.code.push(\"retval = [oaddr, 0, 0];\");\n                    context.code.push(\"}\");\n                    context.code.push(\"else if (otype >= 0xC0 && otype <= 0xDF) {\");\n                    var argc = 0;\n                    if (cab.type == 0x0A || cab.type == 0x0B) {\n                        argc = Mem4(cab.addr+4);\n                        for (var ix=0; ix<argc; ix++)\n                            context.code.push(\"self.tempcallargs[\"+ix+\"]=\"+Mem4(cab.addr+8+4*ix)+\";\");\n                    }\n                    context.code.push(\"self.enter_function(oaddr, \"+argc+\");\");\n                    context.code.push(\"retval = true;\");\n                    context.code.push(\"}\");\n                    context.code.push(\"else {\");\n                    context.code.push(\"self.fatal_error('Unknown object while decoding string indirect reference.', otype);\");\n                    context.code.push(\"}\");\n                    break;\n                default:\n                    fatal_error(\"Unknown entity in string decoding (cached).\");\n                    break;\n                }\n            }\n        }\n        else {  /* No decoding_tree available. */\n            var node, byt, nodetype;\n            var done = false;\n            \n            if (!self.stringtable)\n                fatal_error(\"Attempted to print a compressed string with no table set.\");\n            /* bitnum is already set right */\n            byt = Mem1(addr);\n            if (bitnum)\n                byt >>= bitnum;\n            node = Mem4(self.stringtable+8);\n\n            while (!done) {\n                nodetype = Mem1(node);\n                node++;\n                switch (nodetype) {\n                case 0x00: /* non-leaf node */\n                    if (byt & 1) \n                        node = Mem4(node+4);\n                    else\n                        node = Mem4(node+0);\n                    if (bitnum == 7) {\n                        bitnum = 0;\n                        addr++;\n                        byt = Mem1(addr);\n                    }\n                    else {\n                        bitnum++;\n                        byt >>= 1;\n                    }\n                    break;\n                case 0x01: /* string terminator */\n                    retval = false;\n                    done = true;\n                    break;\n                case 0x02: /* single character */\n                    ch = Mem1(node);\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        context.buffer.push(CharToString(ch));\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        context.code.push(\"self.tempcallargs[0]=\"+ch+\";\");\n                        context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n                        retval = true;\n                        done = true;\n                        break;\n                    }\n                    node = Mem4(self.stringtable+8);\n                    break;\n                case 0x04: /* single Unicode character */\n                    ch = Mem4(node);\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        context.buffer.push(CharToString(ch));\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        context.code.push(\"self.tempcallargs[0]=\"+ch+\";\");\n                        context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n                        retval = true;\n                        done = true;\n                        break;\n                    }\n                    node = Mem4(self.stringtable+8);\n                    break;\n                case 0x03: /* C string */\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        while (true) {\n                            ch = Mem1(node);\n                            if (ch == 0)\n                                break;\n                            context.buffer.push(CharToString(ch));\n                            node++;\n                        }\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        retval = \"[\"+node+\", 0xE0, 0]\";\n                        done = true;\n                        break;\n                    }\n                    node = Mem4(self.stringtable+8);\n                    break;\n                case 0x05: /* C Unicode string */\n                    switch (curiosys) {\n                    case 2: /* glk */\n                        while (true) {\n                            ch = Mem4(node);\n                            if (ch == 0)\n                                break;\n                            context.buffer.push(CharToString(ch));\n                            node += 4;\n                        }\n                        break;\n                    case 1: /* filter */\n                        oputil_flush_string(context);\n                        oputil_push_substring_callstub(context);\n                        oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                        retval = \"[\"+node+\", 0xE2, 0]\";\n                        done = true;\n                        break;\n                    }\n                    node = Mem4(self.stringtable+8);\n                    break;\n                case 0x08:\n                case 0x09:\n                case 0x0A:\n                case 0x0B: \n                    oputil_flush_string(context);\n                    oputil_push_substring_callstub(context);\n                    /* It's not worth precomputing this type-test. We could\n                       do it for a single-indirect to a ROM address, and\n                       it'd be mostly okay if we weren't caching this\n                       JIT code. But those aren't the common cases, so\n                       let's not bother. */\n                    context.code.push(\"var otype, retval;\");\n                    context.code.push(\"var oaddr = \"+Mem4(node)+\";\");\n                    if (nodetype == 0x09 || nodetype == 0x0B)\n                        context.code.push(\"oaddr = self.Mem4(oaddr);\");\n                    context.code.push(\"otype = self.Mem1(oaddr);\");\n                    retval = \"retval\";\n                    done = true;\n\n                    oputil_push_callstub(context, \"0x10,\"+bitnum, addr);\n                    context.code.push(\"if (otype >= 0xE0 && otype <= 0xFF) {\");\n                    context.code.push(\"retval = [oaddr, 0, 0];\");\n                    context.code.push(\"}\");\n                    context.code.push(\"else if (otype >= 0xC0 && otype <= 0xDF) {\");\n                    var argc = 0;\n                    if (nodetype == 0x0A || nodetype == 0x0B) {\n                        argc = Mem4(node+4);\n                        for (var ix=0; ix<argc; ix++)\n                            context.code.push(\"self.tempcallargs[\"+ix+\"]=\"+Mem4(node+8+4*ix)+\";\");\n                    }\n                    context.code.push(\"self.enter_function(oaddr, \"+argc+\");\");\n                    context.code.push(\"retval = true;\");\n                    context.code.push(\"}\");\n                    context.code.push(\"else {\");\n                    context.code.push(\"self.fatal_error('Unknown object while decoding string indirect reference.', otype);\");\n                    context.code.push(\"}\");\n                    break;\n                default:\n                    fatal_error(\"Unknown entity in string decoding.\", nodetype);\n                    break;\n                }\n            }\n        }\n    }\n    else if (type == 0xE0) {\n        var ch;\n        switch (curiosys) {\n        case 2: /* glk */\n            while (1) {\n                ch = Mem1(addr);\n                addr++;\n                if (ch == 0)\n                    break;\n                context.buffer.push(CharToString(ch));\n            }\n            break;\n        case 1: /* filter */\n            oputil_flush_string(context);\n            oputil_push_substring_callstub(context);\n            ch = Mem1(addr);\n            addr++;\n            if (ch != 0) {\n                oputil_push_callstub(context, \"0x13,0\", addr);\n                context.code.push(\"self.tempcallargs[0]=\"+ch+\";\");\n                context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n                retval = true;\n            }\n            else {\n                retval = \"false\";\n            }\n            break;\n        }\n    }\n    else if (type == 0xE2) {\n        var ch;\n        switch (curiosys) {\n        case 2: /* glk */\n            while (1) {\n                ch = Mem4(addr);\n                addr+=4;\n                if (ch == 0)\n                    break;\n                context.buffer.push(CharToString(ch));\n            }\n            break;\n        case 1: /* filter */\n            oputil_flush_string(context);\n            oputil_push_substring_callstub(context);\n            ch = Mem4(addr);\n            addr+=4;\n            if (ch != 0) {\n                oputil_push_callstub(context, \"0x14,0\", addr);\n                context.code.push(\"self.tempcallargs[0]=\"+ch+\";\");\n                context.code.push(\"self.enter_function(self.iosysrock, 1);\");\n                retval = true;\n            }\n            else {\n                retval = \"false\";\n            }\n            break;\n        }\n    }\n    else if (type >= 0xE0 && type <= 0xFF) {\n        fatal_error(\"Attempt to print unknown type of string.\");\n    }\n    else {\n        fatal_error(\"Attempt to print non-string.\");\n    }\n\n    if (!retval) {\n        /* The simple case; retval is false or undefined. Equivalent to a\n           function that prints text and returns false. */\n        ;;;if (context.code.length > 1) {\n        ;;;    fatal_error(\"Simple-case string generated code.\"); //assert\n        ;;;}\n        return context.buffer.join(\"\");\n    }\n    else {\n        oputil_flush_string(context);\n        context.code.push(\"return \" + retval + \";\");\n        return make_code(context.code.join(\"\\n\"), \"_func_str_\"+startaddr, \"nextcp\", \"substring\");\n    }\n}\n\nfunction do_gestalt(val, val2) {\n    var ix;\n\n    switch (val) {\n    case 0: /* GlulxVersion */\n        return 0x00030102; /* Glulx spec version 3.1.2 */\n\n    case 1: /* TerpVersion */\n        return 0x00020200; /* Quixe version 2.2.0 */\n\n    case 2: /* ResizeMem */\n        return 1; /* Memory resizing works. */\n\n    case 3: /* Undo */\n        return 1; /* Undo works. */\n\n    case 4: /* IOSystem */\n        switch (val2) {\n        case 0:\n            return 1; /* The \"null\" system always works. */\n        case 1:\n            return 1; /* The \"filter\" system always works. */\n        case 2:\n            return 1; /* A Glk library is hooked up. */\n        default:\n            return 0;\n        }\n        break;\n\n    case 5: /* Unicode */\n        return 1; /* We can handle Unicode. */\n\n    case 6: /* MemCopy */\n        return 1; /* We can do mcopy/mzero. */\n\n    case 7: /* MAlloc */\n        return 1; /* We can handle malloc/mfree. */\n\n    case 8: /* MAllocHeap */\n        return heap_get_start();\n\n    case 9: /* Acceleration */\n        return 1; /* The acceleration opcodes work. */\n\n    case 10: /* AccelFunc */\n        if (accel_func_map[val2])\n            return 1;\n        else\n            return 0;\n\n    case 11: /* Float */\n        return 1; /* We can handle the floating-point opcodes. */\n\n\n    default:\n        return 0;\n    }\n}\nself.do_gestalt = do_gestalt;\n\n/* This fetches a search key, and returns an array containing the key\n   (bytewise). Actually it always returns the same array.\n*/\nfunction fetch_search_key(addr, len, options) {\n    var ix;\n\n    if (options & 1) {\n        /* indirect key */\n        return MemSlice(addr, len);\n    }\n    else {\n        switch (len) {\n        case 4:\n            return [\n                (addr >> 24) & 0xFF,\n                (addr >> 16) & 0xFF,\n                (addr >> 8) & 0xFF,\n                addr & 0xFF\n            ];\n        case 2:\n            return [\n                (addr >> 8) & 0xFF,\n                addr & 0xFF\n            ];\n        case 1:\n            return [addr & 0xFF];\n        default:\n            fatal_error('Direct search key must hold one, two, or four bytes.');\n        }\n    }\n}\n\nfunction linear_search(key, keysize, start, \n    structsize, numstructs, keyoffset, options) {\n\n    var ix, count, match, bytes;\n    var retindex = ((options & 4) != 0);\n    var zeroterm = ((options & 2) != 0);\n    var keybuf = fetch_search_key(key, keysize, options);\n\n    for (count=0; count<numstructs; count++, start+=structsize) {\n        match = true;\n        bytes = MemSlice(start + keyoffset, keysize);\n        for (ix=0; match && ix<keysize; ix++) {\n            if (bytes[ix] != keybuf[ix])\n                match = false;\n        }\n\n        if (match) {\n            if (retindex)\n                return count;\n            else\n                return start;\n        }\n        \n        if (zeroterm) {\n            match = true;\n            bytes = MemSlice(start + keyoffset, keysize);\n            for (ix=0; match && ix<keysize; ix++) {\n                if (bytes[ix] != 0)\n                    match = false;\n            }\n            \n            if (match) {\n                break;\n            }\n        }\n    }\n\n    if (retindex)\n        return 0xFFFFFFFF;\n    else\n        return 0;\n}\n\nfunction binary_search(key, keysize, start, \n    structsize, numstructs, keyoffset, options) {\n\n    var top, bot, addr, val, cmp, ix;\n    var byt, byt2;\n    var retindex = ((options & 4) != 0);\n    var keybuf = fetch_search_key(key, keysize, options);\n\n    bot = 0;\n    top = numstructs;\n    while (bot < top) {\n        cmp = 0;\n        val = (top+bot) >> 1;\n        addr = start + val * structsize;\n        for (ix=0; (!cmp) && ix<keysize; ix++) {\n            byt = Mem1(addr + keyoffset + ix);\n            byt2 = keybuf[ix];\n            if (byt < byt2)\n                cmp = -1;\n            else if (byt > byt2)\n                cmp = 1;\n        }\n\n        if (!cmp) {\n            if (retindex)\n                return val;\n            else\n                return addr;\n        }\n        \n        if (cmp < 0) {\n            bot = val+1;\n        }\n        else {\n            top = val;\n        }\n    }\n\n    if (retindex)\n        return 0xFFFFFFFF;\n    else\n        return 0;\n}\n\nfunction linked_search(key, keysize, start, \n    keyoffset, nextoffset, options) {\n\n    var ix, byt, match;\n    var zeroterm = ((options & 2) != 0);\n    var keybuf = fetch_search_key(key, keysize, options);\n\n    while (start != 0) {\n        match = true;\n        for (ix=0; match && ix<keysize; ix++) {\n            byt = Mem1(start + keyoffset + ix);\n            if (byt != keybuf[ix])\n                match = false;\n        }\n\n        if (match) {\n            return start;\n        }\n        \n        if (zeroterm) {\n            match = true;\n            for (ix=0; match && ix<keysize; ix++) {\n                byt = Mem1(start + keyoffset + ix);\n                if (byt != 0)\n                    match = false;\n            }\n            \n            if (match) {\n                break;\n            }\n        }\n\n        start = Mem4(start + nextoffset);\n    }\n\n    return 0;\n}\n\nself.linear_search = linear_search;\nself.binary_search = binary_search;\nself.linked_search = linked_search;\n\n/* Convert an integer (in IEEE-754 single-precision format) into a\n   Javascript number.\n*/\nfunction decode_float(val) {\n    var sign, res, expo;\n\n    if (val & 0x80000000) {\n        sign = true;\n        val = val & 0x7fffffff;\n    }\n    else {\n        sign = false;\n    }\n\n    if (val == 0) {\n        return (sign ? -0.0 : 0.0);\n    }\n\n    if ((val & 0x7f800000) == 0x7f800000) {\n        /* Either an infinity or a NaN. */\n        if ((val & 0x7fffff) == 0) {\n            return (sign ? -Infinity : Infinity);\n        }\n        else {\n            return (sign ? -NaN : NaN);\n        }\n    }\n\n    expo = (val>>23 & 0xff);\n    /* 8388608 is 2^23, in case you're curious. */\n    if (expo) {\n        res = ((val & 0x7fffff | 0x800000) / 8388608\n            * Math.pow(2, (expo - 127)));\n    }\n    else {\n        res = ((val & 0x7fffff) / 8388608\n            * Math.pow(2, -126));\n    }\n\n    if (sign)\n        return -res;\n    else\n        return res;\n}\n\n/* Convert a Javascript number into IEEE-754 single-precision format.\n   The result will be a (non-negative) 32-bit integer.\n*/\nfunction encode_float(val) {\n    var absval, fbits;\n    var mant, expo, sign;\n\n    if (isNaN(val)) {\n        return 0x7f800001;\n    }\n    if (!isFinite(val)) {\n        if (val < 0)\n            return 0xff800000;\n        else\n            return 0x7f800000;\n    }\n    if (val == 0) {\n        /* We have to deal with zeroes separately, because you can't test\n           (-0 < 0) -- it ain't so. You have to turn the thing into an\n           infinity and test that. */\n        if (1 / val < 0)\n            return 0x80000000;\n        else\n            return 0x0;\n    }\n\n    if (val < 0) {\n        sign = true;\n        absval = -val;\n    }\n    else {\n        sign = false;\n        absval = val;\n    }\n\n    expo = Math.floor(Math.log(absval) / Math.log(2));\n    mant = absval / Math.pow(2, expo);\n\n    if (expo >= 128) {\n        /* Oops, overflow */\n        return (sign ? 0xff800000 : 0x7f800000); /* infinity */\n    }\n    else if (expo < -126) {\n        /* Denormalized (very small) number */\n        mant = mant * Math.pow(2, 126 + expo);\n        expo = 0;\n    }\n    else if (!(expo == 0 && mant == 0.0)) {\n        expo += 127;\n        mant -= 1.0; /* Get rid of leading 1 */\n    }\n\n    mant = mant * 8388608.0; /* 2^23 */\n\n    /* We want to round mant to the nearest integer. However, we bias\n       towards rounding down, in order to make Javascript's math\n       (which is double-precision) match the single-precision C code. */\n    fbits = (mant + 0.4999999999999999) << 0; \n    if (fbits >= 8388608) {\n        /* The carry propagated out of a string of 23 1 bits. */\n        fbits = 0;\n        expo++;\n        if (expo >= 255) {\n            /* Oops, overflow */\n            return (sign ? 0xff800000 : 0x7f800000); /* infinity */\n        }\n    }\n\n    if (sign)\n        return ((0x80000000) | (expo << 23) | (fbits)) >>>0;\n    else\n        return (expo << 23) | (fbits);\n}\n\nself.decode_float = decode_float;\nself.encode_float = encode_float;\n\n/* ----------------------------------------------------------------- */\n\n/* Now we declare all the VM global variables and constants.\n\n   Some of these are (private) variables; some live in the self object.\n   There's no real difference, except for the rule that JIT-compiled\n   functions cannot access private variables. I could have put all\n   of them in self, but I was lazy.\n*/\n\n/* Parameters set at init() time, including the game image and any\n   execution options. */\n\nvar game_image = null; /* the original game image, as an array of bytes */\nvar game_signature = null; /* string, containing the first 64 bytes of image */\nvar opt_log_execution_time = null;\nvar opt_rethrow_exceptions = null;\nvar opt_do_vm_autosave = null;\nvar opt_clear_vm_autosave = null;\n\n/* The VM state variables. */\n\nvar memmap; /* array of bytes */\nvar stack; /* array of StackFrames */\nself.frame = null; /* the top of the stack */\nself.vm_started = false; /* Quixe is initialized */\nself.vm_stopped = false; /* Quixe has shut down */\nself.tempcallargs = null; /* only used momentarily, for enter_function() */\nself.tempglkargs = null; /* only used momentarily, for the @glk opcode */\nself.done_executing = null; /* signals that we've quit *or* paused for interaction */\n\nvar vmfunc_table; /* maps addresses to VMFuncs */\nvar vmtextenv_table; /* maps stringtable addresses to VMTextEnvs */\n/* The following two variables point to inside the current string table.\n   They are undefined if stringtable is zero, or a non-ROM address. */\nvar decoding_tree; /* binary tree of string nodes */\nvar vmstring_table; /* maps addresses to functions or strings */\n\nself.random_func = null; /* Math.random or deterministic equivalent */\n\n/* Header constants. */\nvar ramstart;\nvar endgamefile;   // always game_image.length\nvar origendmem;\nvar stacksize;     // not used -- we allow the stack to grow as needed\nvar startfuncaddr;\nvar origstringtable;\nvar checksum;\n\n/* The VM registers. */\nself.pc = null;\nself.stringtable = null;\nself.endmem = null;        // always memmap.length\nself.protectstart = null;\nself.protectend = null;\nself.iosysmode = null;\nself.iosysrock = null;\n\n/* This is not needed for VM operation, but it may be needed for\n   autosave/autorestore. It is updated very lazily -- only when\n   beginning a blocking @glk opcode. (I.e., only when we're about\n   to autosave.) */\nself.prevpc = null;\n\nvar undostack;     // array of VM state snapshots.\nself.resumefuncop = null;\nself.resumevalue = null;\n\n/* Memory allocation heap. Blocks have \"addr\" and \"size\" properties. */\nvar heapstart;     // Start address of the heap.\nvar usedlist;      // Sorted array of used blocks.\nvar freelist;      // Sorted array of free blocks.\n\n/* Statistics -- may only be meaningful in a debug release. */\nvar total_execution_time = 0;\nvar total_function_calls = 0;\nvar accel_function_calls = 0;\nvar total_path_calls = 0;\nvar paths_cached = 0;\nvar paths_compiled = 0;\nvar strings_cached = 0;\nvar strings_compiled = 0;\n\n/* Set up all the initial VM state.\n*/\nfunction setup_vm() {\n    var val, version;\n\n    if (!game_image)\n        fatal_error(\"There is no Glulx game file loaded.\");\n\n    var Dialog = self.Glk.getlibrary('Dialog');\n    \n    self.vm_started = true;\n    self.resumefuncop = null;\n    self.resumevalue = 0;\n    memmap = null;\n    stack = [];\n    self.frame = null;\n    self.pc = 0;\n    self.prevpc = 0;\n\n    if (game_image.length < 36)\n        fatal_error(\"This is too short to be a valid Glulx file.\");\n    val = ByteRead4(game_image, 0);\n    if (val != 0x476c756c)   // 'Glul'\n        fatal_error(\"This is not a valid Glulx file.\");\n    \n    /* We support version 2.0 through 3.1.*. */\n    version = ByteRead4(game_image, 4);\n    if (version < 0x20000) \n        fatal_error(\"This Glulx file is too old a version to execute.\");\n    if (version >= 0x30200) \n        fatal_error(\"This Glulx file is too new a version to execute.\");\n\n    ramstart = ByteRead4(game_image, 8);\n    endgamefile = ByteRead4(game_image, 12);\n    origendmem = ByteRead4(game_image, 16);\n    stacksize = ByteRead4(game_image, 20);\n    startfuncaddr = ByteRead4(game_image, 24);\n    origstringtable = ByteRead4(game_image, 28);\n    checksum = ByteRead4(game_image, 32);\n\n    /* Set the protection range to (0, 0), meaning \"off\". */\n    self.protectstart = 0;\n    self.protectend = 0;\n\n    if (ramstart < 0x100 \n        || endgamefile < ramstart \n        || origendmem < endgamefile) \n        fatal_error(\"The segment boundaries in the header are in an impossible order.\");\n\n    if (endgamefile != game_image.length)\n        fatal_error(\"The game file length does not agree with the header.\");\n\n    self.done_executing = false;\n    vmfunc_table = {};\n    vmtextenv_table = {};\n    decoding_tree = undefined;\n    vmstring_table = undefined;\n    self.tempcallargs = Array(8);\n    self.tempglkargs = Array(8);\n    set_random(0);\n\n    self.endmem = origendmem;\n    self.stringtable = 0;\n\n    undostack = [];\n\n    heapstart = 0;\n    usedlist = [];\n    freelist = [];\n\n    if (opt_clear_vm_autosave) {\n        Dialog.autosave_write(game_signature, null);\n    }\n    if (opt_do_vm_autosave && !opt_clear_vm_autosave) {\n        try {\n            var snapshot = Dialog.autosave_read(game_signature);\n            if (snapshot) {\n                qlog('Found autosave...');\n                vm_autorestore(snapshot);\n                return;\n            }\n        }\n        catch (ex) {\n            qlog('Autorestore failed, deleting it: ' + show_exception(ex));\n            if (ex.stack)\n                qlog('JS stack dump C:\\n' + ex.stack);\n            Dialog.autosave_write(game_signature, null);\n        }\n    }\n    \n    vm_restart();\n}\n\n/* Put the VM into a state where it's ready to begin executing the\n   game. This is called both at startup time, and when the machine\n   performs a \"restart\" opcode. \n*/\nfunction vm_restart() {\n    var ix;\n\n    /* Deactivate the heap (if it was active). */\n    heap_clear();\n\n    var protect = copy_protected_range();\n\n    /* Build (or rebuild) main memory array. */\n    memmap = null; // garbage-collect old memmap\n    memmap = game_image.slice(0, endgamefile);\n    self.endmem = memmap.length;\n    change_memsize(origendmem, false);\n    /* endmem is now origendmem */\n\n    paste_protected_range(protect);\n\n    stack = [];\n    self.frame = null;\n    self.pc = 0;\n    self.prevpc = 0;\n    self.iosysmode = 0;\n    self.iosysrock = 0;\n    set_string_table(origstringtable);\n\n    /* Note that we do not reset the protection range. */\n    \n    /* Push the first function call. (No arguments.) */\n    enter_function(startfuncaddr, 0);\n    \n    /* We're now ready to execute. */\n}\nself.vm_restart = vm_restart;\n\n/* Run-length-encode an array, for Quetzal. */\nfunction compress_bytes(arr) {\n    var result = [];\n    var i = 0;\n    while (i < arr.length) {\n        var zeroes = 0;\n        while (i < arr.length && arr[i] == 0 && zeroes <= 255) {\n            zeroes++;\n            i++;\n        }\n        if (zeroes > 0) {\n            result.push(0);\n            result.push(zeroes - 1);\n        }\n        while (i < arr.length && arr[i] != 0) {\n            result.push(arr[i]);\n            i++;\n        }\n    }\n    //qlog(\"Compressed \" + arr.length + \" bytes to \" + result.length);\n    return result;\n}\n\n/* Run-length-decode an array, for Quetzal. */\nfunction decompress_bytes(arr) {\n    var result = [];\n    var i = 0;\n    while (i < arr.length) {\n        var b = arr[i++];\n        if (b == 0) {\n            var count = arr[i++] + 1;\n            for (var j = 0; j < count; j++) {\n                result.push(0);\n            }\n        } else {\n            result.push(b);\n        }\n    }\n    //qlog(\"Decompressed \" + arr.length + \" bytes to \" + result.length);\n    return result;\n}\n\n/* Pack an array of { key:ID, chunk:bytes } into a single byte array.\n   The ID should be a 4-character string.\n*/\nfunction pack_iff_chunks(chunks) {\n    var bytes = [];\n    for (var ix = 0; ix < chunks.length; ix++) {\n        var key = chunks[ix].key;\n        var chunk = chunks[ix].chunk;\n        if (key.length != 4) {\n            fatal_error(\"Bad chunk ID (must be exactly 4 chars): \" + key);\n        }\n        if (chunk == undefined) {\n            fatal_error(\"Missing chunk data: \" + key);\n        }\n        //qlog(\"Writing \" + key + \" (\" + chunk.length + \" bytes)\");\n        BytePushString(bytes, key);\n        BytePush4(bytes, chunk.length);\n        bytes = bytes.concat(chunk);\n        /* Align to even length... */\n        if (bytes.length & 1)\n            bytes.push(0);\n    }\n    return bytes;\n}\n\n/* Unpack a byte array into an { ID -> bytes } map, or undefined on error.\n   The order of chunks is not preserved.\n*/\nfunction unpack_iff_chunks(bytes) {\n    var chunks = {};\n    var pos = 0;\n    while (pos < bytes.length) {\n        if ((pos + 8) > bytes.length) {\n          qlog(\"IFF chunk header is truncated\");\n          return undefined;\n        }\n        var key = ByteReadString(bytes, pos, 4);\n        var size = ByteRead4(bytes, pos + 4);\n        pos += 8;\n\n        if ((pos + size) > bytes.length) {\n          qlog(key + \" chunk is truncated \" +\n                \"(\" + size + \" bytes needed, \" + (bytes.length - pos) + \" available\");\n          return undefined;\n        }\n        chunks[key] = bytes.slice(pos, pos + size);\n        pos += size;\n        /* Align to even length... */\n        if (pos & 1)\n            pos += 1;\n        //qlog(\"Reading \" + key + \" (\" + size + \" bytes)\");\n    }\n    return chunks;\n}\n\n/* Writes a snapshot of the VM state to the given Glk stream. Returns true\n   on success. \n*/\nfunction vm_save(streamid) {\n    ;;;if (memmap.length != self.endmem) {\n    ;;;    fatal_error(\"Memory length was incorrect before save.\"); //assert\n    ;;;}\n\n    if (self.iosysmode != 2)\n        fatal_error(\"Streams are only available in Glk I/O system.\");\n\n    var str = self.GiDispa.class_obj_from_id('stream', streamid);\n    if (!str)\n        return false;\n    \n    var chunks = [];\n    \n    chunks.push({ key:\"IFhd\", chunk:game_image.slice(0, 128) });\n    \n    var cmem = memmap.slice(ramstart);\n    for (var i = ramstart; i < game_image.length; i++) {\n        cmem[i - ramstart] ^= game_image[i];\n    }\n    cmem = compress_bytes(cmem);\n    cmem.splice(0, 0, 0,0,0,0); // prepend four zeroes\n    // Write in the endmem value\n    ByteWrite4(cmem, 0, self.endmem);\n    chunks.push({key:\"CMem\", chunk:cmem});\n    \n    var stkschunk = [];\n    chunks.push({ key:\"Stks\", chunk:stkschunk });\n    for (var i = 0; i < stack.length; i++) {\n        push_serialized_stackframe(stack[i], stkschunk);\n    }\n\n    if (heap_is_active()) {\n        var mallchunk = [];\n        chunks.push({ key:\"MAll\", chunk:mallchunk });\n        BytePush4(mallchunk, heapstart);\n        BytePush4(mallchunk, usedlist.length);\n        for (var i = 0; i < usedlist.length; i++) {\n            BytePush4(mallchunk, usedlist[i].addr);\n            BytePush4(mallchunk, usedlist[i].size);\n        }\n    }\n\n    var payload_bytes = []\n    BytePushString(payload_bytes, \"IFZS\");\n    payload_bytes = payload_bytes.concat(pack_iff_chunks(chunks));\n    \n    var quetzal = pack_iff_chunks([{ key:\"FORM\", chunk:payload_bytes }])\n    //qlog(\"vm_save: writing \" + quetzal.length + \" bytes\");    \n    self.Glk.glk_put_buffer_stream(str, quetzal);\n    return true;\n}\n\n/* Reads a VM state snapshot from the given Glk stream and restores it.\n   Returns true on success.\n*/\nfunction vm_restore(streamid) {\n    if (self.iosysmode != 2)\n        fatal_error(\"Streams are only available in Glk I/O system.\");\n\n    var str = self.GiDispa.class_obj_from_id('stream', streamid);\n    if (!str)\n        return false;\n    \n    var quetzal = new Array(0);\n    var buffer = new Array(1024);\n    var count = 1;\n    while (count > 0) {\n        count = self.Glk.glk_get_buffer_stream(str, buffer);\n        quetzal = quetzal.concat(buffer.slice(0, count));\n    }\n    //qlog(\"vm_restore: reading \" + quetzal.length + \" bytes\");\n    \n    quetzal = unpack_iff_chunks(quetzal);\n    if (!quetzal) {\n        qlog(\"vm_restore failed: file is not Quetzal\");\n        return false;\n    }\n    quetzal = quetzal[\"FORM\"];\n    if (!quetzal || ByteReadString(quetzal, 0, 4) != \"IFZS\") {\n        qlog(\"vm_restore failed: file doesn't start with FORM/IFZS header\");\n        return false;\n    }\n    var chunks = unpack_iff_chunks(quetzal.slice(4));\n\n    // Unpack the chunks map into the VM state. (This is destructive to\n    // the contents of chunks.)\n    \n    if (!chunks[\"IFhd\"]) {\n        qlog(\"vm_restore failed: missing required IFhd chunk\");\n        return false;\n    }\n    for (var i = 0; i < 128; i++) {\n        if (chunks[\"IFhd\"][i] != game_image[i]) {\n            qlog(\"vm_restore failed: this save image is for a different game\");\n            return false;\n        }\n    }    \n    if (!chunks[\"CMem\"]) {\n        qlog(\"vm_restore failed: missing required CMem chunk\");\n        return false;\n    }\n    if (!chunks[\"Stks\"]) {\n        qlog(\"vm_restore failed: missing required Stks chunk\");\n        return false;\n    }\n    \n    // The point of no return.\n    var protect = copy_protected_range();\n    heap_clear();\n    \n    var newendmem = ByteRead4(chunks[\"CMem\"], 0);\n    var ram_xor = chunks[\"CMem\"].slice(4);\n    ram_xor = decompress_bytes(ram_xor);\n    // The trailing zeroes may have been snipped; add them in.\n    while (ram_xor.length < newendmem - ramstart)\n        ram_xor.push(0);\n    change_memsize(newendmem, false);\n    memmap = game_image.slice(0, ramstart).concat(ram_xor);\n    for (var i = ramstart; i < game_image.length; i++) {\n        memmap[i] ^= game_image[i];\n    }\n\n    ;;;if (memmap.length != self.endmem) {\n    ;;;    fatal_error(\"Memory length was incorrect after restore.\"); //assert\n    ;;;}\n\n    var stackchunk = chunks[\"Stks\"];\n    stack = [];\n    while (stackchunk.length) {\n        self.frame = pop_deserialized_stackframe(stackchunk);\n        if (!self.frame) {\n            fatal_error(\"vm_restore failed: bad stack frame\");\n        }\n        stack.unshift(self.frame);\n    }\n    for (var i = 0; i < stack.length; i++) {\n        stack[i].depth = i;\n    }\n    self.frame = stack[stack.length - 1];\n\n    var heapchunk = chunks[\"MAll\"];\n    if (heapchunk && heapchunk.length >= 8) {\n        heapstart = ByteRead4(heapchunk, 0);\n        var numblocks = ByteRead4(heapchunk, 4);\n\n        for (var i = 0; i < numblocks; i++) {\n            var addr = ByteRead4(heapchunk, 8 + 8*i);\n            var size = ByteRead4(heapchunk, 12 + 8*i);\n            usedlist.push(new HeapBlock(addr, size));\n        }\n\n        // This list may be out-of-order. Sort it by address.\n        usedlist.sort(function(blk1, blk2) {return blk1.addr - blk2.addr;});\n\n        // Create freelist blocks to fill in the gaps.\n        var heapend = heapstart;\n        for (var i = 0; i < usedlist.length; i++) {\n            var addr = usedlist[i].addr;\n            var size = usedlist[i].size;\n            if (addr < heapend || (addr + size) > self.endmem) {\n                fatal_error(\"vm_restore failed: corrupt dynamic heap\");\n            }\n            if (addr > heapend) {\n                freelist.push(new HeapBlock(heapend, addr - heapend));\n            }\n            heapend = addr + size;\n        }\n        if (heapend < self.endmem) {\n            freelist.push(new HeapBlock(heapend, self.endmem - heapend));\n        }\n    }\n\n    ;;;assert_heap_valid(); //assert\n    \n    paste_protected_range(protect);\n    return true;\n}\n\n/* Writes a snapshot of the VM state to a special file (not represented\n   by a fileref -- that's how special it is). The eventaddr is the\n   VM address of the event structure; we'll need it to autorestore\n   properly.\n\n   This looks a lot like vm_save, but we serialize a little differently.\n   We're creating a JSONable object.\n*/\nfunction vm_autosave(eventaddr) {\n    var Dialog = self.Glk.getlibrary('Dialog');\n    \n    if (eventaddr < 0) {\n        /* Delete the autosave. */\n        //qlog('### deleting autosave');\n        Dialog.autosave_write(game_signature, null);\n        return;\n    }\n\n    //var timestart = new Date().getTime(); //###stats\n\n    var opmodes = parse_partial_operand();\n    if (!opmodes)\n        return;\n\n    var snapshot = {};\n\n    /* When the save file is autorestored, the VM will restart the @glk\n       opcode. That means that the Glk argument (the event structure\n       address) must be waiting on the stack. Possibly also the @glk\n       opcode's operands -- these might or might not have come off the\n       stack. */\n\n    var valstack = self.frame.valstack;\n    var origstacklen = valstack.length;\n    /* The event structure address: */\n    valstack.push(eventaddr);\n    if (opmodes.argsop == 8) {\n        /* The number of Glk arguments (1): */\n        valstack.push(1);\n    }\n    if (opmodes.selop == 8) {\n        /* The Glk call selector (0x00C0): */\n        valstack.push(0x00C0);\n    }\n\n    /* Push a temporary callstub which contains the *last* PC -- the address\n       of the @glk(select) invocation. */\n    valstack.push(0, 0, self.prevpc, self.frame.framestart);\n\n    /* Save the RAM, stack, and heap. */\n\n    snapshot.ram = memmap.slice(ramstart);\n    snapshot.endmem = self.endmem;\n    snapshot.pc = self.pc;\n    snapshot.stack = [];\n    for (var i = 0; i < stack.length; i++) {\n        push_serialized_stackframe(stack[i], snapshot.stack);\n    }\n\n    if (heap_is_active()) {\n        snapshot.heapstart = heapstart;\n        snapshot.usedlist = [];\n        for (var i = 0; i < usedlist.length; i++) {\n            snapshot.usedlist.push(usedlist[i].addr);\n            snapshot.usedlist.push(usedlist[i].size);\n        }\n    }\n\n    /* Pop off the temporary stack stuff. */\n    valstack.length = origstacklen;\n\n    /* Save miscellaneous VM things which are not part of a standard\n       save state. */\n    snapshot.stringtable = self.stringtable;\n    snapshot.iosysmode = self.iosysmode;\n    snapshot.iosysrock = self.iosysrock;\n    snapshot.protectstart = self.protectstart;\n    snapshot.protectend = self.protectend;\n    if (self.random_func == srand_get_random && srand_table) {\n        snapshot.srand_table = srand_table.slice(0);\n        snapshot.srand_index1 = srand_index1;\n        snapshot.srand_index2 = srand_index2;\n    }\n    snapshot.accel_params = accel_params.slice(0);\n    snapshot.accel_funcnum_map = {};\n    for (var ix in accel_funcnum_map)\n        snapshot.accel_funcnum_map[ix] = accel_funcnum_map[ix];\n\n    /* Tell the Glk API layer to save its own state and pass it back\n       to us. (This includes the glui32-to-Glk-ID table.) */\n    snapshot.glk = self.Glk.save_allstate();\n\n    /* Write the snapshot into an appropriate location, which depends\n       on the game signature. */\n    Dialog.autosave_write(game_signature, snapshot);\n\n    //var timeend = new Date().getTime(); //###stats\n    //qlog(\"### autosave complete; time = \" + (timeend-timestart) + \" ms\");\n}\n\n/* Load a snapshot of the VM state back in. This is called at the end of\n   vm_setup, replacing the vm_restart call.\n*/\nfunction vm_autorestore(snapshot) {\n\n    memmap = game_image.slice(0, endgamefile);\n    memmap = memmap.slice(0, ramstart).concat(snapshot.ram);\n    self.endmem = snapshot.endmem;\n    self.pc = snapshot.pc;\n\n    stack = [];\n\n    var stackchunk = snapshot.stack.slice(0);\n    while (stackchunk.length) {\n        var frm = pop_deserialized_stackframe(stackchunk);\n        if (!frm) {\n            fatal_error(\"vm_autorestore failed: bad stack frame\");\n        }\n        stack.unshift(frm);\n    }\n    for (var i = 0; i < stack.length; i++) {\n        stack[i].depth = i;\n    }\n    self.frame = stack[stack.length - 1];\n\n    if (snapshot.heapstart === undefined) {\n        heapstart = 0;\n        usedlist = [];\n        freelist = [];\n    }\n    else {\n        heapstart = snapshot.heapstart;\n\n        usedlist = [];\n        for (var ix = 0; ix < snapshot.usedlist.length; ix += 2) {\n            var addr = snapshot.usedlist[ix];\n            var size = snapshot.usedlist[ix+1];\n            usedlist.push(new HeapBlock(addr, size));\n        }\n\n        // This list may be out-of-order. Sort it by address.\n        usedlist.sort(function(blk1, blk2) {return blk1.addr - blk2.addr;});\n\n        // Create freelist blocks to fill in the gaps.\n        freelist = [];\n        var heapend = heapstart;\n        for (var i = 0; i < usedlist.length; i++) {\n            var addr = usedlist[i].addr;\n            var size = usedlist[i].size;\n            if (addr < heapend || (addr + size) > self.endmem) {\n                fatal_error(\"vm_autorestore failed: corrupt dynamic heap\");\n            }\n            if (addr > heapend) {\n                freelist.push(new HeapBlock(heapend, addr - heapend));\n            }\n            heapend = addr + size;\n        }\n        if (heapend < self.endmem) {\n            freelist.push(new HeapBlock(heapend, self.endmem - heapend));\n        }\n    }\n\n    ;;;assert_heap_valid(); //assert\n\n    /* Restore miscellaneous VM things which are not part of a standard\n       save state. */\n    set_string_table(snapshot.stringtable);\n    set_iosys(snapshot.iosysmode, snapshot.iosysrock);\n    self.protectstart = snapshot.protectstart;\n    self.protectend = snapshot.protectend;\n\n    if (snapshot.srand_table === undefined) {\n        set_random(0);\n    }\n    else {\n        set_random(1);\n        srand_table = snapshot.srand_table.slice(0);\n        srand_index1 = snapshot.srand_index1;\n        srand_index2 = snapshot.srand_index2;\n    }\n\n    accel_params = snapshot.accel_params.slice(0);\n    for (var ix in snapshot.accel_funcnum_map) {\n        accel_funcnum_map[ix] = snapshot.accel_funcnum_map[ix];\n        accel_address_map[ix] = self.accel_func_map[accel_funcnum_map[ix]];\n    }\n\n    /* Restore Glk API information. */\n    self.Glk.restore_allstate(snapshot.glk);\n\n    /* Pop the callstub, restoring the PC to the @glk opcode (prevpc). */\n    pop_callstub(0);\n}\n\n/* Pushes a snapshot of the VM state onto the undo stack. If there are too\n   many on the stack, throw away the oldest.\n*/\nfunction vm_saveundo() {\n    ;;;if (memmap.length != self.endmem) {\n    ;;;    fatal_error(\"Memory length was incorrect before saveundo.\"); //assert\n    ;;;}\n\n    var snapshot = {};\n    snapshot.ram = memmap.slice(ramstart);\n    snapshot.endmem = self.endmem;\n    snapshot.pc = self.pc;\n    snapshot.stack = [];\n    for (var i = 0; i < stack.length; i++) {\n        snapshot.stack[i] = clone_stackframe(stack[i]);\n    }\n\n    snapshot.heapstart = heapstart;\n    snapshot.usedlist = usedlist.slice(0);\n    snapshot.freelist = freelist.slice(0);\n\n    undostack.push(snapshot);\n    if (undostack.length > 10) {\n        undostack.shift();\n    }\n}\n\n/* Pops a VM state snapshot from the undo stack (if possible) and restores it.\n   Returns true on success.\n*/\nfunction vm_restoreundo() {\n    if (undostack.length == 0) {\n        return false;\n    }\n    var snapshot = undostack.pop();\n    var protect = copy_protected_range();\n\n    memmap = memmap.slice(0, ramstart).concat(snapshot.ram);\n    self.endmem = snapshot.endmem;\n    stack = snapshot.stack;\n    self.frame = stack[stack.length - 1];\n    self.pc = snapshot.pc;\n\n    heapstart = snapshot.heapstart;\n    usedlist = snapshot.usedlist;\n    freelist = snapshot.freelist;\n    \n    paste_protected_range(protect);\n\n    ;;;if (memmap.length != self.endmem) {\n    ;;;    fatal_error(\"Memory length was incorrect after undo.\"); //assert\n    ;;;}\n    ;;;assert_heap_valid(); //assert\n\n    return true;\n}\n\nself.vm_save = vm_save;\nself.vm_restore = vm_restore;\nself.vm_saveundo = vm_saveundo;\nself.vm_restoreundo = vm_restoreundo;\n\n/* Change the size of the memory map. The internal flag should be true \n   only when the heap-allocation system is calling.\n*/\nfunction change_memsize(newlen, internal) {\n    var lx;\n\n    if (newlen == self.endmem)\n        return;\n\n    if ((!internal) && heap_is_active())\n        fatal_error(\"Cannot resize Glulx memory space while heap is active.\");\n    if (newlen < origendmem)\n        fatal_error(\"Cannot resize Glulx memory space smaller than it started.\");\n    if (newlen & 0xFF)\n        fatal_error(\"Can only resize Glulx memory space to a 256-byte boundary.\");\n\n    memmap.length = newlen;\n    if (newlen > self.endmem) {\n        for (lx=self.endmem; lx<newlen; lx++) {\n            memmap[lx] = 0;\n        }\n    }\n\n    self.endmem = newlen;    \n}\nself.change_memsize = change_memsize;\n\n/* Return an object which represents the protected-memory range and its\n   contents. This can later be pasted back into the VM. If there is no\n   protection range, this returns null.\n\n   The idea is that you call this before a restore/restart operation, and\n   then call paste_protected_range() afterwards.\n*/\nfunction copy_protected_range() {\n    if (self.protectstart >= self.protectend)\n        return null;\n\n    var len = self.protectend - self.protectstart;\n    var obj = {\n        start: self.protectstart,\n        end: self.protectend,\n        len: len\n    };\n    var arr = memmap.slice(self.protectstart, self.protectend);\n\n    /* It is legal to protect a range that falls outside of memory; the\n       extra bits are presumed to be zero. */\n    while (arr.length < len)\n        arr.push(0);\n    obj.mem = arr;\n\n    return obj;\n}\n\n/* Paste a protected-memory range into the VM. \n*/\nfunction paste_protected_range(obj) {\n    if (!obj)\n        return;\n\n    var ix, addr;\n    var arr = obj.mem;\n    var start = obj.start;\n    var end = obj.end;\n    if (end > self.endmem)\n        end = self.endmem;\n\n    for (ix=0, addr=start; addr<end; ix++, addr++) {\n        memmap[addr] = arr[ix];\n    }\n}\n\n/* The checksum check. */\nfunction perform_verify() {\n    var imagelen = game_image.length;\n    var ix, newsum, checksum;\n\n    if (imagelen < 0x100 || (imagelen & 0xFF) != 0)\n        return 1;\n    if (imagelen != ByteRead4(game_image, 12))\n        return 1;\n\n    checksum = ByteRead4(game_image, 32);\n    /* Allow for the fact that the checksum is computed with the checksum\n       field zeroed. */\n    newsum = (-checksum) >>>0;\n\n    for (ix=0; ix<imagelen; ix+=4) {\n        newsum = (newsum + ByteRead4(game_image, ix)) >>>0;\n    }\n\n    if (newsum != checksum)\n        return 1;\n\n    return 0;\n}\nself.perform_verify = perform_verify;\n\n/* Return the game image signature. This is used as a fingerprint on save\n   files, to ensure that you can't save in one game and restore in a \n   different one.\n*/\nfunction quixe_get_signature() {\n    return game_signature;\n}\n\n/* Return the internal self object. This gives the caller access to\n   the entire VM state, including memory. So use it wisely.\n*/\nfunction quixe_get_vm_self() {\n    return self;\n}\n\n/* Return whatever information seems useful about execution so far.\n   This is not meant to be super-efficient; it does some counting\n   every time you call it.\n*/\nfunction quixe_get_statistics() {\n    var stat = {\n        game_image_length: game_image.length,\n        total_execution_time: total_execution_time,\n        total_function_calls: total_function_calls,\n        accel_function_calls : accel_function_calls,\n        total_path_calls: total_path_calls,\n        paths_cached: paths_cached,\n        paths_compiled: paths_compiled,\n        strings_cached: strings_cached,\n        strings_compiled: strings_compiled\n    };\n\n    return stat;\n}\n\n/* Heap functions. */\n\nfunction heap_clear() {\n    heapstart = 0;\n    usedlist = [];\n    freelist = [];\n}\n\nfunction heap_is_active() {\n    return (usedlist.length > 0);\n}\n\nfunction heap_get_start() {\n    return heapstart;\n}\n\n/* Constructor: HeapBlock\n\n   We never modify heap blocks, to ensure they can be reused safely across\n   saveundo() and restore().\n*/\nfunction HeapBlock(addr, size) {\n    this.addr = addr;\n    this.size = size;\n    this.end = addr + size;\n}\n\n/* Search list of HeapBlock objects for the given address.\n   If the exact address isn't found, return index of next highest address.\n*/\nfunction heap_binary_search(list, addr) {\n    var low = 0;\n    var high = list.length;\n    while (low < high) {\n        var mid = (low + high) >> 1;\n        if (list[mid].addr < addr) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nfunction heap_malloc(size) {\n    if (!heap_is_active()) {\n        heapstart = self.endmem;\n    }\n    \n    for (var i = 0, max = freelist.length; i < max; i++) {\n        var freeblock = freelist[i];\n        if (freeblock.size >= size) {\n            // Free block is big enough. Off with its head.\n            if (freeblock.size > size) {\n                freelist[i] = new HeapBlock(freeblock.addr + size, freeblock.size - size);\n            } else {\n                freelist.splice(i, 1);\n            }\n            var pos = heap_binary_search(usedlist, freeblock.addr);\n            usedlist.splice(pos, 0, new HeapBlock(freeblock.addr, size));\n            return freeblock.addr;\n        }\n    }\n\n    // No free block is big enough. Grow the heap.\n    var addr = self.endmem;\n    var rounded_up_size = ((size + 0xFF) & 0xFFFFFF00);\n    change_memsize(self.endmem + rounded_up_size, true);\n    if (rounded_up_size > size) {\n        freelist.push(new HeapBlock(addr + size, rounded_up_size - size));\n    }\n    usedlist.push(new HeapBlock(addr, size));\n    return addr;\n}\nself.heap_malloc = heap_malloc;\n\nfunction heap_free(addr) {\n    var pos = heap_binary_search(usedlist, addr);\n    var block = usedlist[pos];\n    if (!block || block.addr != addr) {\n        fatal_error(\"Tried to free non-existent block\");\n    }\n    usedlist.splice(pos, 1);\n    \n    if (usedlist.length == 0) {\n        // No allocated blocks left. Blow away the whole heap.\n        change_memsize(heapstart, true);\n        heap_clear();\n        return;\n    }\n\n    // Find the correct position to insert this block into the freelist.\n    pos = heap_binary_search(freelist, addr);\n\n    // If the next block is free, merge with it.\n    var next = freelist[pos];\n    if (next && next.addr == block.end) {\n        block = new HeapBlock(addr, block.size + next.size);\n        freelist.splice(pos, 1);\n    }\n    \n    // If the previous block is free, merge with it.\n    var prev = freelist[pos - 1];\n    if (prev && prev.end == block.addr) {\n        block = new HeapBlock(prev.addr, prev.size + block.size);\n        freelist.splice(pos - 1, 1);\n        pos -= 1;\n    }\n    \n    freelist.splice(pos, 0, block);\n}\nself.heap_free = heap_free;\n\n/* Check that the heap state is consistent. This is slow, so we only\n   call it in debug assertions.\n*/\nfunction assert_heap_valid() {\n    //qlog(\"### heap check: heapstart \" + heapstart + \", \" + usedlist.length + \" used, \" + freelist.length + \" free\");\n    if (!heap_is_active()) {\n        if (heapstart != 0)\n            fatal_error(\"Heap inconsistency: heapstart nonzero\");\n\n        if (usedlist.length > 0)\n            fatal_error(\"Heap inconsistency: usedlist nonempty\");\n\n        if (freelist.length > 0)\n            fatal_error(\"Heap inconsistency: usedlist nonempty\");\n\n        return;\n    }\n\n    if (heapstart == 0)\n        fatal_error(\"Heap inconsistency: heapstart is zero\");\n\n    var addr = heapstart;\n    var upos = 0, fpos = 0;\n    while (upos < usedlist.length || fpos < freelist.length) {\n        var u = usedlist[upos];\n        var f = freelist[fpos];\n        if (u && u.addr == addr) {\n            //qlog(\"###...\"+u.addr+\" (\"+u.size+\" alloc)\");\n            addr += u.size;\n            upos++;\n        } else if (f && f.addr == addr) {\n            //qlog(\"###...\"+f.addr+\" (\"+f.size+\" free)\");\n            addr += f.size;\n            fpos++;\n        } else {\n            fatal_error(\"Heap inconsistency: no block at address \" + addr);\n        }\n    }\n    \n    if (addr != self.endmem)\n        fatal_error(\"Heap inconsistency: overrun at end of heap\");\n}\nself.assert_heap_valid = assert_heap_valid;\n\nvar debuginfo = {\n    map: {},\n    functions: [],\n    functionmap: {}\n};\n\nfunction quixe_get_debuginfo() {\n    return debuginfo;\n}\n\nfunction parse_inform_debug_data() {\n    if (!self.GiLoad)\n        return;\n    var buf = self.GiLoad.get_debug_info();\n    if (!buf)\n        return;\n    var done;\n    var pos, oldpos;\n    \n    if (!(buf[0] == 0xDE && buf[1] == 0xBF && buf[2] == 0 && buf[3] == 0)) {\n        qlog(\"Dbug chunk did not contain an (old-style) Inform gameinfo.dbg file\");\n        return;\n    }\n    \n    var informversion = (buf[4]<<8) | (buf[5]);\n    pos = 6;\n    done = false;\n\n    while (!done) {\n        var rectype = buf[pos++];\n\n        switch (rectype) {\n            case 0:\n            case undefined:\n                done = true;\n                break;\n\n            case 1: /* file */\n                var filenum = buf[pos++];\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var includename = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var filename = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 2: /* class */\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var classname = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                var linestart = buf.slice(pos, pos+4);\n                pos += 4;\n                var lineend = buf.slice(pos, pos+4);\n                pos += 4;\n                break;\n\n            case 3: /* object */\n                var objnum = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var objname = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                var linestart = buf.slice(pos, pos+4);\n                pos += 4;\n                var lineend = buf.slice(pos, pos+4);\n                pos += 4;\n                break;\n\n            case 4: /* global */\n                var num = (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 5: /* attribute */\n                var num = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 6: /* property */\n                var num = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 7: /* fake action */\n                var num = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 8: /* action */\n                var num = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 9: /* header */\n                pos += 64;\n                break;\n\n            case 10: /* sequence point */\n                var funcnum = (buf[pos++]<<8) | (buf[pos++]);\n                var seqcount = (buf[pos++]<<8) | (buf[pos++]);\n                pos += seqcount * 6;\n                break;\n\n            case 11: /* function */\n                var funcnum = (buf[pos++]<<8) | (buf[pos++]);\n                var line = buf.slice(pos, pos+4);\n                pos += 4;\n                var funcaddr = (buf[pos++]<<16) | (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var funcname = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                var locals = [];\n                while (buf[pos]) {\n                    oldpos = pos; while (buf[pos]) { pos++ };\n                    var locname = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                    pos++;\n                    locals.push(locname);\n                }\n                pos++;\n                debuginfo.functions.push({ \n                    num:funcnum, name:funcname, addr:funcaddr,\n                    locals:locals });\n                break;\n\n            case 12: /* array */\n                var arrayaddr = (buf[pos++]<<8) | (buf[pos++]);\n                oldpos = pos; while (buf[pos]) { pos++ };\n                var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                pos++;\n                break;\n\n            case 13: /* map */\n                while (buf[pos]) {\n                    oldpos = pos; while (buf[pos]) { pos++ };\n                    var name = String.fromCharCode.apply(this, buf.slice(oldpos, pos));\n                    pos++;\n                    var addr = (buf[pos++]<<16) | (buf[pos++]<<8) | (buf[pos++]);\n                    debuginfo.map[name] = addr;\n                }\n                pos++;\n                break;\n\n            case 14: /* function end */\n                var funcnum = (buf[pos++]<<8) | (buf[pos++]);\n                var line = buf.slice(pos, pos+4);\n                pos += 4;\n                var endaddr = (buf[pos++]<<16) | (buf[pos++]<<8) | (buf[pos++]);\n                break;                \n\n            default:\n                qlog(\"Unknown record type in debug data: \" + rectype);\n                done = true;\n                break;\n        }\n    }\n\n    var funcbase = debuginfo.map[\"code area\"];\n    if (funcbase) {\n        var ix;\n        for (ix=0; ix<debuginfo.functions.length; ix++) {\n            var func = debuginfo.functions[ix];\n            debuginfo.functionmap[funcbase+func.addr] = func;\n        }\n    }\n}\n\n/* Dummy value, returned by path functions on @quit or when leave_function()\n   pops the top-level stack frame. */\nself.VMStopped = { dummy: 'The top-level function has returned.' };\n\n/* Begin executing code, compiling as necessary. When glk_select is invoked,\n   or the game ends, this calls self.Glk.update() and exits.\n*/\nfunction execute_loop() {\n    var vmfunc, pathtab, path;\n    var pathstart, pathend;\n\n    if (self.resumefuncop) {\n        //qlog(\"### at resume time, storing value \" + self.resumevalue + \" at funcop \" + self.resumefuncop.key);\n        store_operand_by_funcop(self.resumefuncop, self.resumevalue);\n        self.resumefuncop = null;\n        self.resumevalue = 0;\n    }\n\n    pathstart = new Date().getTime(); //###stats\n\n    while (!self.done_executing) {\n        //qlog(\"### pc now \" + self.pc.toString(16));\n        vmfunc = self.frame.vmfunc;\n        pathtab = vmfunc[self.iosysmode];\n        path = pathtab[self.pc];\n        if (path === undefined) {\n            vmfunc.pathaddrs[self.pc] = true;\n            path = compile_path(vmfunc, self.pc, self.iosysmode);\n            paths_compiled++; //###stats\n            if (self.pc < ramstart) {\n                pathtab[self.pc] = path;\n                paths_cached++; //###stats\n            }\n        }\n        total_path_calls++; //###stats\n        var res = path(self);\n        if (res === self.VMStopped) {\n            self.done_executing = true;\n            self.vm_stopped = true;\n        }\n    }\n\n    pathend = new Date().getTime(); //###stats\n    total_execution_time += (pathend-pathstart) / 1000.0; //###stats\n\n    if (self.vm_stopped) {\n        /* If the library resumes us after exiting, we'll call glk_exit()\n           again. That's the library's problem. */\n        self.Glk.glk_exit();\n    }\n\n    self.Glk.update();\n\n    if (opt_log_execution_time) {\n        qlog(\"event executed in \" + (pathend-pathstart) + \" ms\");\n    }\n}\n\n/* End of Quixe namespace function. Return the object which will\n   become the Quixe global. */\nreturn {\n    classname: 'Quixe',\n    version: '2.2.0', /* Quixe version */\n    init: quixe_init,\n    inited: quixe_inited,\n    getlibrary: quixe_getlibrary,\n    \n    start: quixe_start,\n    resume: quixe_resume,\n    get_signature: quixe_get_signature,\n    get_vm_internals: quixe_get_vm_self,\n    get_statistics: quixe_get_statistics,\n    get_debuginfo: quixe_get_debuginfo,\n\n    ReadByte: ReadArgByte,\n    WriteByte: WriteArgByte,\n    ReadWord: ReadArgWord,\n    WriteWord: WriteArgWord,\n    ReadStructField: ReadStructField,\n    WriteStructField: WriteStructField,\n    SetResumeStore: SetResumeStore,\n\n    do_autosave: vm_autosave\n};\n\n};\n\n/* Quixe is an instance of QuixeClass, ready to init. */\nvar Quixe = new QuixeClass();\n\n// Node-compatible behavior\ntry { exports.Quixe = Quixe; exports.QuixeClass = QuixeClass; } catch (ex) {};\n\n/* End of Quixe library. */\n", "'use strict';\n\n/* GiDispa -- a GlkAPI dispatch layer for Quixe\n * Designed by Andrew Plotkin <erkyrath@eblong.com>\n * <http://eblong.com/zarf/glulx/quixe/>\n * \n * This Javascript library is copyright 2010-2021 by Andrew Plotkin.\n * It is distributed under the MIT license; see the \"LICENSE\" file.\n *\n * This is the code layer that sits in between Quixe and GlkAPI. It provides\n * Glk entry points for every Glk call; Quixe's @glk opcode invokes these. It\n * also translates between Glk opaque objects (windows, streams, filerefs, etc)\n * to Quixe 32-bit numeric IDs.\n *\n * (A few calls, or arguments of calls, are marked \"for autosave/autorestore\n * only\". These exist for the purpose of getting a game displayed in a known\n * state, which is rather more complicated than the usual situation of \n * letting a game start up and run.)\n */\n\n//### Should split WriteWord into a WriteRefWord and WriteArrayWord,\n//### with different handling of -1. Etc.\n\n/* All state is contained in GiDispaClass.\n\n   Within this namespace, \"self\" is an internal secondary namespace. Many\n   of our private variables and functions will be copied into \"self\".\n   The \"self\" will be available inside compiled functions, and will give\n   them access to its contents.\n*/\n/* We find that .bind()-build functions are slower than the original,\n   particularly on Firefox. However, I don't know another way around the\n   \"dynamic variable binding in eval()\" issue, which is *also* an \n   optimization problem. At least GiDispa functions aren't (usually) called \n   that often in (normal) gameplay.\n*/\n\nvar GiDispaClass = function() {\n\n/* Create the \"self\" object. */\nvar self = {};\n\n/* self.VM will store the VM interface object. GiDispa needs this to load and\n   store reference arguments, from and to VM memory. When this layer is used\n   with Quixe, VM is just an alias for the Quixe interface object.\n*/\nself.VM = null;\nself.Glk = null;\n    \n/* Set the VM interface object. This is called by the Glk library, before\n   the VM starts running. \n*/\nfunction gidispa_init(options) {\n    self.VM = options.vm;\n    self.Glk = options.io;\n}\n\n/* Has this module been inited? */\nfunction gidispa_inited() {\n    return (self.VM != null);\n}\n\nfunction gidispa_getlibrary(val) {\n    switch (val) {\n        case 'VM': return self.VM;\n        case 'Glk': return self.Glk;\n    }\n    /* Unrecognized library name. */\n    return null;\n}\n    \n/* A table of the Glk classes, and their index numbers. This is derived from\n   gi_dispa.c, although it's too simple to bother auto-generating.\n*/\nvar class_defs = {\n    0: 'window',\n    1: 'stream',\n    2: 'fileref',\n    3: 'schannel'\n};\n\n/* FuncSpec is a data representation of a Glk function's prototype.\n   The table of FuncSpecs is generated, ultimately, from the Glk\n   prototype description strings in gi_dispa.c.\n*/\nfunction FuncSpec(id, name, proto) {\n    this.id = id;\n    this.name = name;\n    this.proto = proto;\n}\n\n/* A bunch of data classes, used by FuncSpec. */\n\nfunction Prototype(args, retarg) {\n    this.args = args;\n    this.retarg = retarg;\n}\nfunction ArgString() { \n    this.macro = 'Byte';\n    this.refsize = 1;\n    this.serialize = function() {\n        return { type:'ArgString' };\n    };\n}\nfunction ArgUnicode() { \n    this.macro = 'Word';\n    this.refsize = 4;\n    this.serialize = function() {\n        return { type:'ArgUnicode' };\n    };\n}\nfunction ArgChar(signed) {\n    this.signed = signed;\n    this.macro = 'Byte';\n    this.refsize = 1;\n    /* Note that in build_function(), we use the literal field, so\n       'arg_char_unsigned' appears for the \"char native\" case. This is\n       okay, since we only use arg.signed as a condition at that point. */\n    this.literal = (signed ? 'arg_char_signed' : 'arg_char_unsigned');\n    this.serialize = function() {\n        return { type:'ArgChar', signed:signed };\n    };\n}\nfunction ArgInt(signed) {\n    this.signed = signed;\n    this.macro = 'Word';\n    this.refsize = 4;\n    this.literal = (signed ? 'arg_int_signed' : 'arg_int_unsigned');\n    this.serialize = function() {\n        return { type:'ArgInt', signed:signed };\n    };\n}\nfunction ArgClass(name) {\n    this.name = name;\n    this.macro = 'Word';\n    this.refsize = 4;\n}\nfunction ArgStruct(form) {\n    this.form = form;\n}\nfunction ArgRef(arg, passin, passout, nonnull) {\n    this.arg = arg;\n    this.passin = passin;\n    this.passout = passout;\n    this.nonnull = nonnull;\n}\nfunction ArgArray(arg, retained, passin, passout, nonnull) {\n    this.arg = arg;\n    this.retained = retained;\n    this.passin = passin;\n    this.passout = passout;\n    this.nonnull = nonnull;\n}\n\n/* Turn the (JSONable) object generated by ArgX.serialize() back into\n   the ArgX. */\nfunction arg_deserialize(obj) {\n    switch (obj.type) {\n    case 'ArgString':\n        return new ArgString();\n    case 'ArgUnicode':\n        return new ArgUnicode();\n    case 'ArgInt':\n        if (obj.signed)\n            return arg_int_signed;\n        else\n            return arg_int_unsigned;\n    case 'ArgChar':\n        if (obj.signed === null)\n            return arg_char_native;\n        else if (obj.signed)\n            return arg_char_signed;\n        else\n            return arg_char_unsigned;\n    /* The other Arg types should not show up here. I hope. */\n    }\n    throw new Error('arg_deserialize: unknown type: ' + obj.type);\n}\n\n// The following table is auto-generated by parse_dispatch.py.\n// Generated for Glk API version 0.7.4\n/* Some literal ArgInt and ArgChar objects, used to speed\n   up the proto_map construction. These globals are also\n   used in the build_function() call in gi_dispa.js. */\nvar arg_int_unsigned = new ArgInt(false);\nvar arg_int_signed = new ArgInt(true);\nvar arg_char_unsigned = new ArgChar(false);\nvar arg_char_native = new ArgChar(null);\nvar arg_char_signed = new ArgChar(true);\nvar arg_class_window = new ArgClass(\"window\");\nvar arg_class_stream = new ArgClass(\"stream\");\nvar arg_class_fileref = new ArgClass(\"fileref\");\nvar arg_class_schannel = new ArgClass(\"schannel\");\nvar proto_map = {\n// 1 (0x001): exit - 0:\n1 : new FuncSpec(1, \"exit\", new Prototype([], null)),\n// 3 (0x003): tick - 0:\n3 : new FuncSpec(3, \"tick\", new Prototype([], null)),\n// 4 (0x004): gestalt - 3IuIu:Iu\n4 : new FuncSpec(4, \"gestalt\", new Prototype([arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 5 (0x005): gestalt_ext - 4IuIu&#Iu:Iu\n5 : new FuncSpec(5, \"gestalt_ext\", new Prototype([arg_int_unsigned, arg_int_unsigned, new ArgArray(arg_int_unsigned, false, true, true, false)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 32 (0x020): window_iterate - 3Qa<Iu:Qa\n32 : new FuncSpec(32, \"window_iterate\", new Prototype([arg_class_window, new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_class_window, false, true, true))),\n// 33 (0x021): window_get_rock - 2Qa:Iu\n33 : new FuncSpec(33, \"window_get_rock\", new Prototype([arg_class_window], new ArgRef(arg_int_unsigned, false, true, true))),\n// 34 (0x022): window_get_root - 1:Qa\n34 : new FuncSpec(34, \"window_get_root\", new Prototype([], new ArgRef(arg_class_window, false, true, true))),\n// 35 (0x023): window_open - 6QaIuIuIuIu:Qa\n35 : new FuncSpec(35, \"window_open\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_unsigned, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_window, false, true, true))),\n// 36 (0x024): window_close - 2Qa<[2IuIu]:\n36 : new FuncSpec(36, \"window_close\", new Prototype([arg_class_window, new ArgRef(new ArgStruct(new Prototype([arg_int_unsigned, arg_int_unsigned], null)), false, true, false)], null)),\n// 37 (0x025): window_get_size - 3Qa<Iu<Iu:\n37 : new FuncSpec(37, \"window_get_size\", new Prototype([arg_class_window, new ArgRef(arg_int_unsigned, false, true, false), new ArgRef(arg_int_unsigned, false, true, false)], null)),\n// 38 (0x026): window_set_arrangement - 4QaIuIuQa:\n38 : new FuncSpec(38, \"window_set_arrangement\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_unsigned, arg_class_window], null)),\n// 39 (0x027): window_get_arrangement - 4Qa<Iu<Iu<Qa:\n39 : new FuncSpec(39, \"window_get_arrangement\", new Prototype([arg_class_window, new ArgRef(arg_int_unsigned, false, true, false), new ArgRef(arg_int_unsigned, false, true, false), new ArgRef(arg_class_window, false, true, false)], null)),\n// 40 (0x028): window_get_type - 2Qa:Iu\n40 : new FuncSpec(40, \"window_get_type\", new Prototype([arg_class_window], new ArgRef(arg_int_unsigned, false, true, true))),\n// 41 (0x029): window_get_parent - 2Qa:Qa\n41 : new FuncSpec(41, \"window_get_parent\", new Prototype([arg_class_window], new ArgRef(arg_class_window, false, true, true))),\n// 42 (0x02A): window_clear - 1Qa:\n42 : new FuncSpec(42, \"window_clear\", new Prototype([arg_class_window], null)),\n// 43 (0x02B): window_move_cursor - 3QaIuIu:\n43 : new FuncSpec(43, \"window_move_cursor\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_unsigned], null)),\n// 44 (0x02C): window_get_stream - 2Qa:Qb\n44 : new FuncSpec(44, \"window_get_stream\", new Prototype([arg_class_window], new ArgRef(arg_class_stream, false, true, true))),\n// 45 (0x02D): window_set_echo_stream - 2QaQb:\n45 : new FuncSpec(45, \"window_set_echo_stream\", new Prototype([arg_class_window, arg_class_stream], null)),\n// 46 (0x02E): window_get_echo_stream - 2Qa:Qb\n46 : new FuncSpec(46, \"window_get_echo_stream\", new Prototype([arg_class_window], new ArgRef(arg_class_stream, false, true, true))),\n// 47 (0x02F): set_window - 1Qa:\n47 : new FuncSpec(47, \"set_window\", new Prototype([arg_class_window], null)),\n// 48 (0x030): window_get_sibling - 2Qa:Qa\n48 : new FuncSpec(48, \"window_get_sibling\", new Prototype([arg_class_window], new ArgRef(arg_class_window, false, true, true))),\n// 64 (0x040): stream_iterate - 3Qb<Iu:Qb\n64 : new FuncSpec(64, \"stream_iterate\", new Prototype([arg_class_stream, new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_class_stream, false, true, true))),\n// 65 (0x041): stream_get_rock - 2Qb:Iu\n65 : new FuncSpec(65, \"stream_get_rock\", new Prototype([arg_class_stream], new ArgRef(arg_int_unsigned, false, true, true))),\n// 66 (0x042): stream_open_file - 4QcIuIu:Qb\n66 : new FuncSpec(66, \"stream_open_file\", new Prototype([arg_class_fileref, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 67 (0x043): stream_open_memory - 4&#!CnIuIu:Qb\n67 : new FuncSpec(67, \"stream_open_memory\", new Prototype([new ArgArray(arg_char_native, true, true, true, false), arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 68 (0x044): stream_close - 2Qb<[2IuIu]:\n68 : new FuncSpec(68, \"stream_close\", new Prototype([arg_class_stream, new ArgRef(new ArgStruct(new Prototype([arg_int_unsigned, arg_int_unsigned], null)), false, true, false)], null)),\n// 69 (0x045): stream_set_position - 3QbIsIu:\n69 : new FuncSpec(69, \"stream_set_position\", new Prototype([arg_class_stream, arg_int_signed, arg_int_unsigned], null)),\n// 70 (0x046): stream_get_position - 2Qb:Iu\n70 : new FuncSpec(70, \"stream_get_position\", new Prototype([arg_class_stream], new ArgRef(arg_int_unsigned, false, true, true))),\n// 71 (0x047): stream_set_current - 1Qb:\n71 : new FuncSpec(71, \"stream_set_current\", new Prototype([arg_class_stream], null)),\n// 72 (0x048): stream_get_current - 1:Qb\n72 : new FuncSpec(72, \"stream_get_current\", new Prototype([], new ArgRef(arg_class_stream, false, true, true))),\n// 73 (0x049): stream_open_resource - 3IuIu:Qb\n73 : new FuncSpec(73, \"stream_open_resource\", new Prototype([arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 96 (0x060): fileref_create_temp - 3IuIu:Qc\n96 : new FuncSpec(96, \"fileref_create_temp\", new Prototype([arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_fileref, false, true, true))),\n// 97 (0x061): fileref_create_by_name - 4IuSIu:Qc\n97 : new FuncSpec(97, \"fileref_create_by_name\", new Prototype([arg_int_unsigned, new ArgString(), arg_int_unsigned], new ArgRef(arg_class_fileref, false, true, true))),\n// 98 (0x062): fileref_create_by_prompt - 4IuIuIu:Qc\n98 : new FuncSpec(98, \"fileref_create_by_prompt\", new Prototype([arg_int_unsigned, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_fileref, false, true, true))),\n// 99 (0x063): fileref_destroy - 1Qc:\n99 : new FuncSpec(99, \"fileref_destroy\", new Prototype([arg_class_fileref], null)),\n// 100 (0x064): fileref_iterate - 3Qc<Iu:Qc\n100 : new FuncSpec(100, \"fileref_iterate\", new Prototype([arg_class_fileref, new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_class_fileref, false, true, true))),\n// 101 (0x065): fileref_get_rock - 2Qc:Iu\n101 : new FuncSpec(101, \"fileref_get_rock\", new Prototype([arg_class_fileref], new ArgRef(arg_int_unsigned, false, true, true))),\n// 102 (0x066): fileref_delete_file - 1Qc:\n102 : new FuncSpec(102, \"fileref_delete_file\", new Prototype([arg_class_fileref], null)),\n// 103 (0x067): fileref_does_file_exist - 2Qc:Iu\n103 : new FuncSpec(103, \"fileref_does_file_exist\", new Prototype([arg_class_fileref], new ArgRef(arg_int_unsigned, false, true, true))),\n// 104 (0x068): fileref_create_from_fileref - 4IuQcIu:Qc\n104 : new FuncSpec(104, \"fileref_create_from_fileref\", new Prototype([arg_int_unsigned, arg_class_fileref, arg_int_unsigned], new ArgRef(arg_class_fileref, false, true, true))),\n// 128 (0x080): put_char - 1Cu:\n128 : new FuncSpec(128, \"put_char\", new Prototype([arg_char_unsigned], null)),\n// 129 (0x081): put_char_stream - 2QbCu:\n129 : new FuncSpec(129, \"put_char_stream\", new Prototype([arg_class_stream, arg_char_unsigned], null)),\n// 130 (0x082): put_string - 1S:\n130 : new FuncSpec(130, \"put_string\", new Prototype([new ArgString()], null)),\n// 131 (0x083): put_string_stream - 2QbS:\n131 : new FuncSpec(131, \"put_string_stream\", new Prototype([arg_class_stream, new ArgString()], null)),\n// 132 (0x084): put_buffer - 1>+#Cn:\n132 : new FuncSpec(132, \"put_buffer\", new Prototype([new ArgArray(arg_char_native, false, true, false, true)], null)),\n// 133 (0x085): put_buffer_stream - 2Qb>+#Cn:\n133 : new FuncSpec(133, \"put_buffer_stream\", new Prototype([arg_class_stream, new ArgArray(arg_char_native, false, true, false, true)], null)),\n// 134 (0x086): set_style - 1Iu:\n134 : new FuncSpec(134, \"set_style\", new Prototype([arg_int_unsigned], null)),\n// 135 (0x087): set_style_stream - 2QbIu:\n135 : new FuncSpec(135, \"set_style_stream\", new Prototype([arg_class_stream, arg_int_unsigned], null)),\n// 144 (0x090): get_char_stream - 2Qb:Is\n144 : new FuncSpec(144, \"get_char_stream\", new Prototype([arg_class_stream], new ArgRef(arg_int_signed, false, true, true))),\n// 145 (0x091): get_line_stream - 3Qb<+#Cn:Iu\n145 : new FuncSpec(145, \"get_line_stream\", new Prototype([arg_class_stream, new ArgArray(arg_char_native, false, false, true, true)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 146 (0x092): get_buffer_stream - 3Qb<+#Cn:Iu\n146 : new FuncSpec(146, \"get_buffer_stream\", new Prototype([arg_class_stream, new ArgArray(arg_char_native, false, false, true, true)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 160 (0x0A0): char_to_lower - 2Cu:Cu\n160 : new FuncSpec(160, \"char_to_lower\", new Prototype([arg_char_unsigned], new ArgRef(arg_char_unsigned, false, true, true))),\n// 161 (0x0A1): char_to_upper - 2Cu:Cu\n161 : new FuncSpec(161, \"char_to_upper\", new Prototype([arg_char_unsigned], new ArgRef(arg_char_unsigned, false, true, true))),\n// 176 (0x0B0): stylehint_set - 4IuIuIuIs:\n176 : new FuncSpec(176, \"stylehint_set\", new Prototype([arg_int_unsigned, arg_int_unsigned, arg_int_unsigned, arg_int_signed], null)),\n// 177 (0x0B1): stylehint_clear - 3IuIuIu:\n177 : new FuncSpec(177, \"stylehint_clear\", new Prototype([arg_int_unsigned, arg_int_unsigned, arg_int_unsigned], null)),\n// 178 (0x0B2): style_distinguish - 4QaIuIu:Iu\n178 : new FuncSpec(178, \"style_distinguish\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 179 (0x0B3): style_measure - 5QaIuIu<Iu:Iu\n179 : new FuncSpec(179, \"style_measure\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_unsigned, new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 192 (0x0C0): select - 1<+[4IuQaIuIu]:\n192 : new FuncSpec(192, \"select\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_unsigned, arg_class_window, arg_int_unsigned, arg_int_unsigned], null)), false, true, true)], null)),\n// 193 (0x0C1): select_poll - 1<+[4IuQaIuIu]:\n193 : new FuncSpec(193, \"select_poll\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_unsigned, arg_class_window, arg_int_unsigned, arg_int_unsigned], null)), false, true, true)], null)),\n// 208 (0x0D0): request_line_event - 3Qa&+#!CnIu:\n208 : new FuncSpec(208, \"request_line_event\", new Prototype([arg_class_window, new ArgArray(arg_char_native, true, true, true, true), arg_int_unsigned], null)),\n// 209 (0x0D1): cancel_line_event - 2Qa<[4IuQaIuIu]:\n209 : new FuncSpec(209, \"cancel_line_event\", new Prototype([arg_class_window, new ArgRef(new ArgStruct(new Prototype([arg_int_unsigned, arg_class_window, arg_int_unsigned, arg_int_unsigned], null)), false, true, false)], null)),\n// 210 (0x0D2): request_char_event - 1Qa:\n210 : new FuncSpec(210, \"request_char_event\", new Prototype([arg_class_window], null)),\n// 211 (0x0D3): cancel_char_event - 1Qa:\n211 : new FuncSpec(211, \"cancel_char_event\", new Prototype([arg_class_window], null)),\n// 212 (0x0D4): request_mouse_event - 1Qa:\n212 : new FuncSpec(212, \"request_mouse_event\", new Prototype([arg_class_window], null)),\n// 213 (0x0D5): cancel_mouse_event - 1Qa:\n213 : new FuncSpec(213, \"cancel_mouse_event\", new Prototype([arg_class_window], null)),\n// 214 (0x0D6): request_timer_events - 1Iu:\n214 : new FuncSpec(214, \"request_timer_events\", new Prototype([arg_int_unsigned], null)),\n// 224 (0x0E0): image_get_info - 4Iu<Iu<Iu:Iu\n224 : new FuncSpec(224, \"image_get_info\", new Prototype([arg_int_unsigned, new ArgRef(arg_int_unsigned, false, true, false), new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 225 (0x0E1): image_draw - 5QaIuIsIs:Iu\n225 : new FuncSpec(225, \"image_draw\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_signed, arg_int_signed], new ArgRef(arg_int_unsigned, false, true, true))),\n// 226 (0x0E2): image_draw_scaled - 7QaIuIsIsIuIu:Iu\n226 : new FuncSpec(226, \"image_draw_scaled\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_signed, arg_int_signed, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 232 (0x0E8): window_flow_break - 1Qa:\n232 : new FuncSpec(232, \"window_flow_break\", new Prototype([arg_class_window], null)),\n// 233 (0x0E9): window_erase_rect - 5QaIsIsIuIu:\n233 : new FuncSpec(233, \"window_erase_rect\", new Prototype([arg_class_window, arg_int_signed, arg_int_signed, arg_int_unsigned, arg_int_unsigned], null)),\n// 234 (0x0EA): window_fill_rect - 6QaIuIsIsIuIu:\n234 : new FuncSpec(234, \"window_fill_rect\", new Prototype([arg_class_window, arg_int_unsigned, arg_int_signed, arg_int_signed, arg_int_unsigned, arg_int_unsigned], null)),\n// 235 (0x0EB): window_set_background_color - 2QaIu:\n235 : new FuncSpec(235, \"window_set_background_color\", new Prototype([arg_class_window, arg_int_unsigned], null)),\n// 240 (0x0F0): schannel_iterate - 3Qd<Iu:Qd\n240 : new FuncSpec(240, \"schannel_iterate\", new Prototype([arg_class_schannel, new ArgRef(arg_int_unsigned, false, true, false)], new ArgRef(arg_class_schannel, false, true, true))),\n// 241 (0x0F1): schannel_get_rock - 2Qd:Iu\n241 : new FuncSpec(241, \"schannel_get_rock\", new Prototype([arg_class_schannel], new ArgRef(arg_int_unsigned, false, true, true))),\n// 242 (0x0F2): schannel_create - 2Iu:Qd\n242 : new FuncSpec(242, \"schannel_create\", new Prototype([arg_int_unsigned], new ArgRef(arg_class_schannel, false, true, true))),\n// 243 (0x0F3): schannel_destroy - 1Qd:\n243 : new FuncSpec(243, \"schannel_destroy\", new Prototype([arg_class_schannel], null)),\n// 244 (0x0F4): schannel_create_ext - 3IuIu:Qd\n244 : new FuncSpec(244, \"schannel_create_ext\", new Prototype([arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_schannel, false, true, true))),\n// 247 (0x0F7): schannel_play_multi - 4>+#Qd>+#IuIu:Iu\n247 : new FuncSpec(247, \"schannel_play_multi\", new Prototype([new ArgArray(arg_class_schannel, false, true, false, true), new ArgArray(arg_int_unsigned, false, true, false, true), arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 248 (0x0F8): schannel_play - 3QdIu:Iu\n248 : new FuncSpec(248, \"schannel_play\", new Prototype([arg_class_schannel, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 249 (0x0F9): schannel_play_ext - 5QdIuIuIu:Iu\n249 : new FuncSpec(249, \"schannel_play_ext\", new Prototype([arg_class_schannel, arg_int_unsigned, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 250 (0x0FA): schannel_stop - 1Qd:\n250 : new FuncSpec(250, \"schannel_stop\", new Prototype([arg_class_schannel], null)),\n// 251 (0x0FB): schannel_set_volume - 2QdIu:\n251 : new FuncSpec(251, \"schannel_set_volume\", new Prototype([arg_class_schannel, arg_int_unsigned], null)),\n// 252 (0x0FC): sound_load_hint - 2IuIu:\n252 : new FuncSpec(252, \"sound_load_hint\", new Prototype([arg_int_unsigned, arg_int_unsigned], null)),\n// 253 (0x0FD): schannel_set_volume_ext - 4QdIuIuIu:\n253 : new FuncSpec(253, \"schannel_set_volume_ext\", new Prototype([arg_class_schannel, arg_int_unsigned, arg_int_unsigned, arg_int_unsigned], null)),\n// 254 (0x0FE): schannel_pause - 1Qd:\n254 : new FuncSpec(254, \"schannel_pause\", new Prototype([arg_class_schannel], null)),\n// 255 (0x0FF): schannel_unpause - 1Qd:\n255 : new FuncSpec(255, \"schannel_unpause\", new Prototype([arg_class_schannel], null)),\n// 256 (0x100): set_hyperlink - 1Iu:\n256 : new FuncSpec(256, \"set_hyperlink\", new Prototype([arg_int_unsigned], null)),\n// 257 (0x101): set_hyperlink_stream - 2QbIu:\n257 : new FuncSpec(257, \"set_hyperlink_stream\", new Prototype([arg_class_stream, arg_int_unsigned], null)),\n// 258 (0x102): request_hyperlink_event - 1Qa:\n258 : new FuncSpec(258, \"request_hyperlink_event\", new Prototype([arg_class_window], null)),\n// 259 (0x103): cancel_hyperlink_event - 1Qa:\n259 : new FuncSpec(259, \"cancel_hyperlink_event\", new Prototype([arg_class_window], null)),\n// 288 (0x120): buffer_to_lower_case_uni - 3&+#IuIu:Iu\n288 : new FuncSpec(288, \"buffer_to_lower_case_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, true, true), arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 289 (0x121): buffer_to_upper_case_uni - 3&+#IuIu:Iu\n289 : new FuncSpec(289, \"buffer_to_upper_case_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, true, true), arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 290 (0x122): buffer_to_title_case_uni - 4&+#IuIuIu:Iu\n290 : new FuncSpec(290, \"buffer_to_title_case_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, true, true), arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 291 (0x123): buffer_canon_decompose_uni - 3&+#IuIu:Iu\n291 : new FuncSpec(291, \"buffer_canon_decompose_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, true, true), arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 292 (0x124): buffer_canon_normalize_uni - 3&+#IuIu:Iu\n292 : new FuncSpec(292, \"buffer_canon_normalize_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, true, true), arg_int_unsigned], new ArgRef(arg_int_unsigned, false, true, true))),\n// 296 (0x128): put_char_uni - 1Iu:\n296 : new FuncSpec(296, \"put_char_uni\", new Prototype([arg_int_unsigned], null)),\n// 297 (0x129): put_string_uni - 1U:\n297 : new FuncSpec(297, \"put_string_uni\", new Prototype([new ArgUnicode()], null)),\n// 298 (0x12A): put_buffer_uni - 1>+#Iu:\n298 : new FuncSpec(298, \"put_buffer_uni\", new Prototype([new ArgArray(arg_int_unsigned, false, true, false, true)], null)),\n// 299 (0x12B): put_char_stream_uni - 2QbIu:\n299 : new FuncSpec(299, \"put_char_stream_uni\", new Prototype([arg_class_stream, arg_int_unsigned], null)),\n// 300 (0x12C): put_string_stream_uni - 2QbU:\n300 : new FuncSpec(300, \"put_string_stream_uni\", new Prototype([arg_class_stream, new ArgUnicode()], null)),\n// 301 (0x12D): put_buffer_stream_uni - 2Qb>+#Iu:\n301 : new FuncSpec(301, \"put_buffer_stream_uni\", new Prototype([arg_class_stream, new ArgArray(arg_int_unsigned, false, true, false, true)], null)),\n// 304 (0x130): get_char_stream_uni - 2Qb:Is\n304 : new FuncSpec(304, \"get_char_stream_uni\", new Prototype([arg_class_stream], new ArgRef(arg_int_signed, false, true, true))),\n// 305 (0x131): get_buffer_stream_uni - 3Qb<+#Iu:Iu\n305 : new FuncSpec(305, \"get_buffer_stream_uni\", new Prototype([arg_class_stream, new ArgArray(arg_int_unsigned, false, false, true, true)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 306 (0x132): get_line_stream_uni - 3Qb<+#Iu:Iu\n306 : new FuncSpec(306, \"get_line_stream_uni\", new Prototype([arg_class_stream, new ArgArray(arg_int_unsigned, false, false, true, true)], new ArgRef(arg_int_unsigned, false, true, true))),\n// 312 (0x138): stream_open_file_uni - 4QcIuIu:Qb\n312 : new FuncSpec(312, \"stream_open_file_uni\", new Prototype([arg_class_fileref, arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 313 (0x139): stream_open_memory_uni - 4&#!IuIuIu:Qb\n313 : new FuncSpec(313, \"stream_open_memory_uni\", new Prototype([new ArgArray(arg_int_unsigned, true, true, true, false), arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 314 (0x13A): stream_open_resource_uni - 3IuIu:Qb\n314 : new FuncSpec(314, \"stream_open_resource_uni\", new Prototype([arg_int_unsigned, arg_int_unsigned], new ArgRef(arg_class_stream, false, true, true))),\n// 320 (0x140): request_char_event_uni - 1Qa:\n320 : new FuncSpec(320, \"request_char_event_uni\", new Prototype([arg_class_window], null)),\n// 321 (0x141): request_line_event_uni - 3Qa&+#!IuIu:\n321 : new FuncSpec(321, \"request_line_event_uni\", new Prototype([arg_class_window, new ArgArray(arg_int_unsigned, true, true, true, true), arg_int_unsigned], null)),\n// 336 (0x150): set_echo_line_event - 2QaIu:\n336 : new FuncSpec(336, \"set_echo_line_event\", new Prototype([arg_class_window, arg_int_unsigned], null)),\n// 337 (0x151): set_terminators_line_event - 2Qa>#Iu:\n337 : new FuncSpec(337, \"set_terminators_line_event\", new Prototype([arg_class_window, new ArgArray(arg_int_unsigned, false, true, false, false)], null)),\n// 352 (0x160): current_time - 1<+[3IsIuIs]:\n352 : new FuncSpec(352, \"current_time\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_unsigned, arg_int_signed], null)), false, true, true)], null)),\n// 353 (0x161): current_simple_time - 2Iu:Is\n353 : new FuncSpec(353, \"current_simple_time\", new Prototype([arg_int_unsigned], new ArgRef(arg_int_signed, false, true, true))),\n// 360 (0x168): time_to_date_utc - 2>+[3IsIuIs]<+[8IsIsIsIsIsIsIsIs]:\n360 : new FuncSpec(360, \"time_to_date_utc\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_unsigned, arg_int_signed], null)), true, false, true), new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), false, true, true)], null)),\n// 361 (0x169): time_to_date_local - 2>+[3IsIuIs]<+[8IsIsIsIsIsIsIsIs]:\n361 : new FuncSpec(361, \"time_to_date_local\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_unsigned, arg_int_signed], null)), true, false, true), new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), false, true, true)], null)),\n// 362 (0x16A): simple_time_to_date_utc - 3IsIu<+[8IsIsIsIsIsIsIsIs]:\n362 : new FuncSpec(362, \"simple_time_to_date_utc\", new Prototype([arg_int_signed, arg_int_unsigned, new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), false, true, true)], null)),\n// 363 (0x16B): simple_time_to_date_local - 3IsIu<+[8IsIsIsIsIsIsIsIs]:\n363 : new FuncSpec(363, \"simple_time_to_date_local\", new Prototype([arg_int_signed, arg_int_unsigned, new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), false, true, true)], null)),\n// 364 (0x16C): date_to_time_utc - 2>+[8IsIsIsIsIsIsIsIs]<+[3IsIuIs]:\n364 : new FuncSpec(364, \"date_to_time_utc\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), true, false, true), new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_unsigned, arg_int_signed], null)), false, true, true)], null)),\n// 365 (0x16D): date_to_time_local - 2>+[8IsIsIsIsIsIsIsIs]<+[3IsIuIs]:\n365 : new FuncSpec(365, \"date_to_time_local\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), true, false, true), new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_unsigned, arg_int_signed], null)), false, true, true)], null)),\n// 366 (0x16E): date_to_simple_time_utc - 3>+[8IsIsIsIsIsIsIsIs]Iu:Is\n366 : new FuncSpec(366, \"date_to_simple_time_utc\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), true, false, true), arg_int_unsigned], new ArgRef(arg_int_signed, false, true, true))),\n// 367 (0x16F): date_to_simple_time_local - 3>+[8IsIsIsIsIsIsIsIs]Iu:Is\n367 : new FuncSpec(367, \"date_to_simple_time_local\", new Prototype([new ArgRef(new ArgStruct(new Prototype([arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed, arg_int_signed], null)), true, false, true), arg_int_unsigned], new ArgRef(arg_int_signed, false, true, true))),\n// 4352 (0x1100): garglk_set_zcolors - 2IuIu:\n4352 : new FuncSpec(4352, \"garglk_set_zcolors\", new Prototype([arg_int_unsigned, arg_int_unsigned], null)),\n// 4353 (0x1101): garglk_set_zcolors_stream - 3QbIuIu:\n4353 : new FuncSpec(4353, \"garglk_set_zcolors_stream\", new Prototype([arg_class_stream, arg_int_unsigned, arg_int_unsigned], null)),\n// 4354 (0x1102): garglk_set_reversevideo - 1Iu:\n4354 : new FuncSpec(4354, \"garglk_set_reversevideo\", new Prototype([arg_int_unsigned], null)),\n// 4355 (0x1103): garglk_set_reversevideo_stream - 2QbIu:\n4355 : new FuncSpec(4355, \"garglk_set_reversevideo_stream\", new Prototype([arg_class_stream, arg_int_unsigned], null)),\n};\n// End of auto-generated table.\n\n\n/* Make globals available to compiled functions. */\nself.arg_int_unsigned  = arg_int_unsigned;\nself.arg_int_signed    = arg_int_signed;\nself.arg_char_unsigned = arg_char_unsigned;\nself.arg_char_native   = arg_char_native;\nself.arg_char_signed   = arg_char_signed;\n\n/* Convert one simple value (int, char, string, class) from a Glulx\n   value (32-bit unsigned integer) into a Glk library value.\n*/\nfunction convert_arg(arg, passin, val) {\n    if (arg instanceof ArgInt) {\n        if (passin) {\n            if (!arg.signed)\n                return val;\n            else\n                return val + ' & 0xFFFFFFFF';\n        }\n        else {\n            return '0';\n        }\n    }\n    if (arg instanceof ArgChar) {\n        if (passin) {\n            if (!arg.signed)\n                return val + ' & 0xFF';\n            else\n                return 'self.cast_signed_char('+val+')'\n        }\n        else {\n            return '0';\n        }\n    }\n    if (arg instanceof ArgClass) {\n        if (passin) {\n            return 'self.class_obj_from_id(\"'+arg.name+'\", '+val+')';\n        }\n        else {\n            return 'null';\n        }\n    }\n    return '???';\n}\n\n/* Convert one simple value (int, char, string, class) from a Glk library \n   value into a Glulx value (32-bit unsigned integer).\n*/\nfunction unconvert_arg(arg, val) {\n    if (arg instanceof ArgInt) {\n        return val + ' >>> 0';\n    }\n    if (arg instanceof ArgChar) {\n        if (!arg.signed)\n            return val + ' & 0xFF';\n        else\n            return 'self.uncast_signed_char('+val+')'\n    }\n    if (arg instanceof ArgClass) {\n        return 'self.class_obj_to_id(\"'+arg.name+'\", '+val+')';\n    }\n    return '???';\n}\n\n/* Convert a Glulx value into a signed char value. Not a Javascript\n   string, but the bastardized C notion used by the Glk library:\n   a number from -128 to 127.\n*/\nfunction cast_signed_char(val) {\n    val = val & 0xFF;\n    if (val & 0x80)\n        val -= 0x100;\n    return val;\n}\nself.cast_signed_char = cast_signed_char;\n\n/* The converse. */\nfunction uncast_signed_char(val) {\n    val = val & 0xFF;\n    if (val & 0x80)\n        val += 0xFFFFFF00;\n    return val;\n}\nself.uncast_signed_char = uncast_signed_char;\n\n/* Convert an opaque object (a window, stream, or whatever) to a Glulx value\n   (an unsigned 32-bit number).\n*/\nfunction class_obj_to_id(clas, val) {\n    if (!val)\n        return 0;\n    return val.disprock;\n}\nself.class_obj_to_id = class_obj_to_id;\n\n/* The converse. */\nfunction class_obj_from_id(clas, val) {\n    if (val == 0 || !val)\n        return null;\n    return class_map[clas][val];\n}\nself.class_obj_from_id = class_obj_from_id;\n\n/* Convert a FuncSpec object into a Javascript function. The function,\n   when called, should be passed exactly one argument: an array of\n   Glulx values, taken straight from the VM. It will return a Glulx\n   value (zero, if the Glk call does not return a value).\n\n   (This function is for internal use. The VM should call get_function(),\n   which caches built functions.)\n*/\nfunction build_function(func) {\n    var ix, jx;\n    var form, retarg, argpos, argjoin, subargs;\n    var arg, refarg, tmpvar, val, retval, ls;\n    var mayblock;\n\n    /* We will accumulate a list of Javascript lines in the out array. */\n    var out = [];\n    var locals = {};\n    var arraycount = 0;\n\n    out.push('// no local vars');\n    out.push('// ' + func.id + ': ' + func.name);\n    form = func.proto;\n    retarg = null;\n    if (form.retarg)\n        retarg = form.retarg.arg;\n\n    /* The \"self\" object will be bound in via \"this\". */\n    out.push('var self = this;');\n\n    /* If this is true, the call might return DidNotReturn. */\n    mayblock = self.Glk.call_may_not_return(func.id);\n\n    /* Load the argument values into local variables, for use in the\n       call. For array, struct, and reference arguments, we also need\n       to load up the referred-to values. */\n\n    argpos = 0;\n    argjoin = [];\n    for (ix=0; ix<form.args.length; ix++) {\n        arg = form.args[ix];\n        tmpvar = 'glka'+ix;\n        argjoin.push(tmpvar);\n        locals[tmpvar] = true;\n        if ((arg instanceof ArgInt)\n            || (arg instanceof ArgChar)\n            || (arg instanceof ArgClass)) {\n            val = convert_arg(arg, true, 'callargs['+argpos+']');\n            out.push(tmpvar + ' = ' + val + ';');\n            argpos += 1;\n        }\n        else if (arg instanceof ArgRef) {\n            refarg = arg.arg;\n            out.push('if (callargs['+argpos+'] == 0) {');\n            if (arg.nonnull) \n                out.push('  throw new Error(\"glk '+func.name+': null argument\");');\n            else\n                out.push('  '+tmpvar+' = null;');\n            out.push('} else {');\n            if ((refarg instanceof ArgInt)\n                || (refarg instanceof ArgChar)\n                || (refarg instanceof ArgClass)) {\n                out.push('  '+tmpvar+' = new self.Glk.RefBox();');\n                val = convert_arg(refarg, arg.passin, 'self.VM.ReadWord(callargs['+argpos+'])');\n                out.push('  '+tmpvar+'.set_value('+val+');');\n            }\n            else if (refarg instanceof ArgStruct) {\n                subargs = refarg.form.args;\n                out.push('  '+tmpvar+' = new self.Glk.RefStruct('+subargs.length+');');\n                for (jx=0; jx<subargs.length; jx++) {\n                    val = convert_arg(subargs[jx], arg.passin, 'self.VM.ReadStructField(callargs['+argpos+'], '+jx+')');\n                    out.push('  '+tmpvar+'.push_field('+val+');');\n                }\n            }\n            else {\n                throw new Error('buildfunc: unsupported refarg type: ' + func.name);\n            }\n            out.push('}');\n            argpos += 1;\n        }\n        else if (arg instanceof ArgArray) {\n            locals['glklen'] = true;\n            refarg = arg.arg;\n            out.push('if (callargs['+argpos+'] == 0) {');\n            if (arg.nonnull)\n                out.push('  throw new Error(\"glk '+func.name+': null argument\");');\n            else\n                out.push('  '+tmpvar+' = null;');\n            out.push('} else {');\n            out.push('  glklen = callargs['+(argpos+1)+'];');\n            out.push('  '+tmpvar+' = Array(glklen);');\n            if (arg.passin) {\n                locals['ix'] = true;\n                locals['jx'] = true;\n                out.push('  for (ix=0, jx=callargs['+argpos+']; ix<glklen; ix++, jx+='+refarg.refsize+') {');\n                val = convert_arg(refarg, true, 'self.VM.Read'+refarg.macro+'(jx)');\n                out.push('    '+tmpvar+'[ix] = '+val+';');\n                out.push('  }');\n            }\n            if (arg.retained) {\n                if (arraycount == 0)\n                    out.push('  self.temp_arg_arrays.length = 0;');\n                arraycount += 1;\n                out.push('  self.make_arg_array('+tmpvar+', callargs['+argpos+'], glklen, self.'+refarg.literal+');');\n            }\n            out.push('}');\n            argpos += 2;\n        }\n        else if ((arg instanceof ArgString) || (arg instanceof ArgUnicode)) {\n            locals['ix'] = true;\n            locals['jx'] = true;\n            var confunc, checkbyte;\n            if (arg instanceof ArgString) {\n                checkbyte = '0xE0';\n                confunc = 'byte_array_to_string';\n            }\n            else {\n                checkbyte = '0xE2';\n                confunc = 'uni_array_to_string';\n            }\n            out.push(tmpvar+' = Array();');\n            out.push('jx = callargs['+argpos+'];');\n            out.push('if (self.VM.ReadByte(jx) != '+checkbyte+') throw new Error(\"glk '+func.name+': string argument must be unencoded\");');\n            out.push('for (jx+='+arg.refsize+'; true; jx+='+arg.refsize+') {');\n            out.push('  ix = self.VM.Read'+arg.macro+'(jx);');\n            out.push('  if (ix == 0) break;');\n            out.push('  '+tmpvar+'.push(ix);');\n            out.push('}');\n            out.push(tmpvar+' = self.Glk.'+confunc+'('+tmpvar+');');\n            argpos += 1;\n        }\n        else {\n            throw new Error('buildfunc: unsupported arg type: ' + func.name);\n        }\n    }\n\n    out.push('if (callargs.length != '+argpos+') throw \"glk '+func.name+': wrong number of arguments\";');\n\n    /* Perform the call itself. */\n\n    if (retarg || mayblock) {\n        locals['glkret'] = true;\n        retval = 'glkret = ';\n    }\n    else {\n        retval = '';\n    }\n    out.push(retval + ('self.Glk.glk_' + func.name).replace('glk_gar', 'gar') + '(' + argjoin.join(', ') + ');');\n\n    if (mayblock) {\n        /* If the call blocks, we need to stash away the arguments and\n           then return early. */\n        out.push('if (glkret === self.Glk.DidNotReturn) {');\n        out.push('  self.set_blocked_selector(' + func.id + ', callargs);');\n        out.push('  return glkret;');\n        out.push('}');\n    }\n\n    /* For reference/array/struct arguments, unload the referred-to values\n       back out to the VM. */\n\n    argpos = 0;\n    for (ix=0; ix<form.args.length; ix++) {\n        arg = form.args[ix];\n        tmpvar = 'glka'+ix;\n        if ((arg instanceof ArgInt)\n            || (arg instanceof ArgChar)\n            || (arg instanceof ArgClass)) {\n            argpos += 1;\n        }\n        else if (arg instanceof ArgRef) {\n            refarg = arg.arg;\n            if (arg.passout) {\n                out.push('if ('+tmpvar+') {');\n                if ((refarg instanceof ArgInt)\n                    || (refarg instanceof ArgChar)\n                    || (refarg instanceof ArgClass)) {\n                    val = unconvert_arg(refarg, tmpvar+'.get_value()');\n                    out.push('  self.VM.WriteWord(callargs['+argpos+'], '+val+');');\n                }\n                else if (refarg instanceof ArgStruct) {\n                    subargs = refarg.form.args;\n                    for (jx=0; jx<subargs.length; jx++) {\n                        val = unconvert_arg(subargs[jx], tmpvar+'.get_field('+jx+')');\n                        out.push('  self.VM.WriteStructField(callargs['+argpos+'], '+jx+', '+val+');');\n                    }\n                }\n                else {\n                    throw new Error('buildfunc: unsupported refarg type: ' + func.name);\n                }\n                out.push('}');\n            }\n            argpos += 1;\n        }\n        else if (arg instanceof ArgArray) {\n            refarg = arg.arg;\n            if (arg.passout && !arg.retained) {\n                out.push('if ('+tmpvar+') {');\n                locals['ix'] = true;\n                locals['jx'] = true;\n                out.push('  for (ix=0, jx=callargs['+argpos+']; ix<glklen; ix++, jx+='+refarg.refsize+') {');\n                val = unconvert_arg(refarg, tmpvar+'[ix]');\n                out.push('    self.VM.Write'+refarg.macro+'(jx, '+val+')');\n                out.push('  }');\n                out.push('}');\n            }\n            argpos += 2;\n        }\n        else if ((arg instanceof ArgString) || (arg instanceof ArgUnicode)) {\n            argpos += 1;\n        }\n        else {\n            throw new Error('buildfunc: unsupported arg type: ' + func.name);\n        }\n    }\n    \n    /* Discard any argument arrays. (Retained ones have already been\n       added to retained_arrays.) */\n    if (arraycount != 0)\n        out.push('self.temp_arg_arrays.length = 0;');\n\n    /* Return the return value. */\n\n    if (retarg) {\n        val = unconvert_arg(retarg, 'glkret');\n        out.push('return '+val+';');\n    }\n    else {\n        out.push('return 0;');\n    }\n\n    /* Add a line to the beginning which lists all the locals we used. */\n\n    ls = [];\n    for (val in locals)\n        ls.push(val);\n    if (ls.length)\n        out[0] = 'var ' + ls.join(', ') + ';';\n    val = out.join('\\n');\n\n    /* Compile the function and return it. We bind the internal object as\n       its \"this\". */\n    var resfunc = new Function('callargs', val);\n    return resfunc.bind(self);\n}\n\n/* Cache of all the dispatch functions we've compiled. */\nvar function_map = {};\n\n/* Given a Glk selector number, return the dispatch function for it.\n\n   The function, when called, should be passed exactly one argument: \n   an array of Glulx values, taken straight from the VM. It will return\n   a Glulx value (zero, if the Glk call does not return a value).\n\n   If the selector number is not recognized, this throws an exception.\n*/\nfunction get_function(id) {\n    var proto;\n    var func = function_map[id];\n    if (func === undefined) {\n        proto = proto_map[id];\n        if (proto === undefined)\n            throw new Error('dispatch: unknown Glk function: ' + id);\n        func = build_function(proto);\n        function_map[id] = func;\n    }\n    return func;\n}\n\n/* The stashed arguments of the call that blocked. If we are not blocked\n   on a Glk call, these variables will be null. */\nvar blocked_selector = null;\nvar blocked_callargs = null;\n\nvar last_event_type = -1; /* Last event type. */\n\n/* Stash the above arguments. We make a copy of the args list, because\n   we don't trust the argument to be immutable.\n*/\nfunction set_blocked_selector(sel, args) {\n    blocked_selector = sel;\n    blocked_callargs = args.slice(0);\n}\nself.set_blocked_selector = set_blocked_selector;\n\n/* Check whether this is a good time for autosave. This is an awkward\n   API call, but GiDispa is the easiest place to find this information.\n\n   It's a good time for autosave if (a) we're blocked on glk_select\n   (rather than glk_fileref_create_by_prompt or whatever); (b) we did\n   not just launch; (c) we just responded to a keyboard or mouse event\n   (as opposed to timer, resize, etc).\n\n   If it's not a good time, return null. If it is, we return the VM address\n   of the event structure, which the caller needs. (See, I told you it\n   was awkward.)\n*/\nfunction check_autosave() {\n    if (blocked_selector == 0x0C0 && blocked_callargs && blocked_callargs.length > 0) {\n        if (last_event_type == 2 || last_event_type == 3 \n            || last_event_type == 4 || last_event_type == 8) {\n            return blocked_callargs[0];\n        }\n    }\n    return null;\n}\n\n/* Prepare the VM to resume after a blocked function. The argument is\n   the argument to the original blocked call. Our job is to unload\n   that into the VM's memory map.\n\n   We cheat, here, and rely on knowing that only a couple of Glk calls can\n   block. (glk_exit can block too, but of course it doesn't resume.)\n*/\nfunction prepare_resume(glka0) {\n    if (blocked_selector == 0x0C0) {\n        // glk_select\n        if (blocked_callargs[0] != 0) {\n            last_event_type = (glka0.get_field(0) >>> 0);\n            self.VM.WriteStructField(blocked_callargs[0], 0, glka0.get_field(0) >>> 0);\n            self.VM.WriteStructField(blocked_callargs[0], 1, class_obj_to_id(\"window\", glka0.get_field(1)));\n            self.VM.WriteStructField(blocked_callargs[0], 2, glka0.get_field(2) >>> 0);\n            self.VM.WriteStructField(blocked_callargs[0], 3, glka0.get_field(3) >>> 0);\n        }\n    }\n    else if (blocked_selector == 0x062) {\n        // glk_fileref_create_by_prompt\n        self.VM.SetResumeStore(class_obj_to_id(\"fileref\", glka0));\n    }\n    blocked_selector = null;\n    blocked_callargs = null;\n}\n\n/* This lists all the array arguments during a Glk call (but not between\n   calls). */\nvar temp_arg_arrays = [];\nself.temp_arg_arrays = temp_arg_arrays;\n\n/* List of retained arrays -- those that are being held by long-term\n   Glk activities, like line input. Each entry in this list is an\n   object { arr:array, addr:VMaddress, len:length, arg:ArgInt/ArgChar }.\n\n   This storage model assumes that no array will be retained twice\n   at the same time. I think this is safe.\n*/\nvar retained_arrays = [];\nself.retained_arrays = retained_arrays;\n\n/* Create an argument array descriptor. The address and length are where it\n   will go in VM memory. The arg is an ArgInt or ArgChar object, describing the\n   array entries.\n\n   These descriptors are temporary -- they only exist for the duration\n   of a Glk call -- unless the call *retains* the array. Then it's\n   kept around until another call unretains it.\n*/\nfunction make_arg_array(arr, addr, len, arg) {\n    var obj;\n    if (!arr)\n        return;\n    obj = { arr:arr, addr:addr, len:len, arg:arg };\n    temp_arg_arrays.push(obj);\n}\nself.make_arg_array = make_arg_array;\n\n/* Retain one array. This must have been passed to make_arg_array(),\n   earlier in this Glk call.\n\n   If invoked by the autorestore system, there is no previous \n   make_arg_array() call. Instead, the necessary information is provided\n   in useobj. (The array must match.) The useobj argument should *only*\n   be used by autorestore.\n*/\nfunction retain_array(arr, useobj) {\n    var ix, obj;\n    if (!arr)\n        return;\n\n    if (useobj !== undefined) {\n        if (arr !== useobj.arr)\n            throw new Error('retain_array: array does not match useobj');\n        obj = { \n            addr:useobj.addr, len:useobj.len,\n            arr:arr,\n            arg:arg_deserialize(useobj.arg)\n        }\n        if (obj.len != arr.length)\n            throw new Error('retain_array: array length from useobj does not match');\n    }\n    else {\n        obj = undefined;\n        for (ix=0; ix<temp_arg_arrays.length; ix++) {\n            if (temp_arg_arrays[ix].arr === arr) {\n                obj = temp_arg_arrays[ix];\n                break;\n            }\n        }\n    }\n\n    if (obj === undefined)\n        throw new Error('retain_array: array is not an argument');\n\n    for (ix=0; !(retained_arrays[ix] === undefined); ix++) { };\n    retained_arrays[ix] = obj;\n}\n\n/* Return information about one retained array. This is used *only*\n   by the autosave/autorestore system.\n*/\nfunction get_retained_array(arr) {\n    var ix;\n\n    for (ix=0; ix<retained_arrays.length; ix++) {\n        if (retained_arrays[ix] === undefined)\n            continue;\n        if (retained_arrays[ix].arr === arr) {\n            return retained_arrays[ix];\n        }\n    }\n\n    return null;\n}\n\n/* Unretain one array; write its contents back into memory. (We take for\n   granted that a retained array is always pass-out.)\n*/\nfunction unretain_array(arr) {\n    var ix, jx, obj;\n    if (!arr)\n        return;\n\n    obj = undefined;\n    for (ix=0; ix<retained_arrays.length; ix++) {\n        if (retained_arrays[ix] === undefined)\n            continue;\n        if (retained_arrays[ix].arr === arr) {\n            obj = retained_arrays[ix];\n            delete retained_arrays[ix];\n            break;\n        }\n    }\n\n    if (obj === undefined)\n        throw new Error('unretain_array: array was never retained');\n\n    if (obj.arg instanceof ArgInt) {\n        for (ix=0, jx=obj.addr; ix<obj.len; ix++, jx+=4) {\n            self.VM.WriteWord(jx, obj.arr[ix] >>> 0);\n        }\n    }\n    else if (obj.arg instanceof ArgChar) {\n        if (!obj.arg.signed) {\n            for (ix=0, jx=obj.addr; ix<obj.len; ix++, jx++) {\n                self.VM.WriteByte(jx, obj.arr[ix] & 0xFF);\n            }\n        }\n        else {\n            for (ix=0, jx=obj.addr; ix<obj.len; ix++, jx++) {\n                self.VM.WriteByte(jx, uncast_signed_char(obj.arr[ix]));\n            }\n        }\n    }\n    else {\n        throw new Error('unretain_array: unsupported refarg type');\n    }\n}\n\n/* Table of tables of registered Glk objects. class_map['window'] is the\n   table of windows, and so on.\n*/\nvar class_map = {};\n/* Source of numeric ids that are used to identify Glk objects. */\nvar last_used_id;\n\n/* Note a newly-created Glk object. The clas argument must be one of\n   the type name strings: \"window\", \"stream\", etc. \n\n   This is called by the Glk library. The object's disprock field is\n   set to a 32-bit number.\n\n   If usedisprock is set, we use that value instead of picking a new one.\n   (And bump last_used_id so that it won't collide with it in the future.)\n   This is *only* used by the autorestore feature. In this case, the\n   obj's disprock must already be set to the provided value.\n*/\nfunction class_register(clas, obj, usedisprock) {\n    if (usedisprock === undefined) {\n        /* Normal case */\n        if (obj.disprock)\n            throw new Error('class_register: object is already registered');\n        obj.disprock = last_used_id;\n        last_used_id++;\n    }\n    else {\n        /* Autorestore case */\n        if (obj.disprock != usedisprock)\n            throw new Error('class_register: object is not already registered');\n        if (last_used_id <= usedisprock)\n            last_used_id = usedisprock + 1;\n    }\n\n    class_map[clas][obj.disprock] = obj;\n}\n\n/* Note a just-destroyed Glk object.\n*/\nfunction class_unregister(clas, obj) {\n    if (!obj.disprock || class_map[clas][obj.disprock] === undefined)\n        throw new Error('class_unregister: object is not registered');\n    \n    delete class_map[clas][obj.disprock];\n    obj.disprock = undefined;\n}\n\n/* This is called as soon as the GiDispa module is loaded. It sets up some\n   internal tables. This does not rely on any other module.\n*/\nfunction init_module() {\n    var ix, key;\n\n    last_used_id = 1 + Math.round(Math.random() * 1000);\n\n    for (ix in class_defs) {\n        key = class_defs[ix];\n        class_map[key] = {};\n    }\n};\n\ninit_module();\n\n/* End of GiDispa namespace function. Return the object which will\n   become the GiDispa global. */\nreturn {\n    classname: 'GiDispa',\n    init: gidispa_init,\n    inited: gidispa_inited,\n    getlibrary: gidispa_getlibrary,\n    \n    get_function: get_function,\n    prepare_resume: prepare_resume,\n    check_autosave: check_autosave,\n    class_register: class_register,\n    class_unregister: class_unregister,\n    class_obj_to_id: class_obj_to_id,\n    class_obj_from_id: class_obj_from_id,\n    retain_array: retain_array,\n    unretain_array: unretain_array,\n    get_retained_array: get_retained_array\n};\n\n};\n\n/* I'm breaking the rule about creating a predefined instance. This is\n   only used by Quixe via GiLoad, which always creates a new instance.\n   I don't know of any other projects which need the backwards\n   compatibility support.\n*/\n// var GiDispa = new GiDispaClass();\n\n// Node-compatible behavior\ntry { exports.GiDispaClass = GiDispaClass; } catch (ex) {};\n\n/* End of GiDispa library. */\n", "'use strict';\n\n/* GiLoad -- a game-file loader for Quixe\n * Designed by Andrew Plotkin <erkyrath@eblong.com>\n * <http://eblong.com/zarf/glulx/quixe/>\n *\n * \n * This Javascript library is copyright 2010-2021 by Andrew Plotkin.\n * It is distributed under the MIT license; see the \"LICENSE\" file.\n *\n * This library loads a game image (by one of several possible methods)\n * and then starts up the display layer and game engine. It also extracts\n * data from a Blorb image, if that's what's provided. It is distributed\n * as part of the Quixe engine, but can also be used by IFVMS. Thus it is\n * equipped to handle both Glulx and Z-code games (naked or Blorbed).\n *\n * (This code makes use of the jQuery library, which therefore must be\n * available.)\n *\n * When you are putting together a Quixe installation page, you call\n * GiLoad.load_run() to get the game started. You should do this in the\n * document's \"onload\" handler, or later. (If you call it before \"onload\" \n * time, it may not work.)\n *\n * You can do this in a couple of different ways:\n *\n * GiLoad.load_run(OPTIONS) -- load and run the game using the options\n *   passed as the argument. If OPTIONS is null or not provided, the\n *   global \"game_options\" object is considered. (The various options are\n *   described below.) This invocation assumes Glulx format.\n *\n * GiLoad.load_run(OPTIONS, IMAGE, IMAGEOPTIONS) -- run the game with the\n *   given options. The IMAGE argument, if not null, should be the game\n *   file itself (a glulx, zcode, or blorb file). The IMAGEOPTIONS describe\n *   how the game file is encoded. It should contain:\n *\n *   IMAGEOPTIONS.format: Describes how the game file is encoded:\n *     \"base64\": a base64-encoded binary file\n *     \"raw\": a binary file stored in a string\n *     \"array\": an array of (numeric) byte values\n *\n *   If the third argument is a string rather than an object, it is taken\n *   to be IMAGEOPTIONS.format.\n *\n *   If OPTIONS is null, the global \"game_options\" object is considered.\n *\n * These are the game options. Most have default values, so you only have\n * to declare the ones you want to change.\n *\n *   use_query_story: If this is true, you (or the player) can use a\n *     \"?story=...\" URL parameter to load any game file. If it is false,\n *     this parameter is ignored. (default: true)\n *   set_page_title: If true, the loader will change the document title\n *     to describe the game being loaded. If false, the document title\n *     will be left alone. (default: true)\n *   default_page_title: A default label for the game, if none could be\n *     extracted from the metadata or URL. (default: \"Game\")\n *   engine_name: Label used in the page title along with default_page_title.\n *     (default: \"Quixe\" or \"IFVMS\")\n *   default_story: The URL of the game file to load, if not otherwise\n *     provided.\n *   proxy_url: The URL of the web-app service which is used to convert\n *     binary data to Javascript, if the browser needs that. (default:\n *     https://zcode.appspot.com/proxy/)\n *   resources: An object which describes all the available resources\n *     if they are provided as static URL data. (If this is not provided,\n *     we rely on Blorb resources.) This can be an object or a string;\n *     in the latter case, we look up a global object with that name.\n *     (See the gi_blorb.js library for the format.)\n *   image_info_map: Same as resources, but the data only describes\n *     image data. (This is an older format, still supported.)\n *   exit_warning: A message to display (in a blue warning pane) when\n *     the game exits. If empty or null, no message is displayed.\n *     (default: \"The game session has ended.\")\n *   do_vm_autosave: If set, the VM will check for a snapshot when\n *     launching, and load it if present. The VM will also save a snapshot\n *     after every move. (default: false)\n *   clear_vm_autosave: If set, the VM will clear any snapshot at launch\n *     (so will not load one even if do_vm_autosave is set). (default:\n *     false)\n *   game_format_name: Label used in loading error messages. (default:\n *     \"Glulx\" for Quixe, \"\" otherwise)\n *   blorb_gamechunk_type: Chunk type to extract from a Blorb file.\n *     (default: \"GLUL\" for Quixe, null otherwise)\n *   vm: The game engine interface object. (default: Quixe)\n *   io: The display layer interface object. (default: Glk)\n *   \n *   You can also include any of the display options used by the GlkOte\n *   library, such as gameport, windowport, spacing, ...\n *   And also the interpreter options used by the Quixe library, such as\n *   rethrow_exceptions, ...\n *\n *   For backwards compatibility, if options.vm is omitted or is the\n *   windows.Quixe object, then several other options (engine_name,\n *   blorb_gamechunk_type, game_format_name) are set up with values\n *   appropriate for Glulx game files.\n *\n */\n\n/* All state is contained in GiLoadClass. */\n\nvar GiLoadClass = function() {\n\n/* Start with the defaults. These can be modified later by the game_options\n   defined in the HTML file.\n\n   Note that the \"vm\" and \"io\" entries are not filled in here, because\n   we don't know whether the Quixe or Glk libraries were loaded before\n   this one. We'll fill them in at load_run() time.\n*/\nvar all_options = {\n    vm: null,              // default game engine (Quixe)\n    io: null,              // default display layer (Glk)\n    spacing: 4,            // default spacing between windows\n    use_query_story: true, // use the ?story= URL parameter (if provided)\n    default_story: null,   // story URL to use if not otherwise set\n    set_page_title: true,  // set the window title to the game name\n    default_page_title: 'Game', // fallback game name to use for title\n    game_format_name: '',  // used in error messages\n    exit_warning: 'The game session has ended.',\n    resources: null,       // look for resources in Blorb data\n    image_info_map: null,  // look for images in Blorb data\n    proxy_url: 'https://zcode.appspot.com/proxy/'\n};\n\nvar gameurl = null;  /* The URL we are loading. */\nvar started = false; /* True once start_game() runs */\n    \nvar GlkOte = null; /* imported API object -- for GlkOte.log */\n\n/* Begin the loading process. This is what you call to start a game;\n   it takes care of starting the Glk and Quixe modules, when the game\n   file is available.\n*/\nfunction load_run(optobj, image, imageoptions) {\n\n    /* There are a couple of different calling conventions that we have\n       to distinguish here. */\n\n    if (!imageoptions) {\n        // None provided. (There should be no image argument either.)\n        imageoptions = {};\n    }\n    else if (typeof(imageoptions) == 'string') {\n        // An image_format string. (Old calling format.)\n        imageoptions = { format:imageoptions };\n    }\n    else {\n        // A map of image options, including image_format.\n    }\n\n    /* Now look at the provided arguments. */\n\n    var image_format = imageoptions.format;\n    if (!image_format)\n        image_format = 'array';\n\n    /* Set the default entries for the interface objects that come from\n       other libraries. (If no such libraries have been loaded, then\n       these do nothing. The game_options passed in can override each of\n       these references!)\n    */\n    all_options.io = window.Glk;\n    all_options.vm = window.Quixe;\n    all_options.GiLoad = this;\n    all_options.GlkOte = null;\n    all_options.GiDispa = null;\n    all_options.Blorb = null;\n    \n    /* The game_options object could be provided via an argument. If not,\n       we use the global game_options. */\n    if (!optobj)\n        optobj = window.game_options;\n\n    if (optobj && window.Quixe\n        && ((!optobj.vm) || optobj.vm === window.Quixe)) {\n        /* If we are going to wind up with the Quixe engine -- either from\n           game_options or as a default -- we throw in some more defaults. */\n        all_options.engine_name = 'Quixe';\n        all_options.blorb_gamechunk_type = 'GLUL';\n        all_options.game_format_name = 'Glulx';\n    }\n\n    /* Pull in the values from the game_options, which override the defaults\n       set above. */\n    if (optobj) {\n        jQuery.extend(all_options, optobj);\n    }\n\n    /* If the GlkOte, GiDispa, Blorb classes were not provided, create\n       them now (if possible). */\n    if ((!all_options.GlkOte) && window.GlkOteClass) {\n        all_options.GlkOte = new window.GlkOteClass();\n    }\n    if ((!all_options.GiDispa) && window.GiDispaClass) {\n        all_options.GiDispa = new window.GiDispaClass();\n    }\n    if ((!all_options.Blorb) && window.BlorbClass) {\n        all_options.Blorb = new window.BlorbClass();\n    }\n    \n    GlkOte = all_options.GlkOte; /* our copy of the reference */\n\n    /* If the resources is a string, look for a global object of\n       that name. If there isn't one, delete that option. (The \n       resources could also be an object already, in which case\n       we leave it as is.) */\n    if (all_options.resources != undefined) {\n        if (jQuery.type(all_options.resources) === 'string') {\n            if (window[all_options.resources])\n                all_options.resources = window[all_options.resources];\n            else\n                delete all_options.resources;\n        }\n    }\n    /* Same deal for image_info_map. (You wouldn't usually have both,\n       mind you.) */\n    if (all_options.image_info_map != undefined) {\n        if (jQuery.type(all_options.image_info_map) === 'string') {\n            if (window[all_options.image_info_map])\n                all_options.image_info_map = window[all_options.image_info_map];\n            else\n                delete all_options.image_info_map;\n        }\n    }\n\n    /* The first question is, what's the game file URL? */\n\n    gameurl = null;\n\n    if (all_options.use_query_story) {\n        /* Use ?story= URL parameter, if present and accepted. */\n        var qparams = get_query_params();\n        gameurl = qparams['story'];\n    }\n\n    if (!gameurl && image) {\n        /* The story data is already loaded -- it's not an a URL at all. \n           Decode it, and then fire it off. */\n        GlkOte.log('GiLoad: trying pre-loaded load (' + image_format + ')...');\n        switch (image_format) {\n        case 'base64':\n            image = decode_base64(image);\n            break;\n        case 'raw':\n            image = decode_raw_text(image);\n            break;\n        case 'array':\n            /* Leave image alone */\n            break;\n        default:\n            all_options.io.fatal_error(\"Could not decode story file data: \" + image_format);\n            return;\n        }\n\n        start_game(image);\n        return;\n    }\n\n    if (!gameurl) {\n        /* Go with the \"default_story\" option parameter, if present. */\n        gameurl = all_options.default_story;\n    }\n\n    if (!gameurl) {\n        all_options.io.fatal_error(\"No story file specified!\");\n        return;\n    }\n\n    //GlkOte.log('GiLoad: gameurl: ' + gameurl);\n    /* The gameurl is now known. (It should not change after this point.)\n       The next question is, how do we load it in? */\n\n    /* If an image file was passed in, we didn't use it. So we might as\n       well free its memory at this point. */\n    image = null;\n\n    /* The logic of the following code is adapted from Parchment's\n       file.js. It's probably obsolete at this point -- I suspect\n       that binary_supported and crossorigin_supported will wind up\n       true in all modern browsers. Why throw away code, though... */\n\n    var xhr = new XMLHttpRequest(); /* ### not right on IE? */\n    var binary_supported = (xhr.overrideMimeType !== undefined);\n    /* I'm told that Opera's overrideMimeType() doesn't work, but\n       I'm not inclined to worry about it these days. */\n    var crossorigin_supported = (xhr.withCredentials !== undefined);\n    xhr = null;\n\n    var regex_urldomain = /^(file:|(\\w+:)?\\/\\/[^\\/?#]+)/;\n    var page_domain = regex_urldomain.exec(location)[0];\n    var data_exec = regex_urldomain.exec(gameurl);\n    var is_relative = data_exec ? false : true;\n    var data_domain = data_exec ? data_exec[0] : page_domain;\n\n    var same_origin = (page_domain == data_domain);\n    if (navigator.userAgent.match(/chrome/i) && data_domain == 'file:') {\n        /* Chrome enforces a stricter same-origin policy for file: URLs --\n           it doesn't want to trawl your hard drive for random files.\n           Other browsers may pick this up someday, but for now, it's\n           only Chrome. */\n        same_origin = false;\n    }\n\n    /* Crude test for whether the URL is a Javascript file -- just\n       check for a \".js\" suffix. */\n    var old_js_url = gameurl.match(/[.]js$/i);\n\n    GlkOte.log('GiLoad: is_relative=' + is_relative + ', same_origin=' + same_origin + ', binary_supported=' + binary_supported + ', crossorigin_supported=' + crossorigin_supported);\n\n    if (old_js_url && same_origin) {\n        /* Old-fashioned Javascript file -- the output of Parchment's\n           zcode2js tool. When loaded and eval'ed, this will call\n           a global function processBase64Zcode() with base64 data\n           as the argument. */\n        GlkOte.log('GiLoad: trying old-fashioned load...');\n        window.processBase64Zcode = function(val) { \n            start_game(decode_base64(val));\n        };\n        jQuery.ajax(gameurl, {\n                'type': 'GET',\n                dataType: 'script',\n                cache: true,\n                error: function(jqxhr, textstatus, errorthrown) {\n                    all_options.io.fatal_error(\"The story could not be loaded. (\" + gameurl + \"): Error \" + textstatus + \": \" + errorthrown);\n                }\n        });\n        return;\n    }\n\n    if (old_js_url) {\n        /* Javascript file in a different domain. We'll insert it as a <script>\n           tag; that will force it to load, and invoke a processBase64Zcode()\n           function as above. */\n        GlkOte.log('GiLoad: trying script load...');\n        window.processBase64Zcode = function(val) { \n            start_game(decode_base64(val));\n        };\n        var headls = $('head');\n        if (!headls.length) {\n            all_options.io.fatal_error(\"This page has no <head> element!\");\n            return;\n        }\n        var script = $('<script>', \n            { src:gameurl, 'type':\"text/javascript\" });\n        /* jQuery is now sensitive about this, and will not allow it as\n          a Chrome work-around. We use a raw DOM method instead. */\n        // headls.append(script);\n        headls.get(0).appendChild(script.get(0));\n        return;\n    }\n\n    if (binary_supported && same_origin) {\n        /* We can do an Ajax GET of the binary data. */\n        GlkOte.log('GiLoad: trying binary load...');\n        jQuery.ajax(gameurl, {\n                'type': 'GET',\n                    beforeSend: function(jqxhr, settings) {\n                    /* This ensures that the data doesn't get decoded or\n                       munged in any way. */\n                    jqxhr.overrideMimeType('text/plain; charset=x-user-defined');\n                },\n                success: function(response, textstatus, errorthrown) {\n                    start_game(decode_raw_text(response));\n                },\n                error: function(jqxhr, textstatus, errorthrown) {\n                    all_options.io.fatal_error(\"The story could not be loaded. (\" + gameurl + \"): Error \" + textstatus + \": \" + errorthrown);\n                }\n        });\n        return;\n    }\n\n    if (data_domain == 'file:') {\n        /* All the remaining options go through the proxy. But the proxy\n           can't get at the local hard drive, so it's hopeless.\n           (This case occurs only on Chrome, with its restrictive\n           same-origin-file: policy.) */\n        all_options.io.fatal_error(\"The story could not be loaded. (\" + gameurl + \"): A local file cannot be sent to the proxy.\");\n        return;\n    }\n\n    /* All the remaining options go through the proxy. But the proxy doesn't\n       understand relative URLs, so we absolutize it if necessary. */\n    var absgameurl = gameurl;\n    if (is_relative) {\n        absgameurl = absolutize(gameurl);\n        GlkOte.log('GiLoad: absolutize ' + gameurl + ' to ' + absgameurl);\n    }\n\n    if (crossorigin_supported) {\n        /* Either we can't load binary data, or the data is on a different\n           domain. Either way, we'll go through the proxy, which will\n           convert it to base64 for us. The proxy gives the right headers\n           to make cross-origin Ajax work. */\n        GlkOte.log('GiLoad: trying proxy load... (' + all_options.proxy_url + ')');\n        jQuery.ajax(all_options.proxy_url, {\n                'type': 'GET',\n                data: { encode: 'base64', url: absgameurl },\n                error: function(jqxhr, textstatus, errorthrown) {\n                    /* I would like to display the responseText here, but\n                       most servers return a whole HTML page, and that doesn't\n                       fit into fatal_error. */\n                    all_options.io.fatal_error(\"The story could not be loaded. (\" + gameurl + \"): Error \" + textstatus + \": \" + errorthrown);\n                },\n                success: function(response, textstatus, errorthrown) {\n                    start_game(decode_base64(response));\n                }\n        });\n        return;\n    }\n\n    if (true) {\n        /* Cross-origin Ajax isn't available. We can still use the proxy,\n           but we'll have to insert a <script> tag to do it. */\n        var fullurl = all_options.proxy_url + '?encode=base64&callback=processBase64Zcode&url=' + absgameurl;\n        GlkOte.log('GiLoad: trying proxy-script load... (' + fullurl + ')');\n        window.processBase64Zcode = function(val) { \n            start_game(decode_base64(val));\n        };\n        var headls = $('head');\n        if (!headls.length) {\n            all_options.io.fatal_error(\"This page has no <head> element!\");\n            return;\n        }\n        var script = $('<script>', \n            { src:fullurl, 'type':\"text/javascript\" });\n        headls.append(script);\n        return;\n    }\n\n    all_options.io.fatal_error(\"The story could not be loaded. (\" + gameurl + \"): I don't know how to load this data.\");\n}\n\n/* Take apart the query string of the current URL, and turn it into\n   an object map.\n   (Adapted from querystring.js by Adam Vandenberg.)\n*/\nfunction get_query_params() {\n    var map = {};\n\n    var qs = location.search.substring(1, location.search.length);\n    if (qs.length) {\n        var args = qs.split('&');\n\n        qs = qs.replace(/\\+/g, ' ');\n        for (var ix = 0; ix < args.length; ix++) {\n            var pair = args[ix].split('=');\n            var name = decodeURIComponent(pair[0]);\n            \n            var value = (pair.length==2)\n                ? decodeURIComponent(pair[1])\n                : name;\n            \n            map[name] = value;\n        }\n    }\n\n    return map;\n}\n\n/* Turn a relative URL absolute, based on document.location.\n   (This doesn't make sense in a headless Node environment,\n   but this function shouldn't be called in such environments.)\n*/\nfunction absolutize(url) {\n    var res = new URL(url, document.location.href);\n    return res.href;\n}\n\n/* In the following functions, \"decode\" means turning native string data\n   into an array of numbers; \"encode\" is the other direction. That's weird,\n   I know. It's because an array of byte values is the natural data format\n   of Glulx code.\n*/\n\n/* Convert a byte string into an array of numeric byte values. */\nfunction decode_raw_text(str) {\n    var arr = Array(str.length);\n    var ix;\n    for (ix=0; ix<str.length; ix++) {\n        arr[ix] = str.charCodeAt(ix) & 0xFF;\n    }\n    return arr;\n}\n\n/* Convert a base64 string into an array of numeric byte values.\n*/\nfunction decode_base64(base64data)\n{\n    var data = atob(base64data);\n    var image = Array(data.length);\n    var ix;\n    \n    for (ix=0; ix<data.length; ix++)\n        image[ix] = data.charCodeAt(ix);\n    \n    return image;\n}\n\n/* Start the game (after de-blorbing, if necessary).\n   This is invoked by whatever callback received the loaded game file.\n*/\nfunction start_game(image) {\n    if (image.length == 0) {\n        all_options.io.fatal_error(\"No game file was loaded. (Zero-length response.)\");\n        return;\n    }\n\n    if (image[0] == 0x46 && image[1] == 0x4F && image[2] == 0x52 && image[3] == 0x4D) {\n        var formtype = String.fromCharCode(image[8], image[9], image[10], image[11]);\n\n        if (formtype == 'IFZS') {\n            all_options.io.fatal_error(\"This is a saved-game file, not a \"+all_options.game_format_name+\" game file. You must launch the game first, then restore your save.\");\n            return;\n        }\n\n        if (formtype != 'IFRS') {\n            all_options.io.fatal_error(\"This IFF file is not a Blorb file!\");\n            return;\n        }\n\n        if (all_options.blorb_gamechunk_type) {\n            if (!all_options.Blorb) {\n                all_options.io.fatal_error(\"Blorb file could not be parsed because no BlorbClass is available.\");\n                return;\n            }\n            try {\n                // Normally we are only interested in the game file and images.\n                var retainuses = { 'exec':true, 'pict':true, 'data':true };\n                if (all_options.retainuses !== undefined) {\n                    retainuses = all_options.retainuses;\n                }\n                all_options.Blorb.init(image, { format:'blorbbytes', retainuses:retainuses });\n                image = all_options.Blorb.get_exec_data(all_options.blorb_gamechunk_type);\n            }\n            catch (ex) {\n                all_options.io.fatal_error(\"Blorb file could not be parsed: \" + ex);\n                return;\n            }\n        }\n        if (!image) {\n            all_options.io.fatal_error(\"Blorb file contains no \"+all_options.game_format_name+\" game!\");\n            return;\n        }\n    }\n\n    /* If Blorb wasn't inited from the image data, we try to init it\n       some other way. */\n    if (all_options.Blorb && !all_options.Blorb.inited()) {\n        if (all_options.image_info_map) {\n            all_options.Blorb.init(all_options.image_info_map, { format:'infomap' });\n        }\n        else if (all_options.resources) {\n            all_options.Blorb.init(all_options.resource_array);\n        }\n        else {\n            /* Init with no resources. */\n            all_options.Blorb.init([]);\n        }\n    }\n\n    /* Figure out the title. */\n    {\n        var title = null;\n        if (all_options.Blorb)\n            title = all_options.Blorb.get_metadata('title');\n        if (!title && gameurl) \n            title = gameurl.slice(gameurl.lastIndexOf(\"/\") + 1);\n        if (!title)\n            title = all_options.default_page_title;\n        if (!title)\n            title = 'Game';\n\n        if (!all_options.recording_label)\n            all_options.recording_label = title;\n\n        if (all_options.set_page_title)\n            document.title = title + \" - \" + all_options.engine_name;\n    }\n\n    /* Pass the game image file along to the VM engine. */\n    // Convert a Uint8Array into an Array\n    const image_array = Array.from(image)\n    all_options.vm.init(image_array, all_options);\n\n    started = true;\n    \n    /* Now fire up the display library. This will take care of starting\n       the VM engine, once the window is properly set up. */\n    all_options.io.init(all_options);\n}\n\n/* Has load_run() been called (successfully)? Success means we made it\n   all the way through start_game(). */\nfunction is_inited() {\n    return started;\n}\n\nfunction get_library(val) {\n    switch (val) {\n        case 'GlkOte': return GlkOte;\n        case 'GiDispa': return all_options.GiDispa;\n        case 'Blorb': return all_options.Blorb;\n        case 'VM': return all_options.vm; // typically Quixe\n        case 'IO': return all_options.io; // normally Glk\n    }\n    /* Unrecognized library name. */\n    return null;\n}\n    \n/* End of GiLoad namespace function. Return the object which will\n   become the GiLoad global. */\nreturn {\n    classname: 'GiLoad',\n    load_run: load_run,\n    inited: is_inited,\n    getlibrary: get_library,\n};\n\n};\n\n/* GiLoad is an instance of GiLoadClass, ready to init.\n   (The BASESIXTYFOURTOP in I7's Quixe template relies on GiLoad\n   existing in the global environment.) */\nvar GiLoad = new GiLoadClass();\n\n// Node-compatible behavior\ntry { exports.GiLoad = GiLoad; exports.GiLoadClass = GiLoadClass; } catch (ex) {};\n\n/* End of GiLoad library. */\n", "// Export Quixe engine\n\nimport QuixeModule from '../upstream/quixe/src/quixe/quixe.js'\nimport QuixeDispatch from '../upstream/quixe/src/quixe/gi_dispa.js'\nimport QuixeLoad from '../upstream/quixe/src/quixe/gi_load.js'\n\nexport const Quixe = QuixeModule.Quixe\nexport const GiDispa = QuixeDispatch.GiDispaClass\nexport const GiLoad = QuixeLoad.GiLoad"],
  "mappings": "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",
  "names": []
}
